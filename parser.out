Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AND
    ARROW
    ARROWMAP
    AS
    BOOL
    BREAK
    CASE
    CATCH
    CLASS
    CLONE
    CLOSETAG
    CONCATENATEEQUAL
    CONST
    CONTINUE
    DECLARE
    DEFAULT
    DO
    DOT
    DOUBLEDOT
    ELSE
    ELSEIF
    EMPTY
    ENDSWITCH
    EQ
    EXCEPTION
    EXTENDS
    FGETS
    FINAL
    FINALLY
    FOREACH
    FUNCTION
    GEQ
    GLOBAL
    GT
    ID
    IMPLEMENTS
    INCLUDE
    INSTANCEOF
    INTERFACE
    ISSET
    LEQ
    LIST
    LT
    MINUSEQUAL
    NAMESPACE
    NEQ
    NEW
    NOT
    OPENTAG
    OR
    PLUSEQUAL
    POTENCIA
    PRIVATE
    PROTECTED
    PUBLIC
    RETURN
    STATIC
    STDIN
    STRICTEQ
    STRICTNEQ
    THIS
    THROW
    TRY

Grammar

Rule 0     S' -> programa
Rule 1     programa -> sentencia
Rule 2     programa -> sentencia programa
Rule 3     sentencia -> asignacion
Rule 4     sentencia -> impresion
Rule 5     sentencia -> comparacion
Rule 6     sentencia -> estructurasProgram
Rule 7     asignacion -> VARIABLE EQUALS operaArit SEMICOLON
Rule 8     impresion -> ECHO imprimir SEMICOLON
Rule 9     impresion -> PRINT imprimir SEMICOLON
Rule 10    estructurasProgram -> controlStructure
Rule 11    estructurasProgram -> dataStructure
Rule 12    controlStructure -> if
Rule 13    controlStructure -> for
Rule 14    controlStructure -> while
Rule 15    controlStructure -> switch
Rule 16    dataStructure -> array
Rule 17    dataStructure -> <empty>
Rule 18    array -> VARIABLE EQUALS LBRACKET elementos RBRACKET SEMICOLON
Rule 19    array -> VARIABLE EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON
Rule 20    elementos -> valor COMMA elementos
Rule 21    elementos -> valor
Rule 22    elementos -> empty
Rule 23    funcionDeclarate -> <empty>
Rule 24    classDeclarate -> <empty>
Rule 25    condition -> IF LPAREN valor RPAREN LBRACE RBRACE
Rule 26    if -> IF
Rule 27    for -> FOR
Rule 28    while -> WHILE
Rule 29    switch -> SWITCH
Rule 30    imprimir -> LPAREN repiteValores RPAREN
Rule 31    imprimir -> LPAREN RPAREN
Rule 32    imprimir -> repiteValores
Rule 33    imprimir -> empty
Rule 34    valor -> INT
Rule 35    valor -> FLOAT
Rule 36    valor -> VARIABLE
Rule 37    valor -> STRING
Rule 38    comparacion -> INT operador INT
Rule 39    comparacion -> FLOAT operador FLOAT
Rule 40    comparacion -> INT operador FLOAT
Rule 41    comparacion -> FLOAT operador INT
Rule 42    valor -> TRUE
Rule 43    valor -> FALSE
Rule 44    repiteValores -> valor COMMA repiteValores
Rule 45    repiteValores -> valor
Rule 46    operaArit -> valor
Rule 47    operaArit -> valor operador operaArit
Rule 48    operador -> PLUS
Rule 49    operador -> MINUS
Rule 50    operador -> TIMES
Rule 51    operador -> DIVIDE
Rule 52    operador -> MODULO
Rule 53    empty -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 
ARRAY                : 19
ARROW                : 
ARROWMAP             : 
AS                   : 
BOOL                 : 
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
CLONE                : 
CLOSETAG             : 
COMMA                : 20 44
CONCATENATEEQUAL     : 
CONST                : 
CONTINUE             : 
DECLARE              : 
DEFAULT              : 
DIVIDE               : 51
DO                   : 
DOT                  : 
DOUBLEDOT            : 
ECHO                 : 8
ELSE                 : 
ELSEIF               : 
EMPTY                : 
ENDSWITCH            : 
EQ                   : 
EQUALS               : 7 18 19
EXCEPTION            : 
EXTENDS              : 
FALSE                : 43
FGETS                : 
FINAL                : 
FINALLY              : 
FLOAT                : 35 39 39 40 41
FOR                  : 27
FOREACH              : 
FUNCTION             : 
GEQ                  : 
GLOBAL               : 
GT                   : 
ID                   : 
IF                   : 25 26
IMPLEMENTS           : 
INCLUDE              : 
INSTANCEOF           : 
INT                  : 34 38 38 40 41
INTERFACE            : 
ISSET                : 
LBRACE               : 25
LBRACKET             : 18
LEQ                  : 
LIST                 : 
LPAREN               : 19 25 30 31
LT                   : 
MINUS                : 49
MINUSEQUAL           : 
MODULO               : 52
NAMESPACE            : 
NEQ                  : 
NEW                  : 
NOT                  : 
OPENTAG              : 
OR                   : 
PLUS                 : 48
PLUSEQUAL            : 
POTENCIA             : 
PRINT                : 9
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
RBRACE               : 25
RBRACKET             : 18
RETURN               : 
RPAREN               : 19 25 30 31
SEMICOLON            : 7 8 9 18 19
STATIC               : 
STDIN                : 
STRICTEQ             : 
STRICTNEQ            : 
STRING               : 37
SWITCH               : 29
THIS                 : 
THROW                : 
TIMES                : 50
TRUE                 : 42
TRY                  : 
VARIABLE             : 7 18 19 36
WHILE                : 28
error                : 

Nonterminals, with rules where they appear

array                : 16
asignacion           : 3
classDeclarate       : 
comparacion          : 5
condition            : 
controlStructure     : 10
dataStructure        : 11
elementos            : 18 19 20
empty                : 22 33
estructurasProgram   : 6
for                  : 13
funcionDeclarate     : 
if                   : 12
impresion            : 4
imprimir             : 8 9
operaArit            : 7 47
operador             : 38 39 40 41 47
programa             : 2 0
repiteValores        : 30 32 44
sentencia            : 1 2
switch               : 15
valor                : 20 21 25 44 45 46 47
while                : 14

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . sentencia
    (2) programa -> . sentencia programa
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (8) impresion -> . ECHO imprimir SEMICOLON
    (9) impresion -> . PRINT imprimir SEMICOLON
    (38) comparacion -> . INT operador INT
    (39) comparacion -> . FLOAT operador FLOAT
    (40) comparacion -> . INT operador FLOAT
    (41) comparacion -> . FLOAT operador INT
    (10) estructurasProgram -> . controlStructure
    (11) estructurasProgram -> . dataStructure
    (12) controlStructure -> . if
    (13) controlStructure -> . for
    (14) controlStructure -> . while
    (15) controlStructure -> . switch
    (16) dataStructure -> . array
    (17) dataStructure -> .
    (26) if -> . IF
    (27) for -> . FOR
    (28) while -> . WHILE
    (29) switch -> . SWITCH
    (18) array -> . VARIABLE EQUALS LBRACKET elementos RBRACKET SEMICOLON
    (19) array -> . VARIABLE EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON

  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    $end            reduce using rule 17 (dataStructure -> .)
    IF              shift and go to state 19
    FOR             shift and go to state 20
    WHILE           shift and go to state 21
    SWITCH          shift and go to state 22

  ! VARIABLE        [ reduce using rule 17 (dataStructure -> .) ]
  ! ECHO            [ reduce using rule 17 (dataStructure -> .) ]
  ! PRINT           [ reduce using rule 17 (dataStructure -> .) ]
  ! INT             [ reduce using rule 17 (dataStructure -> .) ]
  ! FLOAT           [ reduce using rule 17 (dataStructure -> .) ]
  ! IF              [ reduce using rule 17 (dataStructure -> .) ]
  ! FOR             [ reduce using rule 17 (dataStructure -> .) ]
  ! WHILE           [ reduce using rule 17 (dataStructure -> .) ]
  ! SWITCH          [ reduce using rule 17 (dataStructure -> .) ]

    programa                       shift and go to state 1
    sentencia                      shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    if                             shift and go to state 14
    for                            shift and go to state 15
    while                          shift and go to state 16
    switch                         shift and go to state 17
    array                          shift and go to state 18

state 1

    (0) S' -> programa .



state 2

    (1) programa -> sentencia .
    (2) programa -> sentencia . programa
    (1) programa -> . sentencia
    (2) programa -> . sentencia programa
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (8) impresion -> . ECHO imprimir SEMICOLON
    (9) impresion -> . PRINT imprimir SEMICOLON
    (38) comparacion -> . INT operador INT
    (39) comparacion -> . FLOAT operador FLOAT
    (40) comparacion -> . INT operador FLOAT
    (41) comparacion -> . FLOAT operador INT
    (10) estructurasProgram -> . controlStructure
    (11) estructurasProgram -> . dataStructure
    (12) controlStructure -> . if
    (13) controlStructure -> . for
    (14) controlStructure -> . while
    (15) controlStructure -> . switch
    (16) dataStructure -> . array
    (17) dataStructure -> .
    (26) if -> . IF
    (27) for -> . FOR
    (28) while -> . WHILE
    (29) switch -> . SWITCH
    (18) array -> . VARIABLE EQUALS LBRACKET elementos RBRACKET SEMICOLON
    (19) array -> . VARIABLE EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON

  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 1 (programa -> sentencia .)
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
    $end            reduce using rule 1 (programa -> sentencia .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    IF              shift and go to state 19
    FOR             shift and go to state 20
    WHILE           shift and go to state 21
    SWITCH          shift and go to state 22

  ! VARIABLE        [ reduce using rule 17 (dataStructure -> .) ]
  ! ECHO            [ reduce using rule 17 (dataStructure -> .) ]
  ! PRINT           [ reduce using rule 17 (dataStructure -> .) ]
  ! INT             [ reduce using rule 17 (dataStructure -> .) ]
  ! FLOAT           [ reduce using rule 17 (dataStructure -> .) ]
  ! IF              [ reduce using rule 17 (dataStructure -> .) ]
  ! FOR             [ reduce using rule 17 (dataStructure -> .) ]
  ! WHILE           [ reduce using rule 17 (dataStructure -> .) ]
  ! SWITCH          [ reduce using rule 17 (dataStructure -> .) ]
  ! $end            [ reduce using rule 17 (dataStructure -> .) ]

    sentencia                      shift and go to state 2
    programa                       shift and go to state 23
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    if                             shift and go to state 14
    for                            shift and go to state 15
    while                          shift and go to state 16
    switch                         shift and go to state 17
    array                          shift and go to state 18

state 3

    (3) sentencia -> asignacion .

    VARIABLE        reduce using rule 3 (sentencia -> asignacion .)
    ECHO            reduce using rule 3 (sentencia -> asignacion .)
    PRINT           reduce using rule 3 (sentencia -> asignacion .)
    INT             reduce using rule 3 (sentencia -> asignacion .)
    FLOAT           reduce using rule 3 (sentencia -> asignacion .)
    IF              reduce using rule 3 (sentencia -> asignacion .)
    FOR             reduce using rule 3 (sentencia -> asignacion .)
    WHILE           reduce using rule 3 (sentencia -> asignacion .)
    SWITCH          reduce using rule 3 (sentencia -> asignacion .)
    $end            reduce using rule 3 (sentencia -> asignacion .)


state 4

    (4) sentencia -> impresion .

    VARIABLE        reduce using rule 4 (sentencia -> impresion .)
    ECHO            reduce using rule 4 (sentencia -> impresion .)
    PRINT           reduce using rule 4 (sentencia -> impresion .)
    INT             reduce using rule 4 (sentencia -> impresion .)
    FLOAT           reduce using rule 4 (sentencia -> impresion .)
    IF              reduce using rule 4 (sentencia -> impresion .)
    FOR             reduce using rule 4 (sentencia -> impresion .)
    WHILE           reduce using rule 4 (sentencia -> impresion .)
    SWITCH          reduce using rule 4 (sentencia -> impresion .)
    $end            reduce using rule 4 (sentencia -> impresion .)


state 5

    (5) sentencia -> comparacion .

    VARIABLE        reduce using rule 5 (sentencia -> comparacion .)
    ECHO            reduce using rule 5 (sentencia -> comparacion .)
    PRINT           reduce using rule 5 (sentencia -> comparacion .)
    INT             reduce using rule 5 (sentencia -> comparacion .)
    FLOAT           reduce using rule 5 (sentencia -> comparacion .)
    IF              reduce using rule 5 (sentencia -> comparacion .)
    FOR             reduce using rule 5 (sentencia -> comparacion .)
    WHILE           reduce using rule 5 (sentencia -> comparacion .)
    SWITCH          reduce using rule 5 (sentencia -> comparacion .)
    $end            reduce using rule 5 (sentencia -> comparacion .)


state 6

    (6) sentencia -> estructurasProgram .

    VARIABLE        reduce using rule 6 (sentencia -> estructurasProgram .)
    ECHO            reduce using rule 6 (sentencia -> estructurasProgram .)
    PRINT           reduce using rule 6 (sentencia -> estructurasProgram .)
    INT             reduce using rule 6 (sentencia -> estructurasProgram .)
    FLOAT           reduce using rule 6 (sentencia -> estructurasProgram .)
    IF              reduce using rule 6 (sentencia -> estructurasProgram .)
    FOR             reduce using rule 6 (sentencia -> estructurasProgram .)
    WHILE           reduce using rule 6 (sentencia -> estructurasProgram .)
    SWITCH          reduce using rule 6 (sentencia -> estructurasProgram .)
    $end            reduce using rule 6 (sentencia -> estructurasProgram .)


state 7

    (7) asignacion -> VARIABLE . EQUALS operaArit SEMICOLON
    (18) array -> VARIABLE . EQUALS LBRACKET elementos RBRACKET SEMICOLON
    (19) array -> VARIABLE . EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON

    EQUALS          shift and go to state 24


state 8

    (8) impresion -> ECHO . imprimir SEMICOLON
    (30) imprimir -> . LPAREN repiteValores RPAREN
    (31) imprimir -> . LPAREN RPAREN
    (32) imprimir -> . repiteValores
    (33) imprimir -> . empty
    (44) repiteValores -> . valor COMMA repiteValores
    (45) repiteValores -> . valor
    (53) empty -> .
    (34) valor -> . INT
    (35) valor -> . FLOAT
    (36) valor -> . VARIABLE
    (37) valor -> . STRING
    (42) valor -> . TRUE
    (43) valor -> . FALSE

    LPAREN          shift and go to state 26
    SEMICOLON       reduce using rule 53 (empty -> .)
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    VARIABLE        shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    imprimir                       shift and go to state 25
    repiteValores                  shift and go to state 27
    empty                          shift and go to state 28
    valor                          shift and go to state 29

state 9

    (9) impresion -> PRINT . imprimir SEMICOLON
    (30) imprimir -> . LPAREN repiteValores RPAREN
    (31) imprimir -> . LPAREN RPAREN
    (32) imprimir -> . repiteValores
    (33) imprimir -> . empty
    (44) repiteValores -> . valor COMMA repiteValores
    (45) repiteValores -> . valor
    (53) empty -> .
    (34) valor -> . INT
    (35) valor -> . FLOAT
    (36) valor -> . VARIABLE
    (37) valor -> . STRING
    (42) valor -> . TRUE
    (43) valor -> . FALSE

    LPAREN          shift and go to state 26
    SEMICOLON       reduce using rule 53 (empty -> .)
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    VARIABLE        shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    imprimir                       shift and go to state 36
    repiteValores                  shift and go to state 27
    empty                          shift and go to state 28
    valor                          shift and go to state 29

state 10

    (38) comparacion -> INT . operador INT
    (40) comparacion -> INT . operador FLOAT
    (48) operador -> . PLUS
    (49) operador -> . MINUS
    (50) operador -> . TIMES
    (51) operador -> . DIVIDE
    (52) operador -> . MODULO

    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIVIDE          shift and go to state 41
    MODULO          shift and go to state 42

    operador                       shift and go to state 37

state 11

    (39) comparacion -> FLOAT . operador FLOAT
    (41) comparacion -> FLOAT . operador INT
    (48) operador -> . PLUS
    (49) operador -> . MINUS
    (50) operador -> . TIMES
    (51) operador -> . DIVIDE
    (52) operador -> . MODULO

    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIVIDE          shift and go to state 41
    MODULO          shift and go to state 42

    operador                       shift and go to state 43

state 12

    (10) estructurasProgram -> controlStructure .

    VARIABLE        reduce using rule 10 (estructurasProgram -> controlStructure .)
    ECHO            reduce using rule 10 (estructurasProgram -> controlStructure .)
    PRINT           reduce using rule 10 (estructurasProgram -> controlStructure .)
    INT             reduce using rule 10 (estructurasProgram -> controlStructure .)
    FLOAT           reduce using rule 10 (estructurasProgram -> controlStructure .)
    IF              reduce using rule 10 (estructurasProgram -> controlStructure .)
    FOR             reduce using rule 10 (estructurasProgram -> controlStructure .)
    WHILE           reduce using rule 10 (estructurasProgram -> controlStructure .)
    SWITCH          reduce using rule 10 (estructurasProgram -> controlStructure .)
    $end            reduce using rule 10 (estructurasProgram -> controlStructure .)


state 13

    (11) estructurasProgram -> dataStructure .

    VARIABLE        reduce using rule 11 (estructurasProgram -> dataStructure .)
    ECHO            reduce using rule 11 (estructurasProgram -> dataStructure .)
    PRINT           reduce using rule 11 (estructurasProgram -> dataStructure .)
    INT             reduce using rule 11 (estructurasProgram -> dataStructure .)
    FLOAT           reduce using rule 11 (estructurasProgram -> dataStructure .)
    IF              reduce using rule 11 (estructurasProgram -> dataStructure .)
    FOR             reduce using rule 11 (estructurasProgram -> dataStructure .)
    WHILE           reduce using rule 11 (estructurasProgram -> dataStructure .)
    SWITCH          reduce using rule 11 (estructurasProgram -> dataStructure .)
    $end            reduce using rule 11 (estructurasProgram -> dataStructure .)


state 14

    (12) controlStructure -> if .

    VARIABLE        reduce using rule 12 (controlStructure -> if .)
    ECHO            reduce using rule 12 (controlStructure -> if .)
    PRINT           reduce using rule 12 (controlStructure -> if .)
    INT             reduce using rule 12 (controlStructure -> if .)
    FLOAT           reduce using rule 12 (controlStructure -> if .)
    IF              reduce using rule 12 (controlStructure -> if .)
    FOR             reduce using rule 12 (controlStructure -> if .)
    WHILE           reduce using rule 12 (controlStructure -> if .)
    SWITCH          reduce using rule 12 (controlStructure -> if .)
    $end            reduce using rule 12 (controlStructure -> if .)


state 15

    (13) controlStructure -> for .

    VARIABLE        reduce using rule 13 (controlStructure -> for .)
    ECHO            reduce using rule 13 (controlStructure -> for .)
    PRINT           reduce using rule 13 (controlStructure -> for .)
    INT             reduce using rule 13 (controlStructure -> for .)
    FLOAT           reduce using rule 13 (controlStructure -> for .)
    IF              reduce using rule 13 (controlStructure -> for .)
    FOR             reduce using rule 13 (controlStructure -> for .)
    WHILE           reduce using rule 13 (controlStructure -> for .)
    SWITCH          reduce using rule 13 (controlStructure -> for .)
    $end            reduce using rule 13 (controlStructure -> for .)


state 16

    (14) controlStructure -> while .

    VARIABLE        reduce using rule 14 (controlStructure -> while .)
    ECHO            reduce using rule 14 (controlStructure -> while .)
    PRINT           reduce using rule 14 (controlStructure -> while .)
    INT             reduce using rule 14 (controlStructure -> while .)
    FLOAT           reduce using rule 14 (controlStructure -> while .)
    IF              reduce using rule 14 (controlStructure -> while .)
    FOR             reduce using rule 14 (controlStructure -> while .)
    WHILE           reduce using rule 14 (controlStructure -> while .)
    SWITCH          reduce using rule 14 (controlStructure -> while .)
    $end            reduce using rule 14 (controlStructure -> while .)


state 17

    (15) controlStructure -> switch .

    VARIABLE        reduce using rule 15 (controlStructure -> switch .)
    ECHO            reduce using rule 15 (controlStructure -> switch .)
    PRINT           reduce using rule 15 (controlStructure -> switch .)
    INT             reduce using rule 15 (controlStructure -> switch .)
    FLOAT           reduce using rule 15 (controlStructure -> switch .)
    IF              reduce using rule 15 (controlStructure -> switch .)
    FOR             reduce using rule 15 (controlStructure -> switch .)
    WHILE           reduce using rule 15 (controlStructure -> switch .)
    SWITCH          reduce using rule 15 (controlStructure -> switch .)
    $end            reduce using rule 15 (controlStructure -> switch .)


state 18

    (16) dataStructure -> array .

    VARIABLE        reduce using rule 16 (dataStructure -> array .)
    ECHO            reduce using rule 16 (dataStructure -> array .)
    PRINT           reduce using rule 16 (dataStructure -> array .)
    INT             reduce using rule 16 (dataStructure -> array .)
    FLOAT           reduce using rule 16 (dataStructure -> array .)
    IF              reduce using rule 16 (dataStructure -> array .)
    FOR             reduce using rule 16 (dataStructure -> array .)
    WHILE           reduce using rule 16 (dataStructure -> array .)
    SWITCH          reduce using rule 16 (dataStructure -> array .)
    $end            reduce using rule 16 (dataStructure -> array .)


state 19

    (26) if -> IF .

    VARIABLE        reduce using rule 26 (if -> IF .)
    ECHO            reduce using rule 26 (if -> IF .)
    PRINT           reduce using rule 26 (if -> IF .)
    INT             reduce using rule 26 (if -> IF .)
    FLOAT           reduce using rule 26 (if -> IF .)
    IF              reduce using rule 26 (if -> IF .)
    FOR             reduce using rule 26 (if -> IF .)
    WHILE           reduce using rule 26 (if -> IF .)
    SWITCH          reduce using rule 26 (if -> IF .)
    $end            reduce using rule 26 (if -> IF .)


state 20

    (27) for -> FOR .

    VARIABLE        reduce using rule 27 (for -> FOR .)
    ECHO            reduce using rule 27 (for -> FOR .)
    PRINT           reduce using rule 27 (for -> FOR .)
    INT             reduce using rule 27 (for -> FOR .)
    FLOAT           reduce using rule 27 (for -> FOR .)
    IF              reduce using rule 27 (for -> FOR .)
    FOR             reduce using rule 27 (for -> FOR .)
    WHILE           reduce using rule 27 (for -> FOR .)
    SWITCH          reduce using rule 27 (for -> FOR .)
    $end            reduce using rule 27 (for -> FOR .)


state 21

    (28) while -> WHILE .

    VARIABLE        reduce using rule 28 (while -> WHILE .)
    ECHO            reduce using rule 28 (while -> WHILE .)
    PRINT           reduce using rule 28 (while -> WHILE .)
    INT             reduce using rule 28 (while -> WHILE .)
    FLOAT           reduce using rule 28 (while -> WHILE .)
    IF              reduce using rule 28 (while -> WHILE .)
    FOR             reduce using rule 28 (while -> WHILE .)
    WHILE           reduce using rule 28 (while -> WHILE .)
    SWITCH          reduce using rule 28 (while -> WHILE .)
    $end            reduce using rule 28 (while -> WHILE .)


state 22

    (29) switch -> SWITCH .

    VARIABLE        reduce using rule 29 (switch -> SWITCH .)
    ECHO            reduce using rule 29 (switch -> SWITCH .)
    PRINT           reduce using rule 29 (switch -> SWITCH .)
    INT             reduce using rule 29 (switch -> SWITCH .)
    FLOAT           reduce using rule 29 (switch -> SWITCH .)
    IF              reduce using rule 29 (switch -> SWITCH .)
    FOR             reduce using rule 29 (switch -> SWITCH .)
    WHILE           reduce using rule 29 (switch -> SWITCH .)
    SWITCH          reduce using rule 29 (switch -> SWITCH .)
    $end            reduce using rule 29 (switch -> SWITCH .)


state 23

    (2) programa -> sentencia programa .

    $end            reduce using rule 2 (programa -> sentencia programa .)


state 24

    (7) asignacion -> VARIABLE EQUALS . operaArit SEMICOLON
    (18) array -> VARIABLE EQUALS . LBRACKET elementos RBRACKET SEMICOLON
    (19) array -> VARIABLE EQUALS . ARRAY LPAREN elementos RPAREN SEMICOLON
    (46) operaArit -> . valor
    (47) operaArit -> . valor operador operaArit
    (34) valor -> . INT
    (35) valor -> . FLOAT
    (36) valor -> . VARIABLE
    (37) valor -> . STRING
    (42) valor -> . TRUE
    (43) valor -> . FALSE

    LBRACKET        shift and go to state 45
    ARRAY           shift and go to state 46
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    VARIABLE        shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    operaArit                      shift and go to state 44
    valor                          shift and go to state 47

state 25

    (8) impresion -> ECHO imprimir . SEMICOLON

    SEMICOLON       shift and go to state 48


state 26

    (30) imprimir -> LPAREN . repiteValores RPAREN
    (31) imprimir -> LPAREN . RPAREN
    (44) repiteValores -> . valor COMMA repiteValores
    (45) repiteValores -> . valor
    (34) valor -> . INT
    (35) valor -> . FLOAT
    (36) valor -> . VARIABLE
    (37) valor -> . STRING
    (42) valor -> . TRUE
    (43) valor -> . FALSE

    RPAREN          shift and go to state 50
    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    VARIABLE        shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    repiteValores                  shift and go to state 49
    valor                          shift and go to state 29

state 27

    (32) imprimir -> repiteValores .

    SEMICOLON       reduce using rule 32 (imprimir -> repiteValores .)


state 28

    (33) imprimir -> empty .

    SEMICOLON       reduce using rule 33 (imprimir -> empty .)


state 29

    (44) repiteValores -> valor . COMMA repiteValores
    (45) repiteValores -> valor .

    COMMA           shift and go to state 51
    SEMICOLON       reduce using rule 45 (repiteValores -> valor .)
    RPAREN          reduce using rule 45 (repiteValores -> valor .)


state 30

    (34) valor -> INT .

    COMMA           reduce using rule 34 (valor -> INT .)
    SEMICOLON       reduce using rule 34 (valor -> INT .)
    PLUS            reduce using rule 34 (valor -> INT .)
    MINUS           reduce using rule 34 (valor -> INT .)
    TIMES           reduce using rule 34 (valor -> INT .)
    DIVIDE          reduce using rule 34 (valor -> INT .)
    MODULO          reduce using rule 34 (valor -> INT .)
    RPAREN          reduce using rule 34 (valor -> INT .)
    RBRACKET        reduce using rule 34 (valor -> INT .)


state 31

    (35) valor -> FLOAT .

    COMMA           reduce using rule 35 (valor -> FLOAT .)
    SEMICOLON       reduce using rule 35 (valor -> FLOAT .)
    PLUS            reduce using rule 35 (valor -> FLOAT .)
    MINUS           reduce using rule 35 (valor -> FLOAT .)
    TIMES           reduce using rule 35 (valor -> FLOAT .)
    DIVIDE          reduce using rule 35 (valor -> FLOAT .)
    MODULO          reduce using rule 35 (valor -> FLOAT .)
    RPAREN          reduce using rule 35 (valor -> FLOAT .)
    RBRACKET        reduce using rule 35 (valor -> FLOAT .)


state 32

    (36) valor -> VARIABLE .

    COMMA           reduce using rule 36 (valor -> VARIABLE .)
    SEMICOLON       reduce using rule 36 (valor -> VARIABLE .)
    PLUS            reduce using rule 36 (valor -> VARIABLE .)
    MINUS           reduce using rule 36 (valor -> VARIABLE .)
    TIMES           reduce using rule 36 (valor -> VARIABLE .)
    DIVIDE          reduce using rule 36 (valor -> VARIABLE .)
    MODULO          reduce using rule 36 (valor -> VARIABLE .)
    RPAREN          reduce using rule 36 (valor -> VARIABLE .)
    RBRACKET        reduce using rule 36 (valor -> VARIABLE .)


state 33

    (37) valor -> STRING .

    COMMA           reduce using rule 37 (valor -> STRING .)
    SEMICOLON       reduce using rule 37 (valor -> STRING .)
    PLUS            reduce using rule 37 (valor -> STRING .)
    MINUS           reduce using rule 37 (valor -> STRING .)
    TIMES           reduce using rule 37 (valor -> STRING .)
    DIVIDE          reduce using rule 37 (valor -> STRING .)
    MODULO          reduce using rule 37 (valor -> STRING .)
    RPAREN          reduce using rule 37 (valor -> STRING .)
    RBRACKET        reduce using rule 37 (valor -> STRING .)


state 34

    (42) valor -> TRUE .

    COMMA           reduce using rule 42 (valor -> TRUE .)
    SEMICOLON       reduce using rule 42 (valor -> TRUE .)
    PLUS            reduce using rule 42 (valor -> TRUE .)
    MINUS           reduce using rule 42 (valor -> TRUE .)
    TIMES           reduce using rule 42 (valor -> TRUE .)
    DIVIDE          reduce using rule 42 (valor -> TRUE .)
    MODULO          reduce using rule 42 (valor -> TRUE .)
    RPAREN          reduce using rule 42 (valor -> TRUE .)
    RBRACKET        reduce using rule 42 (valor -> TRUE .)


state 35

    (43) valor -> FALSE .

    COMMA           reduce using rule 43 (valor -> FALSE .)
    SEMICOLON       reduce using rule 43 (valor -> FALSE .)
    PLUS            reduce using rule 43 (valor -> FALSE .)
    MINUS           reduce using rule 43 (valor -> FALSE .)
    TIMES           reduce using rule 43 (valor -> FALSE .)
    DIVIDE          reduce using rule 43 (valor -> FALSE .)
    MODULO          reduce using rule 43 (valor -> FALSE .)
    RPAREN          reduce using rule 43 (valor -> FALSE .)
    RBRACKET        reduce using rule 43 (valor -> FALSE .)


state 36

    (9) impresion -> PRINT imprimir . SEMICOLON

    SEMICOLON       shift and go to state 52


state 37

    (38) comparacion -> INT operador . INT
    (40) comparacion -> INT operador . FLOAT

    INT             shift and go to state 53
    FLOAT           shift and go to state 54


state 38

    (48) operador -> PLUS .

    INT             reduce using rule 48 (operador -> PLUS .)
    FLOAT           reduce using rule 48 (operador -> PLUS .)
    VARIABLE        reduce using rule 48 (operador -> PLUS .)
    STRING          reduce using rule 48 (operador -> PLUS .)
    TRUE            reduce using rule 48 (operador -> PLUS .)
    FALSE           reduce using rule 48 (operador -> PLUS .)


state 39

    (49) operador -> MINUS .

    INT             reduce using rule 49 (operador -> MINUS .)
    FLOAT           reduce using rule 49 (operador -> MINUS .)
    VARIABLE        reduce using rule 49 (operador -> MINUS .)
    STRING          reduce using rule 49 (operador -> MINUS .)
    TRUE            reduce using rule 49 (operador -> MINUS .)
    FALSE           reduce using rule 49 (operador -> MINUS .)


state 40

    (50) operador -> TIMES .

    INT             reduce using rule 50 (operador -> TIMES .)
    FLOAT           reduce using rule 50 (operador -> TIMES .)
    VARIABLE        reduce using rule 50 (operador -> TIMES .)
    STRING          reduce using rule 50 (operador -> TIMES .)
    TRUE            reduce using rule 50 (operador -> TIMES .)
    FALSE           reduce using rule 50 (operador -> TIMES .)


state 41

    (51) operador -> DIVIDE .

    INT             reduce using rule 51 (operador -> DIVIDE .)
    FLOAT           reduce using rule 51 (operador -> DIVIDE .)
    VARIABLE        reduce using rule 51 (operador -> DIVIDE .)
    STRING          reduce using rule 51 (operador -> DIVIDE .)
    TRUE            reduce using rule 51 (operador -> DIVIDE .)
    FALSE           reduce using rule 51 (operador -> DIVIDE .)


state 42

    (52) operador -> MODULO .

    INT             reduce using rule 52 (operador -> MODULO .)
    FLOAT           reduce using rule 52 (operador -> MODULO .)
    VARIABLE        reduce using rule 52 (operador -> MODULO .)
    STRING          reduce using rule 52 (operador -> MODULO .)
    TRUE            reduce using rule 52 (operador -> MODULO .)
    FALSE           reduce using rule 52 (operador -> MODULO .)


state 43

    (39) comparacion -> FLOAT operador . FLOAT
    (41) comparacion -> FLOAT operador . INT

    FLOAT           shift and go to state 55
    INT             shift and go to state 56


state 44

    (7) asignacion -> VARIABLE EQUALS operaArit . SEMICOLON

    SEMICOLON       shift and go to state 57


state 45

    (18) array -> VARIABLE EQUALS LBRACKET . elementos RBRACKET SEMICOLON
    (20) elementos -> . valor COMMA elementos
    (21) elementos -> . valor
    (22) elementos -> . empty
    (34) valor -> . INT
    (35) valor -> . FLOAT
    (36) valor -> . VARIABLE
    (37) valor -> . STRING
    (42) valor -> . TRUE
    (43) valor -> . FALSE
    (53) empty -> .

    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    VARIABLE        shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    RBRACKET        reduce using rule 53 (empty -> .)

    elementos                      shift and go to state 58
    valor                          shift and go to state 59
    empty                          shift and go to state 60

state 46

    (19) array -> VARIABLE EQUALS ARRAY . LPAREN elementos RPAREN SEMICOLON

    LPAREN          shift and go to state 61


state 47

    (46) operaArit -> valor .
    (47) operaArit -> valor . operador operaArit
    (48) operador -> . PLUS
    (49) operador -> . MINUS
    (50) operador -> . TIMES
    (51) operador -> . DIVIDE
    (52) operador -> . MODULO

    SEMICOLON       reduce using rule 46 (operaArit -> valor .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    TIMES           shift and go to state 40
    DIVIDE          shift and go to state 41
    MODULO          shift and go to state 42

    operador                       shift and go to state 62

state 48

    (8) impresion -> ECHO imprimir SEMICOLON .

    VARIABLE        reduce using rule 8 (impresion -> ECHO imprimir SEMICOLON .)
    ECHO            reduce using rule 8 (impresion -> ECHO imprimir SEMICOLON .)
    PRINT           reduce using rule 8 (impresion -> ECHO imprimir SEMICOLON .)
    INT             reduce using rule 8 (impresion -> ECHO imprimir SEMICOLON .)
    FLOAT           reduce using rule 8 (impresion -> ECHO imprimir SEMICOLON .)
    IF              reduce using rule 8 (impresion -> ECHO imprimir SEMICOLON .)
    FOR             reduce using rule 8 (impresion -> ECHO imprimir SEMICOLON .)
    WHILE           reduce using rule 8 (impresion -> ECHO imprimir SEMICOLON .)
    SWITCH          reduce using rule 8 (impresion -> ECHO imprimir SEMICOLON .)
    $end            reduce using rule 8 (impresion -> ECHO imprimir SEMICOLON .)


state 49

    (30) imprimir -> LPAREN repiteValores . RPAREN

    RPAREN          shift and go to state 63


state 50

    (31) imprimir -> LPAREN RPAREN .

    SEMICOLON       reduce using rule 31 (imprimir -> LPAREN RPAREN .)


state 51

    (44) repiteValores -> valor COMMA . repiteValores
    (44) repiteValores -> . valor COMMA repiteValores
    (45) repiteValores -> . valor
    (34) valor -> . INT
    (35) valor -> . FLOAT
    (36) valor -> . VARIABLE
    (37) valor -> . STRING
    (42) valor -> . TRUE
    (43) valor -> . FALSE

    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    VARIABLE        shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    valor                          shift and go to state 29
    repiteValores                  shift and go to state 64

state 52

    (9) impresion -> PRINT imprimir SEMICOLON .

    VARIABLE        reduce using rule 9 (impresion -> PRINT imprimir SEMICOLON .)
    ECHO            reduce using rule 9 (impresion -> PRINT imprimir SEMICOLON .)
    PRINT           reduce using rule 9 (impresion -> PRINT imprimir SEMICOLON .)
    INT             reduce using rule 9 (impresion -> PRINT imprimir SEMICOLON .)
    FLOAT           reduce using rule 9 (impresion -> PRINT imprimir SEMICOLON .)
    IF              reduce using rule 9 (impresion -> PRINT imprimir SEMICOLON .)
    FOR             reduce using rule 9 (impresion -> PRINT imprimir SEMICOLON .)
    WHILE           reduce using rule 9 (impresion -> PRINT imprimir SEMICOLON .)
    SWITCH          reduce using rule 9 (impresion -> PRINT imprimir SEMICOLON .)
    $end            reduce using rule 9 (impresion -> PRINT imprimir SEMICOLON .)


state 53

    (38) comparacion -> INT operador INT .

    VARIABLE        reduce using rule 38 (comparacion -> INT operador INT .)
    ECHO            reduce using rule 38 (comparacion -> INT operador INT .)
    PRINT           reduce using rule 38 (comparacion -> INT operador INT .)
    INT             reduce using rule 38 (comparacion -> INT operador INT .)
    FLOAT           reduce using rule 38 (comparacion -> INT operador INT .)
    IF              reduce using rule 38 (comparacion -> INT operador INT .)
    FOR             reduce using rule 38 (comparacion -> INT operador INT .)
    WHILE           reduce using rule 38 (comparacion -> INT operador INT .)
    SWITCH          reduce using rule 38 (comparacion -> INT operador INT .)
    $end            reduce using rule 38 (comparacion -> INT operador INT .)


state 54

    (40) comparacion -> INT operador FLOAT .

    VARIABLE        reduce using rule 40 (comparacion -> INT operador FLOAT .)
    ECHO            reduce using rule 40 (comparacion -> INT operador FLOAT .)
    PRINT           reduce using rule 40 (comparacion -> INT operador FLOAT .)
    INT             reduce using rule 40 (comparacion -> INT operador FLOAT .)
    FLOAT           reduce using rule 40 (comparacion -> INT operador FLOAT .)
    IF              reduce using rule 40 (comparacion -> INT operador FLOAT .)
    FOR             reduce using rule 40 (comparacion -> INT operador FLOAT .)
    WHILE           reduce using rule 40 (comparacion -> INT operador FLOAT .)
    SWITCH          reduce using rule 40 (comparacion -> INT operador FLOAT .)
    $end            reduce using rule 40 (comparacion -> INT operador FLOAT .)


state 55

    (39) comparacion -> FLOAT operador FLOAT .

    VARIABLE        reduce using rule 39 (comparacion -> FLOAT operador FLOAT .)
    ECHO            reduce using rule 39 (comparacion -> FLOAT operador FLOAT .)
    PRINT           reduce using rule 39 (comparacion -> FLOAT operador FLOAT .)
    INT             reduce using rule 39 (comparacion -> FLOAT operador FLOAT .)
    FLOAT           reduce using rule 39 (comparacion -> FLOAT operador FLOAT .)
    IF              reduce using rule 39 (comparacion -> FLOAT operador FLOAT .)
    FOR             reduce using rule 39 (comparacion -> FLOAT operador FLOAT .)
    WHILE           reduce using rule 39 (comparacion -> FLOAT operador FLOAT .)
    SWITCH          reduce using rule 39 (comparacion -> FLOAT operador FLOAT .)
    $end            reduce using rule 39 (comparacion -> FLOAT operador FLOAT .)


state 56

    (41) comparacion -> FLOAT operador INT .

    VARIABLE        reduce using rule 41 (comparacion -> FLOAT operador INT .)
    ECHO            reduce using rule 41 (comparacion -> FLOAT operador INT .)
    PRINT           reduce using rule 41 (comparacion -> FLOAT operador INT .)
    INT             reduce using rule 41 (comparacion -> FLOAT operador INT .)
    FLOAT           reduce using rule 41 (comparacion -> FLOAT operador INT .)
    IF              reduce using rule 41 (comparacion -> FLOAT operador INT .)
    FOR             reduce using rule 41 (comparacion -> FLOAT operador INT .)
    WHILE           reduce using rule 41 (comparacion -> FLOAT operador INT .)
    SWITCH          reduce using rule 41 (comparacion -> FLOAT operador INT .)
    $end            reduce using rule 41 (comparacion -> FLOAT operador INT .)


state 57

    (7) asignacion -> VARIABLE EQUALS operaArit SEMICOLON .

    VARIABLE        reduce using rule 7 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    ECHO            reduce using rule 7 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    PRINT           reduce using rule 7 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    INT             reduce using rule 7 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    FLOAT           reduce using rule 7 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    IF              reduce using rule 7 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    FOR             reduce using rule 7 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    WHILE           reduce using rule 7 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    SWITCH          reduce using rule 7 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    $end            reduce using rule 7 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)


state 58

    (18) array -> VARIABLE EQUALS LBRACKET elementos . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 65


state 59

    (20) elementos -> valor . COMMA elementos
    (21) elementos -> valor .

    COMMA           shift and go to state 66
    RBRACKET        reduce using rule 21 (elementos -> valor .)
    RPAREN          reduce using rule 21 (elementos -> valor .)


state 60

    (22) elementos -> empty .

    RBRACKET        reduce using rule 22 (elementos -> empty .)
    RPAREN          reduce using rule 22 (elementos -> empty .)


state 61

    (19) array -> VARIABLE EQUALS ARRAY LPAREN . elementos RPAREN SEMICOLON
    (20) elementos -> . valor COMMA elementos
    (21) elementos -> . valor
    (22) elementos -> . empty
    (34) valor -> . INT
    (35) valor -> . FLOAT
    (36) valor -> . VARIABLE
    (37) valor -> . STRING
    (42) valor -> . TRUE
    (43) valor -> . FALSE
    (53) empty -> .

    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    VARIABLE        shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    RPAREN          reduce using rule 53 (empty -> .)

    elementos                      shift and go to state 67
    valor                          shift and go to state 59
    empty                          shift and go to state 60

state 62

    (47) operaArit -> valor operador . operaArit
    (46) operaArit -> . valor
    (47) operaArit -> . valor operador operaArit
    (34) valor -> . INT
    (35) valor -> . FLOAT
    (36) valor -> . VARIABLE
    (37) valor -> . STRING
    (42) valor -> . TRUE
    (43) valor -> . FALSE

    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    VARIABLE        shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    valor                          shift and go to state 47
    operaArit                      shift and go to state 68

state 63

    (30) imprimir -> LPAREN repiteValores RPAREN .

    SEMICOLON       reduce using rule 30 (imprimir -> LPAREN repiteValores RPAREN .)


state 64

    (44) repiteValores -> valor COMMA repiteValores .

    SEMICOLON       reduce using rule 44 (repiteValores -> valor COMMA repiteValores .)
    RPAREN          reduce using rule 44 (repiteValores -> valor COMMA repiteValores .)


state 65

    (18) array -> VARIABLE EQUALS LBRACKET elementos RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 69


state 66

    (20) elementos -> valor COMMA . elementos
    (20) elementos -> . valor COMMA elementos
    (21) elementos -> . valor
    (22) elementos -> . empty
    (34) valor -> . INT
    (35) valor -> . FLOAT
    (36) valor -> . VARIABLE
    (37) valor -> . STRING
    (42) valor -> . TRUE
    (43) valor -> . FALSE
    (53) empty -> .

    INT             shift and go to state 30
    FLOAT           shift and go to state 31
    VARIABLE        shift and go to state 32
    STRING          shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    RBRACKET        reduce using rule 53 (empty -> .)
    RPAREN          reduce using rule 53 (empty -> .)

    valor                          shift and go to state 59
    elementos                      shift and go to state 70
    empty                          shift and go to state 60

state 67

    (19) array -> VARIABLE EQUALS ARRAY LPAREN elementos . RPAREN SEMICOLON

    RPAREN          shift and go to state 71


state 68

    (47) operaArit -> valor operador operaArit .

    SEMICOLON       reduce using rule 47 (operaArit -> valor operador operaArit .)


state 69

    (18) array -> VARIABLE EQUALS LBRACKET elementos RBRACKET SEMICOLON .

    VARIABLE        reduce using rule 18 (array -> VARIABLE EQUALS LBRACKET elementos RBRACKET SEMICOLON .)
    ECHO            reduce using rule 18 (array -> VARIABLE EQUALS LBRACKET elementos RBRACKET SEMICOLON .)
    PRINT           reduce using rule 18 (array -> VARIABLE EQUALS LBRACKET elementos RBRACKET SEMICOLON .)
    INT             reduce using rule 18 (array -> VARIABLE EQUALS LBRACKET elementos RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 18 (array -> VARIABLE EQUALS LBRACKET elementos RBRACKET SEMICOLON .)
    IF              reduce using rule 18 (array -> VARIABLE EQUALS LBRACKET elementos RBRACKET SEMICOLON .)
    FOR             reduce using rule 18 (array -> VARIABLE EQUALS LBRACKET elementos RBRACKET SEMICOLON .)
    WHILE           reduce using rule 18 (array -> VARIABLE EQUALS LBRACKET elementos RBRACKET SEMICOLON .)
    SWITCH          reduce using rule 18 (array -> VARIABLE EQUALS LBRACKET elementos RBRACKET SEMICOLON .)
    $end            reduce using rule 18 (array -> VARIABLE EQUALS LBRACKET elementos RBRACKET SEMICOLON .)


state 70

    (20) elementos -> valor COMMA elementos .

    RBRACKET        reduce using rule 20 (elementos -> valor COMMA elementos .)
    RPAREN          reduce using rule 20 (elementos -> valor COMMA elementos .)


state 71

    (19) array -> VARIABLE EQUALS ARRAY LPAREN elementos RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 72


state 72

    (19) array -> VARIABLE EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON .

    VARIABLE        reduce using rule 19 (array -> VARIABLE EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON .)
    ECHO            reduce using rule 19 (array -> VARIABLE EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON .)
    PRINT           reduce using rule 19 (array -> VARIABLE EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON .)
    INT             reduce using rule 19 (array -> VARIABLE EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON .)
    FLOAT           reduce using rule 19 (array -> VARIABLE EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON .)
    IF              reduce using rule 19 (array -> VARIABLE EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON .)
    FOR             reduce using rule 19 (array -> VARIABLE EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON .)
    WHILE           reduce using rule 19 (array -> VARIABLE EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON .)
    SWITCH          reduce using rule 19 (array -> VARIABLE EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON .)
    $end            reduce using rule 19 (array -> VARIABLE EQUALS ARRAY LPAREN elementos RPAREN SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VARIABLE in state 0 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 0 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 2 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 2 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 2 resolved as shift
WARNING: shift/reduce conflict for INT in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 2 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 2 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (programa -> sentencia)
WARNING: rejected rule (dataStructure -> <empty>) in state 2
