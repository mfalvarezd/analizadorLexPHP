Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    BOOL
    CATCH
    CLONE
    CLOSETAG
    CONCATENATEEQUAL
    CONST
    CONTINUE
    DECLARE
    DO
    EMPTY
    ENDSWITCH
    EXCEPTION
    FINAL
    FINALLY
    FN
    GLOBAL
    IMPLEMENTS
    INCLUDE
    INSTANCEOF
    INTERFACE
    ISSET
    LIST
    MINUSEQUAL
    NAMESPACE
    OPENTAG
    PLUSEQUAL
    POTENCIA
    PRIVATE
    PROTECTED
    PUBLIC
    STATIC
    THROW
    TRY

Grammar

Rule 0     S' -> programa
Rule 1     programa -> sentencia
Rule 2     programa -> sentencia programa
Rule 3     sentencia -> asignacion
Rule 4     sentencia -> impresion
Rule 5     sentencia -> comparacion
Rule 6     sentencia -> estructurasProgram
Rule 7     sentencia -> asignacion_fgets
Rule 8     asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
Rule 9     sentencias -> sentencia
Rule 10    sentencias -> sentencia sentencias
Rule 11    sentencias -> empty
Rule 12    asignacion -> VARIABLE EQUALS operaArit SEMICOLON
Rule 13    impresion -> ECHO imprimir SEMICOLON
Rule 14    impresion -> PRINT imprimir SEMICOLON
Rule 15    estructurasProgram -> controlStructure
Rule 16    estructurasProgram -> dataStructure
Rule 17    estructurasProgram -> funcionDeclarate
Rule 18    estructurasProgram -> classDeclarate
Rule 19    controlStructure -> if
Rule 20    controlStructure -> for
Rule 21    controlStructure -> while
Rule 22    controlStructure -> switch
Rule 23    if -> statementif ELSE body
Rule 24    if -> statementif ELSE if
Rule 25    if -> statementif ELSEIF if
Rule 26    if -> statementif
Rule 27    statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
Rule 28    conditionProdu -> condition
Rule 29    conditionProdu -> condition opLogic condition conditionProdu
Rule 30    condition -> valor opSymbol valor
Rule 31    condition -> LPAREN conditionProdu RPAREN
Rule 32    opSymbol -> EQ
Rule 33    opSymbol -> NEQ
Rule 34    opSymbol -> STRICTEQ
Rule 35    opSymbol -> STRICTNEQ
Rule 36    opSymbol -> LT
Rule 37    opSymbol -> GT
Rule 38    opSymbol -> LEQ
Rule 39    opSymbol -> GEQ
Rule 40    opLogic -> AND
Rule 41    opLogic -> OR
Rule 42    opLogic -> NOT
Rule 43    for -> forStatement
Rule 44    forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE
Rule 45    forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE
Rule 46    forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
Rule 47    forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS
Rule 48    while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE
Rule 49    while -> WHILE LPAREN condition RPAREN LBRACE RBRACE
Rule 50    switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
Rule 51    switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE
Rule 52    caseLists -> cases default
Rule 53    caseLists -> cases
Rule 54    caseLists -> default
Rule 55    caseLists -> empty
Rule 56    cases -> case cases
Rule 57    cases -> case
Rule 58    case -> CASE valor COLON body BREAK SEMICOLON
Rule 59    default -> DEFAULT COLON body BREAK SEMICOLON
Rule 60    dataStructure -> array
Rule 61    dataStructure -> map
Rule 62    funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
Rule 63    funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
Rule 64    funcionBody -> body
Rule 65    funcionBody -> RETURN expresion SEMICOLON
Rule 66    parametros -> parametro
Rule 67    parametros -> parametro COMMA parametros
Rule 68    parametros -> empty
Rule 69    parametro -> ID
Rule 70    parametro -> dataType ID
Rule 71    parametro -> ID EQUALS valor
Rule 72    parametro -> dataType ID EQUALS valor
Rule 73    brace -> LBRACE body RBRACE
Rule 74    funcionParen -> ID LPAREN parametros RPAREN
Rule 75    funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON
Rule 76    classDeclarate -> CLASS ID LBRACE classBody RBRACE
Rule 77    classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE
Rule 78    classBody -> classMember classBody
Rule 79    classBody -> empty
Rule 80    classMember -> dataType VARIABLE SEMICOLON
Rule 81    classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace
Rule 82    classMember -> objectInstantiation
Rule 83    accessMember -> VARIABLE ARROW ID
Rule 84    accessMember -> VARIABLE ARROW funcionParen
Rule 85    objectInstantiation -> NEW ID LPAREN argumentos RPAREN
Rule 86    objectInstantiation -> NEW ID LPAREN RPAREN
Rule 87    argumentos -> expresion
Rule 88    argumentos -> expresion COMMA argumentos
Rule 89    argumentos -> empty
Rule 90    array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
Rule 91    array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
Rule 92    array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
Rule 93    array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
Rule 94    map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
Rule 95    map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
Rule 96    mapProduc -> mapArrow
Rule 97    mapProduc -> mapArrow COMMA mapProduc
Rule 98    mapArrow -> valor ARROWMAP valor
Rule 99    body -> sentencia
Rule 100   body -> sentencia sentencias
Rule 101   body -> empty
Rule 102   imprimir -> LPAREN repiteValores RPAREN
Rule 103   imprimir -> LPAREN RPAREN
Rule 104   imprimir -> repiteValores
Rule 105   valor -> INT
Rule 106   valor -> FLOAT
Rule 107   valor -> VARIABLE
Rule 108   valor -> STRING
Rule 109   valor -> TRUE
Rule 110   valor -> FALSE
Rule 111   valor -> THIS
Rule 112   valor -> funcionParen
Rule 113   valor -> funcionAnonima
Rule 114   dataType -> INTEGER
Rule 115   dataType -> FLOATING
Rule 116   dataType -> STRINGS
Rule 117   dataType -> BOOLEAN
Rule 118   dataType -> VOID
Rule 119   comparacion -> INT operador INT
Rule 120   comparacion -> FLOAT operador FLOAT
Rule 121   comparacion -> INT operador FLOAT
Rule 122   comparacion -> FLOAT operador INT
Rule 123   repiteValores -> valor COMMA repiteValores
Rule 124   repiteValores -> valor
Rule 125   operaArit -> valor
Rule 126   operaArit -> valor operador operaArit
Rule 127   operaArit -> valor DOT valor
Rule 128   expresion -> valor
Rule 129   expresion -> operaArit
Rule 130   expresion -> conditionProdu
Rule 131   expresion -> ternario
Rule 132   expresion -> accessMember
Rule 133   operador -> PLUS
Rule 134   operador -> MINUS
Rule 135   operador -> TIMES
Rule 136   operador -> DIVIDE
Rule 137   operador -> MODULO
Rule 138   ternario -> conditionProdu QUESTION expresion COLON expresion
Rule 139   empty -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 40
ARRAY                : 91 92 95
ARROW                : 83 84
ARROWMAP             : 98
AS                   : 
BOOL                 : 
BOOLEAN              : 117
BREAK                : 45 58 59
CASE                 : 58
CATCH                : 
CLASS                : 76 77
CLONE                : 
CLOSETAG             : 
COLON                : 58 59 138
COMMA                : 67 88 97 123
CONCATENATEEQUAL     : 
CONST                : 
CONTINUE             : 
DECLARE              : 
DEFAULT              : 59
DIVIDE               : 136
DO                   : 
DOT                  : 127
DOUBLEDOT            : 63
DOUBLEMINUS          : 47
DOUBLEPLUS           : 46
ECHO                 : 13
ELSE                 : 23 24
ELSEIF               : 25
EMPTY                : 
ENDSWITCH            : 
EQ                   : 32
EQUALS               : 8 12 46 47 71 72 75 90 91 92 93 94 95
EXCEPTION            : 
EXTENDS              : 77
FALSE                : 110
FGETS                : 8
FINAL                : 
FINALLY              : 
FLOAT                : 106 120 120 121 122
FLOATING             : 115
FN                   : 
FOR                  : 44
FOREACH              : 45
FUNCTION             : 62 63 75 81
GEQ                  : 39
GLOBAL               : 
GT                   : 37
ID                   : 62 63 69 70 71 72 74 76 77 77 81 83 85 86
IF                   : 27
IMPLEMENTS           : 
INCLUDE              : 
INSTANCEOF           : 
INT                  : 46 46 47 47 105 119 119 121 122
INTEGER              : 114
INTERFACE            : 
ISSET                : 
LBRACE               : 27 44 45 48 49 50 51 62 63 73 75 76 77
LBRACKET             : 90 93 94
LEQ                  : 38
LIST                 : 
LPAREN               : 8 27 31 44 45 48 49 50 51 62 63 74 75 81 85 86 91 92 95 102 103
LT                   : 36
MINUS                : 134
MINUSEQUAL           : 
MODULO               : 137
NAMESPACE            : 
NEQ                  : 33
NEW                  : 85 86
NOT                  : 42
OPENTAG              : 
OR                   : 41
PLUS                 : 133
PLUSEQUAL            : 
POTENCIA             : 
PRINT                : 14
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
QUESTION             : 138
RBRACE               : 27 44 45 48 49 50 51 62 63 73 75 76 77
RBRACKET             : 90 93 94
RETURN               : 65 75
RPAREN               : 8 27 31 44 45 48 49 50 51 62 63 74 75 81 85 86 91 92 95 102 103
SEMICOLON            : 8 12 13 14 45 46 46 47 47 58 59 65 75 75 80 90 91 92 93 94 95
STATIC               : 
STDIN                : 8
STRICTEQ             : 34
STRICTNEQ            : 35
STRING               : 108
STRINGS              : 116
SWITCH               : 50 51
THIS                 : 111
THROW                : 
TIMES                : 135
TRUE                 : 109
TRY                  : 
VARIABLE             : 8 12 46 46 46 47 47 47 75 80 83 84 90 91 92 93 94 95 107
VOID                 : 118
WHILE                : 48 49
error                : 

Nonterminals, with rules where they appear

accessMember         : 132
argumentos           : 85 88
array                : 60
asignacion           : 3
asignacion_fgets     : 7
body                 : 23 27 44 45 48 58 59 64 73
brace                : 81
case                 : 56 57
caseLists            : 50
cases                : 52 53 56
classBody            : 76 77 78
classDeclarate       : 18
classMember          : 78
comparacion          : 5
condition            : 28 29 29 48 49 50 51
conditionProdu       : 27 29 31 130 138
controlStructure     : 15
dataStructure        : 16
dataType             : 63 70 72 80 81
default              : 52 54
empty                : 11 55 68 79 89 101
estructurasProgram   : 6
expresion            : 65 75 87 88 138 138
for                  : 20
forStatement         : 43
forcondition         : 44 45
funcionAnonima       : 113
funcionBody          : 62 63
funcionDeclarate     : 17
funcionParen         : 84 112
if                   : 19 24 25
impresion            : 4
imprimir             : 13 14
map                  : 61
mapArrow             : 96 97
mapProduc            : 92 93 94 95 97
objectInstantiation  : 82
opLogic              : 29
opSymbol             : 30 46 47
operaArit            : 12 126 129
operador             : 119 120 121 122 126
parametro            : 66 67
parametros           : 62 63 67 74 75 81
programa             : 2 0
repiteValores        : 90 91 102 104 123
sentencia            : 1 2 9 10 99 100
sentencias           : 10 100
statementif          : 23 24 25 26
switch               : 22
ternario             : 131
valor                : 30 30 58 71 72 98 98 123 124 125 126 127 127 128
while                : 21

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . sentencia
    (2) programa -> . sentencia programa
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) sentencia -> . asignacion_fgets
    (12) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (13) impresion -> . ECHO imprimir SEMICOLON
    (14) impresion -> . PRINT imprimir SEMICOLON
    (119) comparacion -> . INT operador INT
    (120) comparacion -> . FLOAT operador FLOAT
    (121) comparacion -> . INT operador FLOAT
    (122) comparacion -> . FLOAT operador INT
    (15) estructurasProgram -> . controlStructure
    (16) estructurasProgram -> . dataStructure
    (17) estructurasProgram -> . funcionDeclarate
    (18) estructurasProgram -> . classDeclarate
    (8) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (19) controlStructure -> . if
    (20) controlStructure -> . for
    (21) controlStructure -> . while
    (22) controlStructure -> . switch
    (60) dataStructure -> . array
    (61) dataStructure -> . map
    (62) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (76) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (77) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (43) for -> . forStatement
    (48) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (50) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (90) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (44) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (45) forStatement -> . FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

    VARIABLE        shift and go to state 8
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    FUNCTION        shift and go to state 23
    CLASS           shift and go to state 24
    WHILE           shift and go to state 27
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    FOREACH         shift and go to state 31

    programa                       shift and go to state 1
    sentencia                      shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    asignacion_fgets               shift and go to state 7
    controlStructure               shift and go to state 13
    dataStructure                  shift and go to state 14
    funcionDeclarate               shift and go to state 15
    classDeclarate                 shift and go to state 16
    if                             shift and go to state 17
    for                            shift and go to state 18
    while                          shift and go to state 19
    switch                         shift and go to state 20
    array                          shift and go to state 21
    map                            shift and go to state 22
    statementif                    shift and go to state 25
    forStatement                   shift and go to state 26

state 1

    (0) S' -> programa .



state 2

    (1) programa -> sentencia .
    (2) programa -> sentencia . programa
    (1) programa -> . sentencia
    (2) programa -> . sentencia programa
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) sentencia -> . asignacion_fgets
    (12) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (13) impresion -> . ECHO imprimir SEMICOLON
    (14) impresion -> . PRINT imprimir SEMICOLON
    (119) comparacion -> . INT operador INT
    (120) comparacion -> . FLOAT operador FLOAT
    (121) comparacion -> . INT operador FLOAT
    (122) comparacion -> . FLOAT operador INT
    (15) estructurasProgram -> . controlStructure
    (16) estructurasProgram -> . dataStructure
    (17) estructurasProgram -> . funcionDeclarate
    (18) estructurasProgram -> . classDeclarate
    (8) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (19) controlStructure -> . if
    (20) controlStructure -> . for
    (21) controlStructure -> . while
    (22) controlStructure -> . switch
    (60) dataStructure -> . array
    (61) dataStructure -> . map
    (62) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (76) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (77) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (43) for -> . forStatement
    (48) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (50) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (90) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (44) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (45) forStatement -> . FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

    $end            reduce using rule 1 (programa -> sentencia .)
    VARIABLE        shift and go to state 8
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    FUNCTION        shift and go to state 23
    CLASS           shift and go to state 24
    WHILE           shift and go to state 27
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    FOREACH         shift and go to state 31

    sentencia                      shift and go to state 2
    programa                       shift and go to state 32
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    asignacion_fgets               shift and go to state 7
    controlStructure               shift and go to state 13
    dataStructure                  shift and go to state 14
    funcionDeclarate               shift and go to state 15
    classDeclarate                 shift and go to state 16
    if                             shift and go to state 17
    for                            shift and go to state 18
    while                          shift and go to state 19
    switch                         shift and go to state 20
    array                          shift and go to state 21
    map                            shift and go to state 22
    statementif                    shift and go to state 25
    forStatement                   shift and go to state 26

state 3

    (3) sentencia -> asignacion .

    VARIABLE        reduce using rule 3 (sentencia -> asignacion .)
    ECHO            reduce using rule 3 (sentencia -> asignacion .)
    PRINT           reduce using rule 3 (sentencia -> asignacion .)
    INT             reduce using rule 3 (sentencia -> asignacion .)
    FLOAT           reduce using rule 3 (sentencia -> asignacion .)
    FUNCTION        reduce using rule 3 (sentencia -> asignacion .)
    CLASS           reduce using rule 3 (sentencia -> asignacion .)
    WHILE           reduce using rule 3 (sentencia -> asignacion .)
    SWITCH          reduce using rule 3 (sentencia -> asignacion .)
    IF              reduce using rule 3 (sentencia -> asignacion .)
    FOR             reduce using rule 3 (sentencia -> asignacion .)
    FOREACH         reduce using rule 3 (sentencia -> asignacion .)
    $end            reduce using rule 3 (sentencia -> asignacion .)
    RBRACE          reduce using rule 3 (sentencia -> asignacion .)
    BREAK           reduce using rule 3 (sentencia -> asignacion .)


state 4

    (4) sentencia -> impresion .

    VARIABLE        reduce using rule 4 (sentencia -> impresion .)
    ECHO            reduce using rule 4 (sentencia -> impresion .)
    PRINT           reduce using rule 4 (sentencia -> impresion .)
    INT             reduce using rule 4 (sentencia -> impresion .)
    FLOAT           reduce using rule 4 (sentencia -> impresion .)
    FUNCTION        reduce using rule 4 (sentencia -> impresion .)
    CLASS           reduce using rule 4 (sentencia -> impresion .)
    WHILE           reduce using rule 4 (sentencia -> impresion .)
    SWITCH          reduce using rule 4 (sentencia -> impresion .)
    IF              reduce using rule 4 (sentencia -> impresion .)
    FOR             reduce using rule 4 (sentencia -> impresion .)
    FOREACH         reduce using rule 4 (sentencia -> impresion .)
    $end            reduce using rule 4 (sentencia -> impresion .)
    RBRACE          reduce using rule 4 (sentencia -> impresion .)
    BREAK           reduce using rule 4 (sentencia -> impresion .)


state 5

    (5) sentencia -> comparacion .

    VARIABLE        reduce using rule 5 (sentencia -> comparacion .)
    ECHO            reduce using rule 5 (sentencia -> comparacion .)
    PRINT           reduce using rule 5 (sentencia -> comparacion .)
    INT             reduce using rule 5 (sentencia -> comparacion .)
    FLOAT           reduce using rule 5 (sentencia -> comparacion .)
    FUNCTION        reduce using rule 5 (sentencia -> comparacion .)
    CLASS           reduce using rule 5 (sentencia -> comparacion .)
    WHILE           reduce using rule 5 (sentencia -> comparacion .)
    SWITCH          reduce using rule 5 (sentencia -> comparacion .)
    IF              reduce using rule 5 (sentencia -> comparacion .)
    FOR             reduce using rule 5 (sentencia -> comparacion .)
    FOREACH         reduce using rule 5 (sentencia -> comparacion .)
    $end            reduce using rule 5 (sentencia -> comparacion .)
    RBRACE          reduce using rule 5 (sentencia -> comparacion .)
    BREAK           reduce using rule 5 (sentencia -> comparacion .)


state 6

    (6) sentencia -> estructurasProgram .

    VARIABLE        reduce using rule 6 (sentencia -> estructurasProgram .)
    ECHO            reduce using rule 6 (sentencia -> estructurasProgram .)
    PRINT           reduce using rule 6 (sentencia -> estructurasProgram .)
    INT             reduce using rule 6 (sentencia -> estructurasProgram .)
    FLOAT           reduce using rule 6 (sentencia -> estructurasProgram .)
    FUNCTION        reduce using rule 6 (sentencia -> estructurasProgram .)
    CLASS           reduce using rule 6 (sentencia -> estructurasProgram .)
    WHILE           reduce using rule 6 (sentencia -> estructurasProgram .)
    SWITCH          reduce using rule 6 (sentencia -> estructurasProgram .)
    IF              reduce using rule 6 (sentencia -> estructurasProgram .)
    FOR             reduce using rule 6 (sentencia -> estructurasProgram .)
    FOREACH         reduce using rule 6 (sentencia -> estructurasProgram .)
    $end            reduce using rule 6 (sentencia -> estructurasProgram .)
    RBRACE          reduce using rule 6 (sentencia -> estructurasProgram .)
    BREAK           reduce using rule 6 (sentencia -> estructurasProgram .)


state 7

    (7) sentencia -> asignacion_fgets .

    VARIABLE        reduce using rule 7 (sentencia -> asignacion_fgets .)
    ECHO            reduce using rule 7 (sentencia -> asignacion_fgets .)
    PRINT           reduce using rule 7 (sentencia -> asignacion_fgets .)
    INT             reduce using rule 7 (sentencia -> asignacion_fgets .)
    FLOAT           reduce using rule 7 (sentencia -> asignacion_fgets .)
    FUNCTION        reduce using rule 7 (sentencia -> asignacion_fgets .)
    CLASS           reduce using rule 7 (sentencia -> asignacion_fgets .)
    WHILE           reduce using rule 7 (sentencia -> asignacion_fgets .)
    SWITCH          reduce using rule 7 (sentencia -> asignacion_fgets .)
    IF              reduce using rule 7 (sentencia -> asignacion_fgets .)
    FOR             reduce using rule 7 (sentencia -> asignacion_fgets .)
    FOREACH         reduce using rule 7 (sentencia -> asignacion_fgets .)
    $end            reduce using rule 7 (sentencia -> asignacion_fgets .)
    RBRACE          reduce using rule 7 (sentencia -> asignacion_fgets .)
    BREAK           reduce using rule 7 (sentencia -> asignacion_fgets .)


state 8

    (12) asignacion -> VARIABLE . EQUALS operaArit SEMICOLON
    (8) asignacion_fgets -> VARIABLE . EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (90) array -> VARIABLE . EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> VARIABLE . EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> VARIABLE . EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> VARIABLE . EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> VARIABLE . EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> VARIABLE . EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON

    EQUALS          shift and go to state 33


state 9

    (13) impresion -> ECHO . imprimir SEMICOLON
    (102) imprimir -> . LPAREN repiteValores RPAREN
    (103) imprimir -> . LPAREN RPAREN
    (104) imprimir -> . repiteValores
    (123) repiteValores -> . valor COMMA repiteValores
    (124) repiteValores -> . valor
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 35
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    imprimir                       shift and go to state 34
    repiteValores                  shift and go to state 36
    valor                          shift and go to state 37
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 10

    (14) impresion -> PRINT . imprimir SEMICOLON
    (102) imprimir -> . LPAREN repiteValores RPAREN
    (103) imprimir -> . LPAREN RPAREN
    (104) imprimir -> . repiteValores
    (123) repiteValores -> . valor COMMA repiteValores
    (124) repiteValores -> . valor
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 35
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    imprimir                       shift and go to state 48
    repiteValores                  shift and go to state 36
    valor                          shift and go to state 37
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 11

    (119) comparacion -> INT . operador INT
    (121) comparacion -> INT . operador FLOAT
    (133) operador -> . PLUS
    (134) operador -> . MINUS
    (135) operador -> . TIMES
    (136) operador -> . DIVIDE
    (137) operador -> . MODULO

    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MODULO          shift and go to state 54

    operador                       shift and go to state 49

state 12

    (120) comparacion -> FLOAT . operador FLOAT
    (122) comparacion -> FLOAT . operador INT
    (133) operador -> . PLUS
    (134) operador -> . MINUS
    (135) operador -> . TIMES
    (136) operador -> . DIVIDE
    (137) operador -> . MODULO

    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MODULO          shift and go to state 54

    operador                       shift and go to state 55

state 13

    (15) estructurasProgram -> controlStructure .

    VARIABLE        reduce using rule 15 (estructurasProgram -> controlStructure .)
    ECHO            reduce using rule 15 (estructurasProgram -> controlStructure .)
    PRINT           reduce using rule 15 (estructurasProgram -> controlStructure .)
    INT             reduce using rule 15 (estructurasProgram -> controlStructure .)
    FLOAT           reduce using rule 15 (estructurasProgram -> controlStructure .)
    FUNCTION        reduce using rule 15 (estructurasProgram -> controlStructure .)
    CLASS           reduce using rule 15 (estructurasProgram -> controlStructure .)
    WHILE           reduce using rule 15 (estructurasProgram -> controlStructure .)
    SWITCH          reduce using rule 15 (estructurasProgram -> controlStructure .)
    IF              reduce using rule 15 (estructurasProgram -> controlStructure .)
    FOR             reduce using rule 15 (estructurasProgram -> controlStructure .)
    FOREACH         reduce using rule 15 (estructurasProgram -> controlStructure .)
    $end            reduce using rule 15 (estructurasProgram -> controlStructure .)
    RBRACE          reduce using rule 15 (estructurasProgram -> controlStructure .)
    BREAK           reduce using rule 15 (estructurasProgram -> controlStructure .)


state 14

    (16) estructurasProgram -> dataStructure .

    VARIABLE        reduce using rule 16 (estructurasProgram -> dataStructure .)
    ECHO            reduce using rule 16 (estructurasProgram -> dataStructure .)
    PRINT           reduce using rule 16 (estructurasProgram -> dataStructure .)
    INT             reduce using rule 16 (estructurasProgram -> dataStructure .)
    FLOAT           reduce using rule 16 (estructurasProgram -> dataStructure .)
    FUNCTION        reduce using rule 16 (estructurasProgram -> dataStructure .)
    CLASS           reduce using rule 16 (estructurasProgram -> dataStructure .)
    WHILE           reduce using rule 16 (estructurasProgram -> dataStructure .)
    SWITCH          reduce using rule 16 (estructurasProgram -> dataStructure .)
    IF              reduce using rule 16 (estructurasProgram -> dataStructure .)
    FOR             reduce using rule 16 (estructurasProgram -> dataStructure .)
    FOREACH         reduce using rule 16 (estructurasProgram -> dataStructure .)
    $end            reduce using rule 16 (estructurasProgram -> dataStructure .)
    RBRACE          reduce using rule 16 (estructurasProgram -> dataStructure .)
    BREAK           reduce using rule 16 (estructurasProgram -> dataStructure .)


state 15

    (17) estructurasProgram -> funcionDeclarate .

    VARIABLE        reduce using rule 17 (estructurasProgram -> funcionDeclarate .)
    ECHO            reduce using rule 17 (estructurasProgram -> funcionDeclarate .)
    PRINT           reduce using rule 17 (estructurasProgram -> funcionDeclarate .)
    INT             reduce using rule 17 (estructurasProgram -> funcionDeclarate .)
    FLOAT           reduce using rule 17 (estructurasProgram -> funcionDeclarate .)
    FUNCTION        reduce using rule 17 (estructurasProgram -> funcionDeclarate .)
    CLASS           reduce using rule 17 (estructurasProgram -> funcionDeclarate .)
    WHILE           reduce using rule 17 (estructurasProgram -> funcionDeclarate .)
    SWITCH          reduce using rule 17 (estructurasProgram -> funcionDeclarate .)
    IF              reduce using rule 17 (estructurasProgram -> funcionDeclarate .)
    FOR             reduce using rule 17 (estructurasProgram -> funcionDeclarate .)
    FOREACH         reduce using rule 17 (estructurasProgram -> funcionDeclarate .)
    $end            reduce using rule 17 (estructurasProgram -> funcionDeclarate .)
    RBRACE          reduce using rule 17 (estructurasProgram -> funcionDeclarate .)
    BREAK           reduce using rule 17 (estructurasProgram -> funcionDeclarate .)


state 16

    (18) estructurasProgram -> classDeclarate .

    VARIABLE        reduce using rule 18 (estructurasProgram -> classDeclarate .)
    ECHO            reduce using rule 18 (estructurasProgram -> classDeclarate .)
    PRINT           reduce using rule 18 (estructurasProgram -> classDeclarate .)
    INT             reduce using rule 18 (estructurasProgram -> classDeclarate .)
    FLOAT           reduce using rule 18 (estructurasProgram -> classDeclarate .)
    FUNCTION        reduce using rule 18 (estructurasProgram -> classDeclarate .)
    CLASS           reduce using rule 18 (estructurasProgram -> classDeclarate .)
    WHILE           reduce using rule 18 (estructurasProgram -> classDeclarate .)
    SWITCH          reduce using rule 18 (estructurasProgram -> classDeclarate .)
    IF              reduce using rule 18 (estructurasProgram -> classDeclarate .)
    FOR             reduce using rule 18 (estructurasProgram -> classDeclarate .)
    FOREACH         reduce using rule 18 (estructurasProgram -> classDeclarate .)
    $end            reduce using rule 18 (estructurasProgram -> classDeclarate .)
    RBRACE          reduce using rule 18 (estructurasProgram -> classDeclarate .)
    BREAK           reduce using rule 18 (estructurasProgram -> classDeclarate .)


state 17

    (19) controlStructure -> if .

    VARIABLE        reduce using rule 19 (controlStructure -> if .)
    ECHO            reduce using rule 19 (controlStructure -> if .)
    PRINT           reduce using rule 19 (controlStructure -> if .)
    INT             reduce using rule 19 (controlStructure -> if .)
    FLOAT           reduce using rule 19 (controlStructure -> if .)
    FUNCTION        reduce using rule 19 (controlStructure -> if .)
    CLASS           reduce using rule 19 (controlStructure -> if .)
    WHILE           reduce using rule 19 (controlStructure -> if .)
    SWITCH          reduce using rule 19 (controlStructure -> if .)
    IF              reduce using rule 19 (controlStructure -> if .)
    FOR             reduce using rule 19 (controlStructure -> if .)
    FOREACH         reduce using rule 19 (controlStructure -> if .)
    $end            reduce using rule 19 (controlStructure -> if .)
    RBRACE          reduce using rule 19 (controlStructure -> if .)
    BREAK           reduce using rule 19 (controlStructure -> if .)


state 18

    (20) controlStructure -> for .

    VARIABLE        reduce using rule 20 (controlStructure -> for .)
    ECHO            reduce using rule 20 (controlStructure -> for .)
    PRINT           reduce using rule 20 (controlStructure -> for .)
    INT             reduce using rule 20 (controlStructure -> for .)
    FLOAT           reduce using rule 20 (controlStructure -> for .)
    FUNCTION        reduce using rule 20 (controlStructure -> for .)
    CLASS           reduce using rule 20 (controlStructure -> for .)
    WHILE           reduce using rule 20 (controlStructure -> for .)
    SWITCH          reduce using rule 20 (controlStructure -> for .)
    IF              reduce using rule 20 (controlStructure -> for .)
    FOR             reduce using rule 20 (controlStructure -> for .)
    FOREACH         reduce using rule 20 (controlStructure -> for .)
    $end            reduce using rule 20 (controlStructure -> for .)
    RBRACE          reduce using rule 20 (controlStructure -> for .)
    BREAK           reduce using rule 20 (controlStructure -> for .)


state 19

    (21) controlStructure -> while .

    VARIABLE        reduce using rule 21 (controlStructure -> while .)
    ECHO            reduce using rule 21 (controlStructure -> while .)
    PRINT           reduce using rule 21 (controlStructure -> while .)
    INT             reduce using rule 21 (controlStructure -> while .)
    FLOAT           reduce using rule 21 (controlStructure -> while .)
    FUNCTION        reduce using rule 21 (controlStructure -> while .)
    CLASS           reduce using rule 21 (controlStructure -> while .)
    WHILE           reduce using rule 21 (controlStructure -> while .)
    SWITCH          reduce using rule 21 (controlStructure -> while .)
    IF              reduce using rule 21 (controlStructure -> while .)
    FOR             reduce using rule 21 (controlStructure -> while .)
    FOREACH         reduce using rule 21 (controlStructure -> while .)
    $end            reduce using rule 21 (controlStructure -> while .)
    RBRACE          reduce using rule 21 (controlStructure -> while .)
    BREAK           reduce using rule 21 (controlStructure -> while .)


state 20

    (22) controlStructure -> switch .

    VARIABLE        reduce using rule 22 (controlStructure -> switch .)
    ECHO            reduce using rule 22 (controlStructure -> switch .)
    PRINT           reduce using rule 22 (controlStructure -> switch .)
    INT             reduce using rule 22 (controlStructure -> switch .)
    FLOAT           reduce using rule 22 (controlStructure -> switch .)
    FUNCTION        reduce using rule 22 (controlStructure -> switch .)
    CLASS           reduce using rule 22 (controlStructure -> switch .)
    WHILE           reduce using rule 22 (controlStructure -> switch .)
    SWITCH          reduce using rule 22 (controlStructure -> switch .)
    IF              reduce using rule 22 (controlStructure -> switch .)
    FOR             reduce using rule 22 (controlStructure -> switch .)
    FOREACH         reduce using rule 22 (controlStructure -> switch .)
    $end            reduce using rule 22 (controlStructure -> switch .)
    RBRACE          reduce using rule 22 (controlStructure -> switch .)
    BREAK           reduce using rule 22 (controlStructure -> switch .)


state 21

    (60) dataStructure -> array .

    VARIABLE        reduce using rule 60 (dataStructure -> array .)
    ECHO            reduce using rule 60 (dataStructure -> array .)
    PRINT           reduce using rule 60 (dataStructure -> array .)
    INT             reduce using rule 60 (dataStructure -> array .)
    FLOAT           reduce using rule 60 (dataStructure -> array .)
    FUNCTION        reduce using rule 60 (dataStructure -> array .)
    CLASS           reduce using rule 60 (dataStructure -> array .)
    WHILE           reduce using rule 60 (dataStructure -> array .)
    SWITCH          reduce using rule 60 (dataStructure -> array .)
    IF              reduce using rule 60 (dataStructure -> array .)
    FOR             reduce using rule 60 (dataStructure -> array .)
    FOREACH         reduce using rule 60 (dataStructure -> array .)
    $end            reduce using rule 60 (dataStructure -> array .)
    RBRACE          reduce using rule 60 (dataStructure -> array .)
    BREAK           reduce using rule 60 (dataStructure -> array .)


state 22

    (61) dataStructure -> map .

    VARIABLE        reduce using rule 61 (dataStructure -> map .)
    ECHO            reduce using rule 61 (dataStructure -> map .)
    PRINT           reduce using rule 61 (dataStructure -> map .)
    INT             reduce using rule 61 (dataStructure -> map .)
    FLOAT           reduce using rule 61 (dataStructure -> map .)
    FUNCTION        reduce using rule 61 (dataStructure -> map .)
    CLASS           reduce using rule 61 (dataStructure -> map .)
    WHILE           reduce using rule 61 (dataStructure -> map .)
    SWITCH          reduce using rule 61 (dataStructure -> map .)
    IF              reduce using rule 61 (dataStructure -> map .)
    FOR             reduce using rule 61 (dataStructure -> map .)
    FOREACH         reduce using rule 61 (dataStructure -> map .)
    $end            reduce using rule 61 (dataStructure -> map .)
    RBRACE          reduce using rule 61 (dataStructure -> map .)
    BREAK           reduce using rule 61 (dataStructure -> map .)


state 23

    (62) funcionDeclarate -> FUNCTION . ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> FUNCTION . ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE

    ID              shift and go to state 56


state 24

    (76) classDeclarate -> CLASS . ID LBRACE classBody RBRACE
    (77) classDeclarate -> CLASS . ID EXTENDS ID LBRACE classBody RBRACE

    ID              shift and go to state 57


state 25

    (23) if -> statementif . ELSE body
    (24) if -> statementif . ELSE if
    (25) if -> statementif . ELSEIF if
    (26) if -> statementif .

    ELSE            shift and go to state 58
    ELSEIF          shift and go to state 59
    VARIABLE        reduce using rule 26 (if -> statementif .)
    ECHO            reduce using rule 26 (if -> statementif .)
    PRINT           reduce using rule 26 (if -> statementif .)
    INT             reduce using rule 26 (if -> statementif .)
    FLOAT           reduce using rule 26 (if -> statementif .)
    FUNCTION        reduce using rule 26 (if -> statementif .)
    CLASS           reduce using rule 26 (if -> statementif .)
    WHILE           reduce using rule 26 (if -> statementif .)
    SWITCH          reduce using rule 26 (if -> statementif .)
    IF              reduce using rule 26 (if -> statementif .)
    FOR             reduce using rule 26 (if -> statementif .)
    FOREACH         reduce using rule 26 (if -> statementif .)
    $end            reduce using rule 26 (if -> statementif .)
    RBRACE          reduce using rule 26 (if -> statementif .)
    BREAK           reduce using rule 26 (if -> statementif .)


state 26

    (43) for -> forStatement .

    VARIABLE        reduce using rule 43 (for -> forStatement .)
    ECHO            reduce using rule 43 (for -> forStatement .)
    PRINT           reduce using rule 43 (for -> forStatement .)
    INT             reduce using rule 43 (for -> forStatement .)
    FLOAT           reduce using rule 43 (for -> forStatement .)
    FUNCTION        reduce using rule 43 (for -> forStatement .)
    CLASS           reduce using rule 43 (for -> forStatement .)
    WHILE           reduce using rule 43 (for -> forStatement .)
    SWITCH          reduce using rule 43 (for -> forStatement .)
    IF              reduce using rule 43 (for -> forStatement .)
    FOR             reduce using rule 43 (for -> forStatement .)
    FOREACH         reduce using rule 43 (for -> forStatement .)
    $end            reduce using rule 43 (for -> forStatement .)
    RBRACE          reduce using rule 43 (for -> forStatement .)
    BREAK           reduce using rule 43 (for -> forStatement .)


state 27

    (48) while -> WHILE . LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> WHILE . LPAREN condition RPAREN LBRACE RBRACE

    LPAREN          shift and go to state 60


state 28

    (50) switch -> SWITCH . LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> SWITCH . LPAREN condition RPAREN LBRACE RBRACE

    LPAREN          shift and go to state 61


state 29

    (27) statementif -> IF . LPAREN conditionProdu RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 62


state 30

    (44) forStatement -> FOR . LPAREN forcondition RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 63


state 31

    (45) forStatement -> FOREACH . LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

    LPAREN          shift and go to state 64


state 32

    (2) programa -> sentencia programa .

    $end            reduce using rule 2 (programa -> sentencia programa .)


state 33

    (12) asignacion -> VARIABLE EQUALS . operaArit SEMICOLON
    (8) asignacion_fgets -> VARIABLE EQUALS . FGETS LPAREN STDIN RPAREN SEMICOLON
    (90) array -> VARIABLE EQUALS . LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> VARIABLE EQUALS . ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> VARIABLE EQUALS . ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> VARIABLE EQUALS . LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> VARIABLE EQUALS . LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> VARIABLE EQUALS . ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (125) operaArit -> . valor
    (126) operaArit -> . valor operador operaArit
    (127) operaArit -> . valor DOT valor
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    FGETS           shift and go to state 66
    LBRACKET        shift and go to state 67
    ARRAY           shift and go to state 68
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    operaArit                      shift and go to state 65
    valor                          shift and go to state 69
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 34

    (13) impresion -> ECHO imprimir . SEMICOLON

    SEMICOLON       shift and go to state 70


state 35

    (102) imprimir -> LPAREN . repiteValores RPAREN
    (103) imprimir -> LPAREN . RPAREN
    (123) repiteValores -> . valor COMMA repiteValores
    (124) repiteValores -> . valor
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    RPAREN          shift and go to state 72
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    repiteValores                  shift and go to state 71
    valor                          shift and go to state 37
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 36

    (104) imprimir -> repiteValores .

    SEMICOLON       reduce using rule 104 (imprimir -> repiteValores .)


state 37

    (123) repiteValores -> valor . COMMA repiteValores
    (124) repiteValores -> valor .

    COMMA           shift and go to state 73
    SEMICOLON       reduce using rule 124 (repiteValores -> valor .)
    RPAREN          reduce using rule 124 (repiteValores -> valor .)
    RBRACKET        reduce using rule 124 (repiteValores -> valor .)


state 38

    (105) valor -> INT .

    COMMA           reduce using rule 105 (valor -> INT .)
    SEMICOLON       reduce using rule 105 (valor -> INT .)
    DOT             reduce using rule 105 (valor -> INT .)
    PLUS            reduce using rule 105 (valor -> INT .)
    MINUS           reduce using rule 105 (valor -> INT .)
    TIMES           reduce using rule 105 (valor -> INT .)
    DIVIDE          reduce using rule 105 (valor -> INT .)
    MODULO          reduce using rule 105 (valor -> INT .)
    RPAREN          reduce using rule 105 (valor -> INT .)
    EQ              reduce using rule 105 (valor -> INT .)
    NEQ             reduce using rule 105 (valor -> INT .)
    STRICTEQ        reduce using rule 105 (valor -> INT .)
    STRICTNEQ       reduce using rule 105 (valor -> INT .)
    LT              reduce using rule 105 (valor -> INT .)
    GT              reduce using rule 105 (valor -> INT .)
    LEQ             reduce using rule 105 (valor -> INT .)
    GEQ             reduce using rule 105 (valor -> INT .)
    ARROWMAP        reduce using rule 105 (valor -> INT .)
    RBRACKET        reduce using rule 105 (valor -> INT .)
    COLON           reduce using rule 105 (valor -> INT .)
    AND             reduce using rule 105 (valor -> INT .)
    OR              reduce using rule 105 (valor -> INT .)
    NOT             reduce using rule 105 (valor -> INT .)
    LPAREN          reduce using rule 105 (valor -> INT .)
    INT             reduce using rule 105 (valor -> INT .)
    FLOAT           reduce using rule 105 (valor -> INT .)
    VARIABLE        reduce using rule 105 (valor -> INT .)
    STRING          reduce using rule 105 (valor -> INT .)
    TRUE            reduce using rule 105 (valor -> INT .)
    FALSE           reduce using rule 105 (valor -> INT .)
    THIS            reduce using rule 105 (valor -> INT .)
    ID              reduce using rule 105 (valor -> INT .)
    QUESTION        reduce using rule 105 (valor -> INT .)


state 39

    (106) valor -> FLOAT .

    COMMA           reduce using rule 106 (valor -> FLOAT .)
    SEMICOLON       reduce using rule 106 (valor -> FLOAT .)
    DOT             reduce using rule 106 (valor -> FLOAT .)
    PLUS            reduce using rule 106 (valor -> FLOAT .)
    MINUS           reduce using rule 106 (valor -> FLOAT .)
    TIMES           reduce using rule 106 (valor -> FLOAT .)
    DIVIDE          reduce using rule 106 (valor -> FLOAT .)
    MODULO          reduce using rule 106 (valor -> FLOAT .)
    RPAREN          reduce using rule 106 (valor -> FLOAT .)
    EQ              reduce using rule 106 (valor -> FLOAT .)
    NEQ             reduce using rule 106 (valor -> FLOAT .)
    STRICTEQ        reduce using rule 106 (valor -> FLOAT .)
    STRICTNEQ       reduce using rule 106 (valor -> FLOAT .)
    LT              reduce using rule 106 (valor -> FLOAT .)
    GT              reduce using rule 106 (valor -> FLOAT .)
    LEQ             reduce using rule 106 (valor -> FLOAT .)
    GEQ             reduce using rule 106 (valor -> FLOAT .)
    ARROWMAP        reduce using rule 106 (valor -> FLOAT .)
    RBRACKET        reduce using rule 106 (valor -> FLOAT .)
    COLON           reduce using rule 106 (valor -> FLOAT .)
    AND             reduce using rule 106 (valor -> FLOAT .)
    OR              reduce using rule 106 (valor -> FLOAT .)
    NOT             reduce using rule 106 (valor -> FLOAT .)
    LPAREN          reduce using rule 106 (valor -> FLOAT .)
    INT             reduce using rule 106 (valor -> FLOAT .)
    FLOAT           reduce using rule 106 (valor -> FLOAT .)
    VARIABLE        reduce using rule 106 (valor -> FLOAT .)
    STRING          reduce using rule 106 (valor -> FLOAT .)
    TRUE            reduce using rule 106 (valor -> FLOAT .)
    FALSE           reduce using rule 106 (valor -> FLOAT .)
    THIS            reduce using rule 106 (valor -> FLOAT .)
    ID              reduce using rule 106 (valor -> FLOAT .)
    QUESTION        reduce using rule 106 (valor -> FLOAT .)


state 40

    (107) valor -> VARIABLE .
    (75) funcionAnonima -> VARIABLE . EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    COMMA           reduce using rule 107 (valor -> VARIABLE .)
    SEMICOLON       reduce using rule 107 (valor -> VARIABLE .)
    DOT             reduce using rule 107 (valor -> VARIABLE .)
    PLUS            reduce using rule 107 (valor -> VARIABLE .)
    MINUS           reduce using rule 107 (valor -> VARIABLE .)
    TIMES           reduce using rule 107 (valor -> VARIABLE .)
    DIVIDE          reduce using rule 107 (valor -> VARIABLE .)
    MODULO          reduce using rule 107 (valor -> VARIABLE .)
    RPAREN          reduce using rule 107 (valor -> VARIABLE .)
    EQ              reduce using rule 107 (valor -> VARIABLE .)
    NEQ             reduce using rule 107 (valor -> VARIABLE .)
    STRICTEQ        reduce using rule 107 (valor -> VARIABLE .)
    STRICTNEQ       reduce using rule 107 (valor -> VARIABLE .)
    LT              reduce using rule 107 (valor -> VARIABLE .)
    GT              reduce using rule 107 (valor -> VARIABLE .)
    LEQ             reduce using rule 107 (valor -> VARIABLE .)
    GEQ             reduce using rule 107 (valor -> VARIABLE .)
    ARROWMAP        reduce using rule 107 (valor -> VARIABLE .)
    RBRACKET        reduce using rule 107 (valor -> VARIABLE .)
    COLON           reduce using rule 107 (valor -> VARIABLE .)
    AND             reduce using rule 107 (valor -> VARIABLE .)
    OR              reduce using rule 107 (valor -> VARIABLE .)
    NOT             reduce using rule 107 (valor -> VARIABLE .)
    LPAREN          reduce using rule 107 (valor -> VARIABLE .)
    INT             reduce using rule 107 (valor -> VARIABLE .)
    FLOAT           reduce using rule 107 (valor -> VARIABLE .)
    VARIABLE        reduce using rule 107 (valor -> VARIABLE .)
    STRING          reduce using rule 107 (valor -> VARIABLE .)
    TRUE            reduce using rule 107 (valor -> VARIABLE .)
    FALSE           reduce using rule 107 (valor -> VARIABLE .)
    THIS            reduce using rule 107 (valor -> VARIABLE .)
    ID              reduce using rule 107 (valor -> VARIABLE .)
    QUESTION        reduce using rule 107 (valor -> VARIABLE .)
    EQUALS          shift and go to state 74


state 41

    (108) valor -> STRING .

    COMMA           reduce using rule 108 (valor -> STRING .)
    SEMICOLON       reduce using rule 108 (valor -> STRING .)
    DOT             reduce using rule 108 (valor -> STRING .)
    PLUS            reduce using rule 108 (valor -> STRING .)
    MINUS           reduce using rule 108 (valor -> STRING .)
    TIMES           reduce using rule 108 (valor -> STRING .)
    DIVIDE          reduce using rule 108 (valor -> STRING .)
    MODULO          reduce using rule 108 (valor -> STRING .)
    RPAREN          reduce using rule 108 (valor -> STRING .)
    EQ              reduce using rule 108 (valor -> STRING .)
    NEQ             reduce using rule 108 (valor -> STRING .)
    STRICTEQ        reduce using rule 108 (valor -> STRING .)
    STRICTNEQ       reduce using rule 108 (valor -> STRING .)
    LT              reduce using rule 108 (valor -> STRING .)
    GT              reduce using rule 108 (valor -> STRING .)
    LEQ             reduce using rule 108 (valor -> STRING .)
    GEQ             reduce using rule 108 (valor -> STRING .)
    ARROWMAP        reduce using rule 108 (valor -> STRING .)
    RBRACKET        reduce using rule 108 (valor -> STRING .)
    COLON           reduce using rule 108 (valor -> STRING .)
    AND             reduce using rule 108 (valor -> STRING .)
    OR              reduce using rule 108 (valor -> STRING .)
    NOT             reduce using rule 108 (valor -> STRING .)
    LPAREN          reduce using rule 108 (valor -> STRING .)
    INT             reduce using rule 108 (valor -> STRING .)
    FLOAT           reduce using rule 108 (valor -> STRING .)
    VARIABLE        reduce using rule 108 (valor -> STRING .)
    STRING          reduce using rule 108 (valor -> STRING .)
    TRUE            reduce using rule 108 (valor -> STRING .)
    FALSE           reduce using rule 108 (valor -> STRING .)
    THIS            reduce using rule 108 (valor -> STRING .)
    ID              reduce using rule 108 (valor -> STRING .)
    QUESTION        reduce using rule 108 (valor -> STRING .)


state 42

    (109) valor -> TRUE .

    COMMA           reduce using rule 109 (valor -> TRUE .)
    SEMICOLON       reduce using rule 109 (valor -> TRUE .)
    DOT             reduce using rule 109 (valor -> TRUE .)
    PLUS            reduce using rule 109 (valor -> TRUE .)
    MINUS           reduce using rule 109 (valor -> TRUE .)
    TIMES           reduce using rule 109 (valor -> TRUE .)
    DIVIDE          reduce using rule 109 (valor -> TRUE .)
    MODULO          reduce using rule 109 (valor -> TRUE .)
    RPAREN          reduce using rule 109 (valor -> TRUE .)
    EQ              reduce using rule 109 (valor -> TRUE .)
    NEQ             reduce using rule 109 (valor -> TRUE .)
    STRICTEQ        reduce using rule 109 (valor -> TRUE .)
    STRICTNEQ       reduce using rule 109 (valor -> TRUE .)
    LT              reduce using rule 109 (valor -> TRUE .)
    GT              reduce using rule 109 (valor -> TRUE .)
    LEQ             reduce using rule 109 (valor -> TRUE .)
    GEQ             reduce using rule 109 (valor -> TRUE .)
    ARROWMAP        reduce using rule 109 (valor -> TRUE .)
    RBRACKET        reduce using rule 109 (valor -> TRUE .)
    COLON           reduce using rule 109 (valor -> TRUE .)
    AND             reduce using rule 109 (valor -> TRUE .)
    OR              reduce using rule 109 (valor -> TRUE .)
    NOT             reduce using rule 109 (valor -> TRUE .)
    LPAREN          reduce using rule 109 (valor -> TRUE .)
    INT             reduce using rule 109 (valor -> TRUE .)
    FLOAT           reduce using rule 109 (valor -> TRUE .)
    VARIABLE        reduce using rule 109 (valor -> TRUE .)
    STRING          reduce using rule 109 (valor -> TRUE .)
    TRUE            reduce using rule 109 (valor -> TRUE .)
    FALSE           reduce using rule 109 (valor -> TRUE .)
    THIS            reduce using rule 109 (valor -> TRUE .)
    ID              reduce using rule 109 (valor -> TRUE .)
    QUESTION        reduce using rule 109 (valor -> TRUE .)


state 43

    (110) valor -> FALSE .

    COMMA           reduce using rule 110 (valor -> FALSE .)
    SEMICOLON       reduce using rule 110 (valor -> FALSE .)
    DOT             reduce using rule 110 (valor -> FALSE .)
    PLUS            reduce using rule 110 (valor -> FALSE .)
    MINUS           reduce using rule 110 (valor -> FALSE .)
    TIMES           reduce using rule 110 (valor -> FALSE .)
    DIVIDE          reduce using rule 110 (valor -> FALSE .)
    MODULO          reduce using rule 110 (valor -> FALSE .)
    RPAREN          reduce using rule 110 (valor -> FALSE .)
    EQ              reduce using rule 110 (valor -> FALSE .)
    NEQ             reduce using rule 110 (valor -> FALSE .)
    STRICTEQ        reduce using rule 110 (valor -> FALSE .)
    STRICTNEQ       reduce using rule 110 (valor -> FALSE .)
    LT              reduce using rule 110 (valor -> FALSE .)
    GT              reduce using rule 110 (valor -> FALSE .)
    LEQ             reduce using rule 110 (valor -> FALSE .)
    GEQ             reduce using rule 110 (valor -> FALSE .)
    ARROWMAP        reduce using rule 110 (valor -> FALSE .)
    RBRACKET        reduce using rule 110 (valor -> FALSE .)
    COLON           reduce using rule 110 (valor -> FALSE .)
    AND             reduce using rule 110 (valor -> FALSE .)
    OR              reduce using rule 110 (valor -> FALSE .)
    NOT             reduce using rule 110 (valor -> FALSE .)
    LPAREN          reduce using rule 110 (valor -> FALSE .)
    INT             reduce using rule 110 (valor -> FALSE .)
    FLOAT           reduce using rule 110 (valor -> FALSE .)
    VARIABLE        reduce using rule 110 (valor -> FALSE .)
    STRING          reduce using rule 110 (valor -> FALSE .)
    TRUE            reduce using rule 110 (valor -> FALSE .)
    FALSE           reduce using rule 110 (valor -> FALSE .)
    THIS            reduce using rule 110 (valor -> FALSE .)
    ID              reduce using rule 110 (valor -> FALSE .)
    QUESTION        reduce using rule 110 (valor -> FALSE .)


state 44

    (111) valor -> THIS .

    COMMA           reduce using rule 111 (valor -> THIS .)
    SEMICOLON       reduce using rule 111 (valor -> THIS .)
    DOT             reduce using rule 111 (valor -> THIS .)
    PLUS            reduce using rule 111 (valor -> THIS .)
    MINUS           reduce using rule 111 (valor -> THIS .)
    TIMES           reduce using rule 111 (valor -> THIS .)
    DIVIDE          reduce using rule 111 (valor -> THIS .)
    MODULO          reduce using rule 111 (valor -> THIS .)
    RPAREN          reduce using rule 111 (valor -> THIS .)
    EQ              reduce using rule 111 (valor -> THIS .)
    NEQ             reduce using rule 111 (valor -> THIS .)
    STRICTEQ        reduce using rule 111 (valor -> THIS .)
    STRICTNEQ       reduce using rule 111 (valor -> THIS .)
    LT              reduce using rule 111 (valor -> THIS .)
    GT              reduce using rule 111 (valor -> THIS .)
    LEQ             reduce using rule 111 (valor -> THIS .)
    GEQ             reduce using rule 111 (valor -> THIS .)
    ARROWMAP        reduce using rule 111 (valor -> THIS .)
    RBRACKET        reduce using rule 111 (valor -> THIS .)
    COLON           reduce using rule 111 (valor -> THIS .)
    AND             reduce using rule 111 (valor -> THIS .)
    OR              reduce using rule 111 (valor -> THIS .)
    NOT             reduce using rule 111 (valor -> THIS .)
    LPAREN          reduce using rule 111 (valor -> THIS .)
    INT             reduce using rule 111 (valor -> THIS .)
    FLOAT           reduce using rule 111 (valor -> THIS .)
    VARIABLE        reduce using rule 111 (valor -> THIS .)
    STRING          reduce using rule 111 (valor -> THIS .)
    TRUE            reduce using rule 111 (valor -> THIS .)
    FALSE           reduce using rule 111 (valor -> THIS .)
    THIS            reduce using rule 111 (valor -> THIS .)
    ID              reduce using rule 111 (valor -> THIS .)
    QUESTION        reduce using rule 111 (valor -> THIS .)


state 45

    (112) valor -> funcionParen .

    COMMA           reduce using rule 112 (valor -> funcionParen .)
    SEMICOLON       reduce using rule 112 (valor -> funcionParen .)
    DOT             reduce using rule 112 (valor -> funcionParen .)
    PLUS            reduce using rule 112 (valor -> funcionParen .)
    MINUS           reduce using rule 112 (valor -> funcionParen .)
    TIMES           reduce using rule 112 (valor -> funcionParen .)
    DIVIDE          reduce using rule 112 (valor -> funcionParen .)
    MODULO          reduce using rule 112 (valor -> funcionParen .)
    RPAREN          reduce using rule 112 (valor -> funcionParen .)
    EQ              reduce using rule 112 (valor -> funcionParen .)
    NEQ             reduce using rule 112 (valor -> funcionParen .)
    STRICTEQ        reduce using rule 112 (valor -> funcionParen .)
    STRICTNEQ       reduce using rule 112 (valor -> funcionParen .)
    LT              reduce using rule 112 (valor -> funcionParen .)
    GT              reduce using rule 112 (valor -> funcionParen .)
    LEQ             reduce using rule 112 (valor -> funcionParen .)
    GEQ             reduce using rule 112 (valor -> funcionParen .)
    ARROWMAP        reduce using rule 112 (valor -> funcionParen .)
    RBRACKET        reduce using rule 112 (valor -> funcionParen .)
    COLON           reduce using rule 112 (valor -> funcionParen .)
    AND             reduce using rule 112 (valor -> funcionParen .)
    OR              reduce using rule 112 (valor -> funcionParen .)
    NOT             reduce using rule 112 (valor -> funcionParen .)
    LPAREN          reduce using rule 112 (valor -> funcionParen .)
    INT             reduce using rule 112 (valor -> funcionParen .)
    FLOAT           reduce using rule 112 (valor -> funcionParen .)
    VARIABLE        reduce using rule 112 (valor -> funcionParen .)
    STRING          reduce using rule 112 (valor -> funcionParen .)
    TRUE            reduce using rule 112 (valor -> funcionParen .)
    FALSE           reduce using rule 112 (valor -> funcionParen .)
    THIS            reduce using rule 112 (valor -> funcionParen .)
    ID              reduce using rule 112 (valor -> funcionParen .)
    QUESTION        reduce using rule 112 (valor -> funcionParen .)


state 46

    (113) valor -> funcionAnonima .

    COMMA           reduce using rule 113 (valor -> funcionAnonima .)
    SEMICOLON       reduce using rule 113 (valor -> funcionAnonima .)
    DOT             reduce using rule 113 (valor -> funcionAnonima .)
    PLUS            reduce using rule 113 (valor -> funcionAnonima .)
    MINUS           reduce using rule 113 (valor -> funcionAnonima .)
    TIMES           reduce using rule 113 (valor -> funcionAnonima .)
    DIVIDE          reduce using rule 113 (valor -> funcionAnonima .)
    MODULO          reduce using rule 113 (valor -> funcionAnonima .)
    RPAREN          reduce using rule 113 (valor -> funcionAnonima .)
    EQ              reduce using rule 113 (valor -> funcionAnonima .)
    NEQ             reduce using rule 113 (valor -> funcionAnonima .)
    STRICTEQ        reduce using rule 113 (valor -> funcionAnonima .)
    STRICTNEQ       reduce using rule 113 (valor -> funcionAnonima .)
    LT              reduce using rule 113 (valor -> funcionAnonima .)
    GT              reduce using rule 113 (valor -> funcionAnonima .)
    LEQ             reduce using rule 113 (valor -> funcionAnonima .)
    GEQ             reduce using rule 113 (valor -> funcionAnonima .)
    ARROWMAP        reduce using rule 113 (valor -> funcionAnonima .)
    RBRACKET        reduce using rule 113 (valor -> funcionAnonima .)
    COLON           reduce using rule 113 (valor -> funcionAnonima .)
    AND             reduce using rule 113 (valor -> funcionAnonima .)
    OR              reduce using rule 113 (valor -> funcionAnonima .)
    NOT             reduce using rule 113 (valor -> funcionAnonima .)
    LPAREN          reduce using rule 113 (valor -> funcionAnonima .)
    INT             reduce using rule 113 (valor -> funcionAnonima .)
    FLOAT           reduce using rule 113 (valor -> funcionAnonima .)
    VARIABLE        reduce using rule 113 (valor -> funcionAnonima .)
    STRING          reduce using rule 113 (valor -> funcionAnonima .)
    TRUE            reduce using rule 113 (valor -> funcionAnonima .)
    FALSE           reduce using rule 113 (valor -> funcionAnonima .)
    THIS            reduce using rule 113 (valor -> funcionAnonima .)
    ID              reduce using rule 113 (valor -> funcionAnonima .)
    QUESTION        reduce using rule 113 (valor -> funcionAnonima .)


state 47

    (74) funcionParen -> ID . LPAREN parametros RPAREN

    LPAREN          shift and go to state 75


state 48

    (14) impresion -> PRINT imprimir . SEMICOLON

    SEMICOLON       shift and go to state 76


state 49

    (119) comparacion -> INT operador . INT
    (121) comparacion -> INT operador . FLOAT

    INT             shift and go to state 77
    FLOAT           shift and go to state 78


state 50

    (133) operador -> PLUS .

    INT             reduce using rule 133 (operador -> PLUS .)
    FLOAT           reduce using rule 133 (operador -> PLUS .)
    VARIABLE        reduce using rule 133 (operador -> PLUS .)
    STRING          reduce using rule 133 (operador -> PLUS .)
    TRUE            reduce using rule 133 (operador -> PLUS .)
    FALSE           reduce using rule 133 (operador -> PLUS .)
    THIS            reduce using rule 133 (operador -> PLUS .)
    ID              reduce using rule 133 (operador -> PLUS .)


state 51

    (134) operador -> MINUS .

    INT             reduce using rule 134 (operador -> MINUS .)
    FLOAT           reduce using rule 134 (operador -> MINUS .)
    VARIABLE        reduce using rule 134 (operador -> MINUS .)
    STRING          reduce using rule 134 (operador -> MINUS .)
    TRUE            reduce using rule 134 (operador -> MINUS .)
    FALSE           reduce using rule 134 (operador -> MINUS .)
    THIS            reduce using rule 134 (operador -> MINUS .)
    ID              reduce using rule 134 (operador -> MINUS .)


state 52

    (135) operador -> TIMES .

    INT             reduce using rule 135 (operador -> TIMES .)
    FLOAT           reduce using rule 135 (operador -> TIMES .)
    VARIABLE        reduce using rule 135 (operador -> TIMES .)
    STRING          reduce using rule 135 (operador -> TIMES .)
    TRUE            reduce using rule 135 (operador -> TIMES .)
    FALSE           reduce using rule 135 (operador -> TIMES .)
    THIS            reduce using rule 135 (operador -> TIMES .)
    ID              reduce using rule 135 (operador -> TIMES .)


state 53

    (136) operador -> DIVIDE .

    INT             reduce using rule 136 (operador -> DIVIDE .)
    FLOAT           reduce using rule 136 (operador -> DIVIDE .)
    VARIABLE        reduce using rule 136 (operador -> DIVIDE .)
    STRING          reduce using rule 136 (operador -> DIVIDE .)
    TRUE            reduce using rule 136 (operador -> DIVIDE .)
    FALSE           reduce using rule 136 (operador -> DIVIDE .)
    THIS            reduce using rule 136 (operador -> DIVIDE .)
    ID              reduce using rule 136 (operador -> DIVIDE .)


state 54

    (137) operador -> MODULO .

    INT             reduce using rule 137 (operador -> MODULO .)
    FLOAT           reduce using rule 137 (operador -> MODULO .)
    VARIABLE        reduce using rule 137 (operador -> MODULO .)
    STRING          reduce using rule 137 (operador -> MODULO .)
    TRUE            reduce using rule 137 (operador -> MODULO .)
    FALSE           reduce using rule 137 (operador -> MODULO .)
    THIS            reduce using rule 137 (operador -> MODULO .)
    ID              reduce using rule 137 (operador -> MODULO .)


state 55

    (120) comparacion -> FLOAT operador . FLOAT
    (122) comparacion -> FLOAT operador . INT

    FLOAT           shift and go to state 79
    INT             shift and go to state 80


state 56

    (62) funcionDeclarate -> FUNCTION ID . LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> FUNCTION ID . LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE

    LPAREN          shift and go to state 81


state 57

    (76) classDeclarate -> CLASS ID . LBRACE classBody RBRACE
    (77) classDeclarate -> CLASS ID . EXTENDS ID LBRACE classBody RBRACE

    LBRACE          shift and go to state 82
    EXTENDS         shift and go to state 83


state 58

    (23) if -> statementif ELSE . body
    (24) if -> statementif ELSE . if
    (99) body -> . sentencia
    (100) body -> . sentencia sentencias
    (101) body -> . empty
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) sentencia -> . asignacion_fgets
    (139) empty -> .
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (12) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (13) impresion -> . ECHO imprimir SEMICOLON
    (14) impresion -> . PRINT imprimir SEMICOLON
    (119) comparacion -> . INT operador INT
    (120) comparacion -> . FLOAT operador FLOAT
    (121) comparacion -> . INT operador FLOAT
    (122) comparacion -> . FLOAT operador INT
    (15) estructurasProgram -> . controlStructure
    (16) estructurasProgram -> . dataStructure
    (17) estructurasProgram -> . funcionDeclarate
    (18) estructurasProgram -> . classDeclarate
    (8) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (19) controlStructure -> . if
    (20) controlStructure -> . for
    (21) controlStructure -> . while
    (22) controlStructure -> . switch
    (60) dataStructure -> . array
    (61) dataStructure -> . map
    (62) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (76) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (77) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (43) for -> . forStatement
    (48) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (50) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (90) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (44) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (45) forStatement -> . FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for FOREACH resolved as shift
    $end            reduce using rule 139 (empty -> .)
    RBRACE          reduce using rule 139 (empty -> .)
    BREAK           reduce using rule 139 (empty -> .)
    IF              shift and go to state 29
    VARIABLE        shift and go to state 8
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    FUNCTION        shift and go to state 23
    CLASS           shift and go to state 24
    WHILE           shift and go to state 27
    SWITCH          shift and go to state 28
    FOR             shift and go to state 30
    FOREACH         shift and go to state 31

  ! VARIABLE        [ reduce using rule 139 (empty -> .) ]
  ! ECHO            [ reduce using rule 139 (empty -> .) ]
  ! PRINT           [ reduce using rule 139 (empty -> .) ]
  ! INT             [ reduce using rule 139 (empty -> .) ]
  ! FLOAT           [ reduce using rule 139 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 139 (empty -> .) ]
  ! CLASS           [ reduce using rule 139 (empty -> .) ]
  ! WHILE           [ reduce using rule 139 (empty -> .) ]
  ! SWITCH          [ reduce using rule 139 (empty -> .) ]
  ! IF              [ reduce using rule 139 (empty -> .) ]
  ! FOR             [ reduce using rule 139 (empty -> .) ]
  ! FOREACH         [ reduce using rule 139 (empty -> .) ]

    statementif                    shift and go to state 25
    body                           shift and go to state 84
    if                             shift and go to state 85
    sentencia                      shift and go to state 86
    empty                          shift and go to state 87
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    asignacion_fgets               shift and go to state 7
    controlStructure               shift and go to state 13
    dataStructure                  shift and go to state 14
    funcionDeclarate               shift and go to state 15
    classDeclarate                 shift and go to state 16
    for                            shift and go to state 18
    while                          shift and go to state 19
    switch                         shift and go to state 20
    array                          shift and go to state 21
    map                            shift and go to state 22
    forStatement                   shift and go to state 26

state 59

    (25) if -> statementif ELSEIF . if
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE

    IF              shift and go to state 29

    statementif                    shift and go to state 25
    if                             shift and go to state 88

state 60

    (48) while -> WHILE LPAREN . condition RPAREN LBRACE body RBRACE
    (49) while -> WHILE LPAREN . condition RPAREN LBRACE RBRACE
    (30) condition -> . valor opSymbol valor
    (31) condition -> . LPAREN conditionProdu RPAREN
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 89
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    condition                      shift and go to state 90
    valor                          shift and go to state 91
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 61

    (50) switch -> SWITCH LPAREN . condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> SWITCH LPAREN . condition RPAREN LBRACE RBRACE
    (30) condition -> . valor opSymbol valor
    (31) condition -> . LPAREN conditionProdu RPAREN
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 89
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    condition                      shift and go to state 92
    valor                          shift and go to state 91
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 62

    (27) statementif -> IF LPAREN . conditionProdu RPAREN LBRACE body RBRACE
    (28) conditionProdu -> . condition
    (29) conditionProdu -> . condition opLogic condition conditionProdu
    (30) condition -> . valor opSymbol valor
    (31) condition -> . LPAREN conditionProdu RPAREN
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 89
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    conditionProdu                 shift and go to state 93
    condition                      shift and go to state 94
    valor                          shift and go to state 91
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 63

    (44) forStatement -> FOR LPAREN . forcondition RPAREN LBRACE body RBRACE
    (46) forcondition -> . VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (47) forcondition -> . VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    VARIABLE        shift and go to state 96

    forcondition                   shift and go to state 95

state 64

    (45) forStatement -> FOREACH LPAREN . forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE
    (46) forcondition -> . VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (47) forcondition -> . VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    VARIABLE        shift and go to state 96

    forcondition                   shift and go to state 97

state 65

    (12) asignacion -> VARIABLE EQUALS operaArit . SEMICOLON

    SEMICOLON       shift and go to state 98


state 66

    (8) asignacion_fgets -> VARIABLE EQUALS FGETS . LPAREN STDIN RPAREN SEMICOLON

    LPAREN          shift and go to state 99


state 67

    (90) array -> VARIABLE EQUALS LBRACKET . repiteValores RBRACKET SEMICOLON
    (93) array -> VARIABLE EQUALS LBRACKET . mapProduc RBRACKET SEMICOLON
    (94) map -> VARIABLE EQUALS LBRACKET . mapProduc RBRACKET SEMICOLON
    (123) repiteValores -> . valor COMMA repiteValores
    (124) repiteValores -> . valor
    (96) mapProduc -> . mapArrow
    (97) mapProduc -> . mapArrow COMMA mapProduc
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (98) mapArrow -> . valor ARROWMAP valor
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    repiteValores                  shift and go to state 100
    mapProduc                      shift and go to state 101
    valor                          shift and go to state 102
    mapArrow                       shift and go to state 103
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 68

    (91) array -> VARIABLE EQUALS ARRAY . LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> VARIABLE EQUALS ARRAY . LPAREN mapProduc RPAREN SEMICOLON
    (95) map -> VARIABLE EQUALS ARRAY . LPAREN mapProduc RPAREN SEMICOLON

    LPAREN          shift and go to state 104


state 69

    (125) operaArit -> valor .
    (126) operaArit -> valor . operador operaArit
    (127) operaArit -> valor . DOT valor
    (133) operador -> . PLUS
    (134) operador -> . MINUS
    (135) operador -> . TIMES
    (136) operador -> . DIVIDE
    (137) operador -> . MODULO

    SEMICOLON       reduce using rule 125 (operaArit -> valor .)
    COMMA           reduce using rule 125 (operaArit -> valor .)
    RPAREN          reduce using rule 125 (operaArit -> valor .)
    COLON           reduce using rule 125 (operaArit -> valor .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MODULO          shift and go to state 54

    operador                       shift and go to state 105

state 70

    (13) impresion -> ECHO imprimir SEMICOLON .

    VARIABLE        reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)
    ECHO            reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)
    PRINT           reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)
    INT             reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)
    FLOAT           reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)
    FUNCTION        reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)
    CLASS           reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)
    WHILE           reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)
    SWITCH          reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)
    IF              reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)
    FOR             reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)
    FOREACH         reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)
    $end            reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)
    RBRACE          reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)
    BREAK           reduce using rule 13 (impresion -> ECHO imprimir SEMICOLON .)


state 71

    (102) imprimir -> LPAREN repiteValores . RPAREN

    RPAREN          shift and go to state 107


state 72

    (103) imprimir -> LPAREN RPAREN .

    SEMICOLON       reduce using rule 103 (imprimir -> LPAREN RPAREN .)


state 73

    (123) repiteValores -> valor COMMA . repiteValores
    (123) repiteValores -> . valor COMMA repiteValores
    (124) repiteValores -> . valor
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    valor                          shift and go to state 37
    repiteValores                  shift and go to state 108
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 74

    (75) funcionAnonima -> VARIABLE EQUALS . FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    FUNCTION        shift and go to state 109


state 75

    (74) funcionParen -> ID LPAREN . parametros RPAREN
    (66) parametros -> . parametro
    (67) parametros -> . parametro COMMA parametros
    (68) parametros -> . empty
    (69) parametro -> . ID
    (70) parametro -> . dataType ID
    (71) parametro -> . ID EQUALS valor
    (72) parametro -> . dataType ID EQUALS valor
    (139) empty -> .
    (114) dataType -> . INTEGER
    (115) dataType -> . FLOATING
    (116) dataType -> . STRINGS
    (117) dataType -> . BOOLEAN
    (118) dataType -> . VOID

    ID              shift and go to state 110
    RPAREN          reduce using rule 139 (empty -> .)
    INTEGER         shift and go to state 115
    FLOATING        shift and go to state 116
    STRINGS         shift and go to state 117
    BOOLEAN         shift and go to state 118
    VOID            shift and go to state 119

    parametros                     shift and go to state 111
    parametro                      shift and go to state 112
    empty                          shift and go to state 113
    dataType                       shift and go to state 114

state 76

    (14) impresion -> PRINT imprimir SEMICOLON .

    VARIABLE        reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)
    ECHO            reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)
    PRINT           reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)
    INT             reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)
    FLOAT           reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)
    FUNCTION        reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)
    CLASS           reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)
    WHILE           reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)
    SWITCH          reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)
    IF              reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)
    FOR             reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)
    FOREACH         reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)
    $end            reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)
    RBRACE          reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)
    BREAK           reduce using rule 14 (impresion -> PRINT imprimir SEMICOLON .)


state 77

    (119) comparacion -> INT operador INT .

    VARIABLE        reduce using rule 119 (comparacion -> INT operador INT .)
    ECHO            reduce using rule 119 (comparacion -> INT operador INT .)
    PRINT           reduce using rule 119 (comparacion -> INT operador INT .)
    INT             reduce using rule 119 (comparacion -> INT operador INT .)
    FLOAT           reduce using rule 119 (comparacion -> INT operador INT .)
    FUNCTION        reduce using rule 119 (comparacion -> INT operador INT .)
    CLASS           reduce using rule 119 (comparacion -> INT operador INT .)
    WHILE           reduce using rule 119 (comparacion -> INT operador INT .)
    SWITCH          reduce using rule 119 (comparacion -> INT operador INT .)
    IF              reduce using rule 119 (comparacion -> INT operador INT .)
    FOR             reduce using rule 119 (comparacion -> INT operador INT .)
    FOREACH         reduce using rule 119 (comparacion -> INT operador INT .)
    $end            reduce using rule 119 (comparacion -> INT operador INT .)
    RBRACE          reduce using rule 119 (comparacion -> INT operador INT .)
    BREAK           reduce using rule 119 (comparacion -> INT operador INT .)


state 78

    (121) comparacion -> INT operador FLOAT .

    VARIABLE        reduce using rule 121 (comparacion -> INT operador FLOAT .)
    ECHO            reduce using rule 121 (comparacion -> INT operador FLOAT .)
    PRINT           reduce using rule 121 (comparacion -> INT operador FLOAT .)
    INT             reduce using rule 121 (comparacion -> INT operador FLOAT .)
    FLOAT           reduce using rule 121 (comparacion -> INT operador FLOAT .)
    FUNCTION        reduce using rule 121 (comparacion -> INT operador FLOAT .)
    CLASS           reduce using rule 121 (comparacion -> INT operador FLOAT .)
    WHILE           reduce using rule 121 (comparacion -> INT operador FLOAT .)
    SWITCH          reduce using rule 121 (comparacion -> INT operador FLOAT .)
    IF              reduce using rule 121 (comparacion -> INT operador FLOAT .)
    FOR             reduce using rule 121 (comparacion -> INT operador FLOAT .)
    FOREACH         reduce using rule 121 (comparacion -> INT operador FLOAT .)
    $end            reduce using rule 121 (comparacion -> INT operador FLOAT .)
    RBRACE          reduce using rule 121 (comparacion -> INT operador FLOAT .)
    BREAK           reduce using rule 121 (comparacion -> INT operador FLOAT .)


state 79

    (120) comparacion -> FLOAT operador FLOAT .

    VARIABLE        reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)
    ECHO            reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)
    PRINT           reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)
    INT             reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)
    FLOAT           reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)
    FUNCTION        reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)
    CLASS           reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)
    WHILE           reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)
    SWITCH          reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)
    IF              reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)
    FOR             reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)
    FOREACH         reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)
    $end            reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)
    RBRACE          reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)
    BREAK           reduce using rule 120 (comparacion -> FLOAT operador FLOAT .)


state 80

    (122) comparacion -> FLOAT operador INT .

    VARIABLE        reduce using rule 122 (comparacion -> FLOAT operador INT .)
    ECHO            reduce using rule 122 (comparacion -> FLOAT operador INT .)
    PRINT           reduce using rule 122 (comparacion -> FLOAT operador INT .)
    INT             reduce using rule 122 (comparacion -> FLOAT operador INT .)
    FLOAT           reduce using rule 122 (comparacion -> FLOAT operador INT .)
    FUNCTION        reduce using rule 122 (comparacion -> FLOAT operador INT .)
    CLASS           reduce using rule 122 (comparacion -> FLOAT operador INT .)
    WHILE           reduce using rule 122 (comparacion -> FLOAT operador INT .)
    SWITCH          reduce using rule 122 (comparacion -> FLOAT operador INT .)
    IF              reduce using rule 122 (comparacion -> FLOAT operador INT .)
    FOR             reduce using rule 122 (comparacion -> FLOAT operador INT .)
    FOREACH         reduce using rule 122 (comparacion -> FLOAT operador INT .)
    $end            reduce using rule 122 (comparacion -> FLOAT operador INT .)
    RBRACE          reduce using rule 122 (comparacion -> FLOAT operador INT .)
    BREAK           reduce using rule 122 (comparacion -> FLOAT operador INT .)


state 81

    (62) funcionDeclarate -> FUNCTION ID LPAREN . parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> FUNCTION ID LPAREN . parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (66) parametros -> . parametro
    (67) parametros -> . parametro COMMA parametros
    (68) parametros -> . empty
    (69) parametro -> . ID
    (70) parametro -> . dataType ID
    (71) parametro -> . ID EQUALS valor
    (72) parametro -> . dataType ID EQUALS valor
    (139) empty -> .
    (114) dataType -> . INTEGER
    (115) dataType -> . FLOATING
    (116) dataType -> . STRINGS
    (117) dataType -> . BOOLEAN
    (118) dataType -> . VOID

    ID              shift and go to state 110
    RPAREN          reduce using rule 139 (empty -> .)
    INTEGER         shift and go to state 115
    FLOATING        shift and go to state 116
    STRINGS         shift and go to state 117
    BOOLEAN         shift and go to state 118
    VOID            shift and go to state 119

    parametros                     shift and go to state 120
    dataType                       shift and go to state 114
    parametro                      shift and go to state 112
    empty                          shift and go to state 113

state 82

    (76) classDeclarate -> CLASS ID LBRACE . classBody RBRACE
    (78) classBody -> . classMember classBody
    (79) classBody -> . empty
    (80) classMember -> . dataType VARIABLE SEMICOLON
    (81) classMember -> . dataType FUNCTION ID LPAREN parametros RPAREN brace
    (82) classMember -> . objectInstantiation
    (139) empty -> .
    (114) dataType -> . INTEGER
    (115) dataType -> . FLOATING
    (116) dataType -> . STRINGS
    (117) dataType -> . BOOLEAN
    (118) dataType -> . VOID
    (85) objectInstantiation -> . NEW ID LPAREN argumentos RPAREN
    (86) objectInstantiation -> . NEW ID LPAREN RPAREN

    RBRACE          reduce using rule 139 (empty -> .)
    INTEGER         shift and go to state 115
    FLOATING        shift and go to state 116
    STRINGS         shift and go to state 117
    BOOLEAN         shift and go to state 118
    VOID            shift and go to state 119
    NEW             shift and go to state 126

    classBody                      shift and go to state 121
    classMember                    shift and go to state 122
    empty                          shift and go to state 123
    dataType                       shift and go to state 124
    objectInstantiation            shift and go to state 125

state 83

    (77) classDeclarate -> CLASS ID EXTENDS . ID LBRACE classBody RBRACE

    ID              shift and go to state 127


state 84

    (23) if -> statementif ELSE body .

    VARIABLE        reduce using rule 23 (if -> statementif ELSE body .)
    ECHO            reduce using rule 23 (if -> statementif ELSE body .)
    PRINT           reduce using rule 23 (if -> statementif ELSE body .)
    INT             reduce using rule 23 (if -> statementif ELSE body .)
    FLOAT           reduce using rule 23 (if -> statementif ELSE body .)
    FUNCTION        reduce using rule 23 (if -> statementif ELSE body .)
    CLASS           reduce using rule 23 (if -> statementif ELSE body .)
    WHILE           reduce using rule 23 (if -> statementif ELSE body .)
    SWITCH          reduce using rule 23 (if -> statementif ELSE body .)
    IF              reduce using rule 23 (if -> statementif ELSE body .)
    FOR             reduce using rule 23 (if -> statementif ELSE body .)
    FOREACH         reduce using rule 23 (if -> statementif ELSE body .)
    $end            reduce using rule 23 (if -> statementif ELSE body .)
    RBRACE          reduce using rule 23 (if -> statementif ELSE body .)
    BREAK           reduce using rule 23 (if -> statementif ELSE body .)


state 85

    (24) if -> statementif ELSE if .
    (19) controlStructure -> if .

  ! reduce/reduce conflict for VARIABLE resolved using rule 19 (controlStructure -> if .)
  ! reduce/reduce conflict for ECHO resolved using rule 19 (controlStructure -> if .)
  ! reduce/reduce conflict for PRINT resolved using rule 19 (controlStructure -> if .)
  ! reduce/reduce conflict for INT resolved using rule 19 (controlStructure -> if .)
  ! reduce/reduce conflict for FLOAT resolved using rule 19 (controlStructure -> if .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 19 (controlStructure -> if .)
  ! reduce/reduce conflict for CLASS resolved using rule 19 (controlStructure -> if .)
  ! reduce/reduce conflict for WHILE resolved using rule 19 (controlStructure -> if .)
  ! reduce/reduce conflict for SWITCH resolved using rule 19 (controlStructure -> if .)
  ! reduce/reduce conflict for IF resolved using rule 19 (controlStructure -> if .)
  ! reduce/reduce conflict for FOR resolved using rule 19 (controlStructure -> if .)
  ! reduce/reduce conflict for FOREACH resolved using rule 19 (controlStructure -> if .)
  ! reduce/reduce conflict for $end resolved using rule 19 (controlStructure -> if .)
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (controlStructure -> if .)
  ! reduce/reduce conflict for BREAK resolved using rule 19 (controlStructure -> if .)
    VARIABLE        reduce using rule 19 (controlStructure -> if .)
    ECHO            reduce using rule 19 (controlStructure -> if .)
    PRINT           reduce using rule 19 (controlStructure -> if .)
    INT             reduce using rule 19 (controlStructure -> if .)
    FLOAT           reduce using rule 19 (controlStructure -> if .)
    FUNCTION        reduce using rule 19 (controlStructure -> if .)
    CLASS           reduce using rule 19 (controlStructure -> if .)
    WHILE           reduce using rule 19 (controlStructure -> if .)
    SWITCH          reduce using rule 19 (controlStructure -> if .)
    IF              reduce using rule 19 (controlStructure -> if .)
    FOR             reduce using rule 19 (controlStructure -> if .)
    FOREACH         reduce using rule 19 (controlStructure -> if .)
    $end            reduce using rule 19 (controlStructure -> if .)
    RBRACE          reduce using rule 19 (controlStructure -> if .)
    BREAK           reduce using rule 19 (controlStructure -> if .)

  ! VARIABLE        [ reduce using rule 24 (if -> statementif ELSE if .) ]
  ! ECHO            [ reduce using rule 24 (if -> statementif ELSE if .) ]
  ! PRINT           [ reduce using rule 24 (if -> statementif ELSE if .) ]
  ! INT             [ reduce using rule 24 (if -> statementif ELSE if .) ]
  ! FLOAT           [ reduce using rule 24 (if -> statementif ELSE if .) ]
  ! FUNCTION        [ reduce using rule 24 (if -> statementif ELSE if .) ]
  ! CLASS           [ reduce using rule 24 (if -> statementif ELSE if .) ]
  ! WHILE           [ reduce using rule 24 (if -> statementif ELSE if .) ]
  ! SWITCH          [ reduce using rule 24 (if -> statementif ELSE if .) ]
  ! IF              [ reduce using rule 24 (if -> statementif ELSE if .) ]
  ! FOR             [ reduce using rule 24 (if -> statementif ELSE if .) ]
  ! FOREACH         [ reduce using rule 24 (if -> statementif ELSE if .) ]
  ! $end            [ reduce using rule 24 (if -> statementif ELSE if .) ]
  ! RBRACE          [ reduce using rule 24 (if -> statementif ELSE if .) ]
  ! BREAK           [ reduce using rule 24 (if -> statementif ELSE if .) ]


state 86

    (99) body -> sentencia .
    (100) body -> sentencia . sentencias
    (9) sentencias -> . sentencia
    (10) sentencias -> . sentencia sentencias
    (11) sentencias -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) sentencia -> . asignacion_fgets
    (139) empty -> .
    (12) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (13) impresion -> . ECHO imprimir SEMICOLON
    (14) impresion -> . PRINT imprimir SEMICOLON
    (119) comparacion -> . INT operador INT
    (120) comparacion -> . FLOAT operador FLOAT
    (121) comparacion -> . INT operador FLOAT
    (122) comparacion -> . FLOAT operador INT
    (15) estructurasProgram -> . controlStructure
    (16) estructurasProgram -> . dataStructure
    (17) estructurasProgram -> . funcionDeclarate
    (18) estructurasProgram -> . classDeclarate
    (8) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (19) controlStructure -> . if
    (20) controlStructure -> . for
    (21) controlStructure -> . while
    (22) controlStructure -> . switch
    (60) dataStructure -> . array
    (61) dataStructure -> . map
    (62) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (76) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (77) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (43) for -> . forStatement
    (48) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (50) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (90) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (44) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (45) forStatement -> . FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

  ! reduce/reduce conflict for VARIABLE resolved using rule 99 (body -> sentencia .)
  ! reduce/reduce conflict for ECHO resolved using rule 99 (body -> sentencia .)
  ! reduce/reduce conflict for PRINT resolved using rule 99 (body -> sentencia .)
  ! reduce/reduce conflict for INT resolved using rule 99 (body -> sentencia .)
  ! reduce/reduce conflict for FLOAT resolved using rule 99 (body -> sentencia .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 99 (body -> sentencia .)
  ! reduce/reduce conflict for CLASS resolved using rule 99 (body -> sentencia .)
  ! reduce/reduce conflict for WHILE resolved using rule 99 (body -> sentencia .)
  ! reduce/reduce conflict for SWITCH resolved using rule 99 (body -> sentencia .)
  ! reduce/reduce conflict for IF resolved using rule 99 (body -> sentencia .)
  ! reduce/reduce conflict for FOR resolved using rule 99 (body -> sentencia .)
  ! reduce/reduce conflict for FOREACH resolved using rule 99 (body -> sentencia .)
  ! reduce/reduce conflict for $end resolved using rule 99 (body -> sentencia .)
  ! reduce/reduce conflict for RBRACE resolved using rule 99 (body -> sentencia .)
  ! reduce/reduce conflict for BREAK resolved using rule 99 (body -> sentencia .)
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for FOREACH resolved as shift
    $end            reduce using rule 99 (body -> sentencia .)
    RBRACE          reduce using rule 99 (body -> sentencia .)
    BREAK           reduce using rule 99 (body -> sentencia .)
    VARIABLE        shift and go to state 8
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    FUNCTION        shift and go to state 23
    CLASS           shift and go to state 24
    WHILE           shift and go to state 27
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    FOREACH         shift and go to state 31

  ! VARIABLE        [ reduce using rule 99 (body -> sentencia .) ]
  ! ECHO            [ reduce using rule 99 (body -> sentencia .) ]
  ! PRINT           [ reduce using rule 99 (body -> sentencia .) ]
  ! INT             [ reduce using rule 99 (body -> sentencia .) ]
  ! FLOAT           [ reduce using rule 99 (body -> sentencia .) ]
  ! FUNCTION        [ reduce using rule 99 (body -> sentencia .) ]
  ! CLASS           [ reduce using rule 99 (body -> sentencia .) ]
  ! WHILE           [ reduce using rule 99 (body -> sentencia .) ]
  ! SWITCH          [ reduce using rule 99 (body -> sentencia .) ]
  ! IF              [ reduce using rule 99 (body -> sentencia .) ]
  ! FOR             [ reduce using rule 99 (body -> sentencia .) ]
  ! FOREACH         [ reduce using rule 99 (body -> sentencia .) ]
  ! VARIABLE        [ reduce using rule 139 (empty -> .) ]
  ! ECHO            [ reduce using rule 139 (empty -> .) ]
  ! PRINT           [ reduce using rule 139 (empty -> .) ]
  ! INT             [ reduce using rule 139 (empty -> .) ]
  ! FLOAT           [ reduce using rule 139 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 139 (empty -> .) ]
  ! CLASS           [ reduce using rule 139 (empty -> .) ]
  ! WHILE           [ reduce using rule 139 (empty -> .) ]
  ! SWITCH          [ reduce using rule 139 (empty -> .) ]
  ! IF              [ reduce using rule 139 (empty -> .) ]
  ! FOR             [ reduce using rule 139 (empty -> .) ]
  ! FOREACH         [ reduce using rule 139 (empty -> .) ]
  ! $end            [ reduce using rule 139 (empty -> .) ]
  ! RBRACE          [ reduce using rule 139 (empty -> .) ]
  ! BREAK           [ reduce using rule 139 (empty -> .) ]

    sentencia                      shift and go to state 128
    sentencias                     shift and go to state 129
    empty                          shift and go to state 130
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    asignacion_fgets               shift and go to state 7
    controlStructure               shift and go to state 13
    dataStructure                  shift and go to state 14
    funcionDeclarate               shift and go to state 15
    classDeclarate                 shift and go to state 16
    if                             shift and go to state 17
    for                            shift and go to state 18
    while                          shift and go to state 19
    switch                         shift and go to state 20
    array                          shift and go to state 21
    map                            shift and go to state 22
    statementif                    shift and go to state 25
    forStatement                   shift and go to state 26

state 87

    (101) body -> empty .

    VARIABLE        reduce using rule 101 (body -> empty .)
    ECHO            reduce using rule 101 (body -> empty .)
    PRINT           reduce using rule 101 (body -> empty .)
    INT             reduce using rule 101 (body -> empty .)
    FLOAT           reduce using rule 101 (body -> empty .)
    FUNCTION        reduce using rule 101 (body -> empty .)
    CLASS           reduce using rule 101 (body -> empty .)
    WHILE           reduce using rule 101 (body -> empty .)
    SWITCH          reduce using rule 101 (body -> empty .)
    IF              reduce using rule 101 (body -> empty .)
    FOR             reduce using rule 101 (body -> empty .)
    FOREACH         reduce using rule 101 (body -> empty .)
    $end            reduce using rule 101 (body -> empty .)
    RBRACE          reduce using rule 101 (body -> empty .)
    BREAK           reduce using rule 101 (body -> empty .)


state 88

    (25) if -> statementif ELSEIF if .

    VARIABLE        reduce using rule 25 (if -> statementif ELSEIF if .)
    ECHO            reduce using rule 25 (if -> statementif ELSEIF if .)
    PRINT           reduce using rule 25 (if -> statementif ELSEIF if .)
    INT             reduce using rule 25 (if -> statementif ELSEIF if .)
    FLOAT           reduce using rule 25 (if -> statementif ELSEIF if .)
    FUNCTION        reduce using rule 25 (if -> statementif ELSEIF if .)
    CLASS           reduce using rule 25 (if -> statementif ELSEIF if .)
    WHILE           reduce using rule 25 (if -> statementif ELSEIF if .)
    SWITCH          reduce using rule 25 (if -> statementif ELSEIF if .)
    IF              reduce using rule 25 (if -> statementif ELSEIF if .)
    FOR             reduce using rule 25 (if -> statementif ELSEIF if .)
    FOREACH         reduce using rule 25 (if -> statementif ELSEIF if .)
    $end            reduce using rule 25 (if -> statementif ELSEIF if .)
    RBRACE          reduce using rule 25 (if -> statementif ELSEIF if .)
    BREAK           reduce using rule 25 (if -> statementif ELSEIF if .)


state 89

    (31) condition -> LPAREN . conditionProdu RPAREN
    (28) conditionProdu -> . condition
    (29) conditionProdu -> . condition opLogic condition conditionProdu
    (30) condition -> . valor opSymbol valor
    (31) condition -> . LPAREN conditionProdu RPAREN
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 89
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    conditionProdu                 shift and go to state 131
    condition                      shift and go to state 94
    valor                          shift and go to state 91
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 90

    (48) while -> WHILE LPAREN condition . RPAREN LBRACE body RBRACE
    (49) while -> WHILE LPAREN condition . RPAREN LBRACE RBRACE

    RPAREN          shift and go to state 132


state 91

    (30) condition -> valor . opSymbol valor
    (32) opSymbol -> . EQ
    (33) opSymbol -> . NEQ
    (34) opSymbol -> . STRICTEQ
    (35) opSymbol -> . STRICTNEQ
    (36) opSymbol -> . LT
    (37) opSymbol -> . GT
    (38) opSymbol -> . LEQ
    (39) opSymbol -> . GEQ

    EQ              shift and go to state 134
    NEQ             shift and go to state 135
    STRICTEQ        shift and go to state 136
    STRICTNEQ       shift and go to state 137
    LT              shift and go to state 138
    GT              shift and go to state 139
    LEQ             shift and go to state 140
    GEQ             shift and go to state 141

    opSymbol                       shift and go to state 133

state 92

    (50) switch -> SWITCH LPAREN condition . RPAREN LBRACE caseLists RBRACE
    (51) switch -> SWITCH LPAREN condition . RPAREN LBRACE RBRACE

    RPAREN          shift and go to state 142


state 93

    (27) statementif -> IF LPAREN conditionProdu . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 143


state 94

    (28) conditionProdu -> condition .
    (29) conditionProdu -> condition . opLogic condition conditionProdu
    (40) opLogic -> . AND
    (41) opLogic -> . OR
    (42) opLogic -> . NOT

    RPAREN          reduce using rule 28 (conditionProdu -> condition .)
    QUESTION        reduce using rule 28 (conditionProdu -> condition .)
    COMMA           reduce using rule 28 (conditionProdu -> condition .)
    SEMICOLON       reduce using rule 28 (conditionProdu -> condition .)
    COLON           reduce using rule 28 (conditionProdu -> condition .)
    AND             shift and go to state 145
    OR              shift and go to state 146
    NOT             shift and go to state 147

    opLogic                        shift and go to state 144

state 95

    (44) forStatement -> FOR LPAREN forcondition . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 148


state 96

    (46) forcondition -> VARIABLE . EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (47) forcondition -> VARIABLE . EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    EQUALS          shift and go to state 149


state 97

    (45) forStatement -> FOREACH LPAREN forcondition . RPAREN LBRACE body BREAK SEMICOLON RBRACE

    RPAREN          shift and go to state 150


state 98

    (12) asignacion -> VARIABLE EQUALS operaArit SEMICOLON .

    VARIABLE        reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    ECHO            reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    PRINT           reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    INT             reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    FLOAT           reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    FUNCTION        reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    CLASS           reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    WHILE           reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    SWITCH          reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    IF              reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    FOR             reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    FOREACH         reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    $end            reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    RBRACE          reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    BREAK           reduce using rule 12 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)


state 99

    (8) asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN . STDIN RPAREN SEMICOLON

    STDIN           shift and go to state 151


state 100

    (90) array -> VARIABLE EQUALS LBRACKET repiteValores . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 152


state 101

    (93) array -> VARIABLE EQUALS LBRACKET mapProduc . RBRACKET SEMICOLON
    (94) map -> VARIABLE EQUALS LBRACKET mapProduc . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 153


state 102

    (123) repiteValores -> valor . COMMA repiteValores
    (124) repiteValores -> valor .
    (98) mapArrow -> valor . ARROWMAP valor

    COMMA           shift and go to state 73
    RBRACKET        reduce using rule 124 (repiteValores -> valor .)
    RPAREN          reduce using rule 124 (repiteValores -> valor .)
    ARROWMAP        shift and go to state 154


state 103

    (96) mapProduc -> mapArrow .
    (97) mapProduc -> mapArrow . COMMA mapProduc

    RBRACKET        reduce using rule 96 (mapProduc -> mapArrow .)
    RPAREN          reduce using rule 96 (mapProduc -> mapArrow .)
    COMMA           shift and go to state 155


state 104

    (91) array -> VARIABLE EQUALS ARRAY LPAREN . repiteValores RPAREN SEMICOLON
    (92) array -> VARIABLE EQUALS ARRAY LPAREN . mapProduc RPAREN SEMICOLON
    (95) map -> VARIABLE EQUALS ARRAY LPAREN . mapProduc RPAREN SEMICOLON
    (123) repiteValores -> . valor COMMA repiteValores
    (124) repiteValores -> . valor
    (96) mapProduc -> . mapArrow
    (97) mapProduc -> . mapArrow COMMA mapProduc
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (98) mapArrow -> . valor ARROWMAP valor
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    repiteValores                  shift and go to state 156
    mapProduc                      shift and go to state 157
    valor                          shift and go to state 102
    mapArrow                       shift and go to state 103
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 105

    (126) operaArit -> valor operador . operaArit
    (125) operaArit -> . valor
    (126) operaArit -> . valor operador operaArit
    (127) operaArit -> . valor DOT valor
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    valor                          shift and go to state 69
    operaArit                      shift and go to state 158
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 106

    (127) operaArit -> valor DOT . valor
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    valor                          shift and go to state 159
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 107

    (102) imprimir -> LPAREN repiteValores RPAREN .

    SEMICOLON       reduce using rule 102 (imprimir -> LPAREN repiteValores RPAREN .)


state 108

    (123) repiteValores -> valor COMMA repiteValores .

    SEMICOLON       reduce using rule 123 (repiteValores -> valor COMMA repiteValores .)
    RPAREN          reduce using rule 123 (repiteValores -> valor COMMA repiteValores .)
    RBRACKET        reduce using rule 123 (repiteValores -> valor COMMA repiteValores .)


state 109

    (75) funcionAnonima -> VARIABLE EQUALS FUNCTION . LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 160


state 110

    (69) parametro -> ID .
    (71) parametro -> ID . EQUALS valor

    COMMA           reduce using rule 69 (parametro -> ID .)
    RPAREN          reduce using rule 69 (parametro -> ID .)
    EQUALS          shift and go to state 161


state 111

    (74) funcionParen -> ID LPAREN parametros . RPAREN

    RPAREN          shift and go to state 162


state 112

    (66) parametros -> parametro .
    (67) parametros -> parametro . COMMA parametros

    RPAREN          reduce using rule 66 (parametros -> parametro .)
    COMMA           shift and go to state 163


state 113

    (68) parametros -> empty .

    RPAREN          reduce using rule 68 (parametros -> empty .)


state 114

    (70) parametro -> dataType . ID
    (72) parametro -> dataType . ID EQUALS valor

    ID              shift and go to state 164


state 115

    (114) dataType -> INTEGER .

    ID              reduce using rule 114 (dataType -> INTEGER .)
    VARIABLE        reduce using rule 114 (dataType -> INTEGER .)
    FUNCTION        reduce using rule 114 (dataType -> INTEGER .)
    LBRACE          reduce using rule 114 (dataType -> INTEGER .)


state 116

    (115) dataType -> FLOATING .

    ID              reduce using rule 115 (dataType -> FLOATING .)
    VARIABLE        reduce using rule 115 (dataType -> FLOATING .)
    FUNCTION        reduce using rule 115 (dataType -> FLOATING .)
    LBRACE          reduce using rule 115 (dataType -> FLOATING .)


state 117

    (116) dataType -> STRINGS .

    ID              reduce using rule 116 (dataType -> STRINGS .)
    VARIABLE        reduce using rule 116 (dataType -> STRINGS .)
    FUNCTION        reduce using rule 116 (dataType -> STRINGS .)
    LBRACE          reduce using rule 116 (dataType -> STRINGS .)


state 118

    (117) dataType -> BOOLEAN .

    ID              reduce using rule 117 (dataType -> BOOLEAN .)
    VARIABLE        reduce using rule 117 (dataType -> BOOLEAN .)
    FUNCTION        reduce using rule 117 (dataType -> BOOLEAN .)
    LBRACE          reduce using rule 117 (dataType -> BOOLEAN .)


state 119

    (118) dataType -> VOID .

    ID              reduce using rule 118 (dataType -> VOID .)
    VARIABLE        reduce using rule 118 (dataType -> VOID .)
    FUNCTION        reduce using rule 118 (dataType -> VOID .)
    LBRACE          reduce using rule 118 (dataType -> VOID .)


state 120

    (62) funcionDeclarate -> FUNCTION ID LPAREN parametros . RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> FUNCTION ID LPAREN parametros . RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE

    RPAREN          shift and go to state 165


state 121

    (76) classDeclarate -> CLASS ID LBRACE classBody . RBRACE

    RBRACE          shift and go to state 166


state 122

    (78) classBody -> classMember . classBody
    (78) classBody -> . classMember classBody
    (79) classBody -> . empty
    (80) classMember -> . dataType VARIABLE SEMICOLON
    (81) classMember -> . dataType FUNCTION ID LPAREN parametros RPAREN brace
    (82) classMember -> . objectInstantiation
    (139) empty -> .
    (114) dataType -> . INTEGER
    (115) dataType -> . FLOATING
    (116) dataType -> . STRINGS
    (117) dataType -> . BOOLEAN
    (118) dataType -> . VOID
    (85) objectInstantiation -> . NEW ID LPAREN argumentos RPAREN
    (86) objectInstantiation -> . NEW ID LPAREN RPAREN

    RBRACE          reduce using rule 139 (empty -> .)
    INTEGER         shift and go to state 115
    FLOATING        shift and go to state 116
    STRINGS         shift and go to state 117
    BOOLEAN         shift and go to state 118
    VOID            shift and go to state 119
    NEW             shift and go to state 126

    classMember                    shift and go to state 122
    classBody                      shift and go to state 167
    empty                          shift and go to state 123
    dataType                       shift and go to state 124
    objectInstantiation            shift and go to state 125

state 123

    (79) classBody -> empty .

    RBRACE          reduce using rule 79 (classBody -> empty .)


state 124

    (80) classMember -> dataType . VARIABLE SEMICOLON
    (81) classMember -> dataType . FUNCTION ID LPAREN parametros RPAREN brace

    VARIABLE        shift and go to state 168
    FUNCTION        shift and go to state 169


state 125

    (82) classMember -> objectInstantiation .

    INTEGER         reduce using rule 82 (classMember -> objectInstantiation .)
    FLOATING        reduce using rule 82 (classMember -> objectInstantiation .)
    STRINGS         reduce using rule 82 (classMember -> objectInstantiation .)
    BOOLEAN         reduce using rule 82 (classMember -> objectInstantiation .)
    VOID            reduce using rule 82 (classMember -> objectInstantiation .)
    NEW             reduce using rule 82 (classMember -> objectInstantiation .)
    RBRACE          reduce using rule 82 (classMember -> objectInstantiation .)


state 126

    (85) objectInstantiation -> NEW . ID LPAREN argumentos RPAREN
    (86) objectInstantiation -> NEW . ID LPAREN RPAREN

    ID              shift and go to state 170


state 127

    (77) classDeclarate -> CLASS ID EXTENDS ID . LBRACE classBody RBRACE

    LBRACE          shift and go to state 171


state 128

    (9) sentencias -> sentencia .
    (10) sentencias -> sentencia . sentencias
    (9) sentencias -> . sentencia
    (10) sentencias -> . sentencia sentencias
    (11) sentencias -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) sentencia -> . asignacion_fgets
    (139) empty -> .
    (12) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (13) impresion -> . ECHO imprimir SEMICOLON
    (14) impresion -> . PRINT imprimir SEMICOLON
    (119) comparacion -> . INT operador INT
    (120) comparacion -> . FLOAT operador FLOAT
    (121) comparacion -> . INT operador FLOAT
    (122) comparacion -> . FLOAT operador INT
    (15) estructurasProgram -> . controlStructure
    (16) estructurasProgram -> . dataStructure
    (17) estructurasProgram -> . funcionDeclarate
    (18) estructurasProgram -> . classDeclarate
    (8) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (19) controlStructure -> . if
    (20) controlStructure -> . for
    (21) controlStructure -> . while
    (22) controlStructure -> . switch
    (60) dataStructure -> . array
    (61) dataStructure -> . map
    (62) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (76) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (77) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (43) for -> . forStatement
    (48) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (50) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (90) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (44) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (45) forStatement -> . FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

  ! reduce/reduce conflict for VARIABLE resolved using rule 9 (sentencias -> sentencia .)
  ! reduce/reduce conflict for ECHO resolved using rule 9 (sentencias -> sentencia .)
  ! reduce/reduce conflict for PRINT resolved using rule 9 (sentencias -> sentencia .)
  ! reduce/reduce conflict for INT resolved using rule 9 (sentencias -> sentencia .)
  ! reduce/reduce conflict for FLOAT resolved using rule 9 (sentencias -> sentencia .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 9 (sentencias -> sentencia .)
  ! reduce/reduce conflict for CLASS resolved using rule 9 (sentencias -> sentencia .)
  ! reduce/reduce conflict for WHILE resolved using rule 9 (sentencias -> sentencia .)
  ! reduce/reduce conflict for SWITCH resolved using rule 9 (sentencias -> sentencia .)
  ! reduce/reduce conflict for IF resolved using rule 9 (sentencias -> sentencia .)
  ! reduce/reduce conflict for FOR resolved using rule 9 (sentencias -> sentencia .)
  ! reduce/reduce conflict for FOREACH resolved using rule 9 (sentencias -> sentencia .)
  ! reduce/reduce conflict for $end resolved using rule 9 (sentencias -> sentencia .)
  ! reduce/reduce conflict for RBRACE resolved using rule 9 (sentencias -> sentencia .)
  ! reduce/reduce conflict for BREAK resolved using rule 9 (sentencias -> sentencia .)
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for FOREACH resolved as shift
    $end            reduce using rule 9 (sentencias -> sentencia .)
    RBRACE          reduce using rule 9 (sentencias -> sentencia .)
    BREAK           reduce using rule 9 (sentencias -> sentencia .)
    VARIABLE        shift and go to state 8
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    FUNCTION        shift and go to state 23
    CLASS           shift and go to state 24
    WHILE           shift and go to state 27
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    FOREACH         shift and go to state 31

  ! VARIABLE        [ reduce using rule 9 (sentencias -> sentencia .) ]
  ! ECHO            [ reduce using rule 9 (sentencias -> sentencia .) ]
  ! PRINT           [ reduce using rule 9 (sentencias -> sentencia .) ]
  ! INT             [ reduce using rule 9 (sentencias -> sentencia .) ]
  ! FLOAT           [ reduce using rule 9 (sentencias -> sentencia .) ]
  ! FUNCTION        [ reduce using rule 9 (sentencias -> sentencia .) ]
  ! CLASS           [ reduce using rule 9 (sentencias -> sentencia .) ]
  ! WHILE           [ reduce using rule 9 (sentencias -> sentencia .) ]
  ! SWITCH          [ reduce using rule 9 (sentencias -> sentencia .) ]
  ! IF              [ reduce using rule 9 (sentencias -> sentencia .) ]
  ! FOR             [ reduce using rule 9 (sentencias -> sentencia .) ]
  ! FOREACH         [ reduce using rule 9 (sentencias -> sentencia .) ]
  ! VARIABLE        [ reduce using rule 139 (empty -> .) ]
  ! ECHO            [ reduce using rule 139 (empty -> .) ]
  ! PRINT           [ reduce using rule 139 (empty -> .) ]
  ! INT             [ reduce using rule 139 (empty -> .) ]
  ! FLOAT           [ reduce using rule 139 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 139 (empty -> .) ]
  ! CLASS           [ reduce using rule 139 (empty -> .) ]
  ! WHILE           [ reduce using rule 139 (empty -> .) ]
  ! SWITCH          [ reduce using rule 139 (empty -> .) ]
  ! IF              [ reduce using rule 139 (empty -> .) ]
  ! FOR             [ reduce using rule 139 (empty -> .) ]
  ! FOREACH         [ reduce using rule 139 (empty -> .) ]
  ! $end            [ reduce using rule 139 (empty -> .) ]
  ! RBRACE          [ reduce using rule 139 (empty -> .) ]
  ! BREAK           [ reduce using rule 139 (empty -> .) ]

    sentencia                      shift and go to state 128
    sentencias                     shift and go to state 172
    empty                          shift and go to state 130
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    asignacion_fgets               shift and go to state 7
    controlStructure               shift and go to state 13
    dataStructure                  shift and go to state 14
    funcionDeclarate               shift and go to state 15
    classDeclarate                 shift and go to state 16
    if                             shift and go to state 17
    for                            shift and go to state 18
    while                          shift and go to state 19
    switch                         shift and go to state 20
    array                          shift and go to state 21
    map                            shift and go to state 22
    statementif                    shift and go to state 25
    forStatement                   shift and go to state 26

state 129

    (100) body -> sentencia sentencias .

    VARIABLE        reduce using rule 100 (body -> sentencia sentencias .)
    ECHO            reduce using rule 100 (body -> sentencia sentencias .)
    PRINT           reduce using rule 100 (body -> sentencia sentencias .)
    INT             reduce using rule 100 (body -> sentencia sentencias .)
    FLOAT           reduce using rule 100 (body -> sentencia sentencias .)
    FUNCTION        reduce using rule 100 (body -> sentencia sentencias .)
    CLASS           reduce using rule 100 (body -> sentencia sentencias .)
    WHILE           reduce using rule 100 (body -> sentencia sentencias .)
    SWITCH          reduce using rule 100 (body -> sentencia sentencias .)
    IF              reduce using rule 100 (body -> sentencia sentencias .)
    FOR             reduce using rule 100 (body -> sentencia sentencias .)
    FOREACH         reduce using rule 100 (body -> sentencia sentencias .)
    $end            reduce using rule 100 (body -> sentencia sentencias .)
    RBRACE          reduce using rule 100 (body -> sentencia sentencias .)
    BREAK           reduce using rule 100 (body -> sentencia sentencias .)


state 130

    (11) sentencias -> empty .

    VARIABLE        reduce using rule 11 (sentencias -> empty .)
    ECHO            reduce using rule 11 (sentencias -> empty .)
    PRINT           reduce using rule 11 (sentencias -> empty .)
    INT             reduce using rule 11 (sentencias -> empty .)
    FLOAT           reduce using rule 11 (sentencias -> empty .)
    FUNCTION        reduce using rule 11 (sentencias -> empty .)
    CLASS           reduce using rule 11 (sentencias -> empty .)
    WHILE           reduce using rule 11 (sentencias -> empty .)
    SWITCH          reduce using rule 11 (sentencias -> empty .)
    IF              reduce using rule 11 (sentencias -> empty .)
    FOR             reduce using rule 11 (sentencias -> empty .)
    FOREACH         reduce using rule 11 (sentencias -> empty .)
    $end            reduce using rule 11 (sentencias -> empty .)
    RBRACE          reduce using rule 11 (sentencias -> empty .)
    BREAK           reduce using rule 11 (sentencias -> empty .)


state 131

    (31) condition -> LPAREN conditionProdu . RPAREN

    RPAREN          shift and go to state 173


state 132

    (48) while -> WHILE LPAREN condition RPAREN . LBRACE body RBRACE
    (49) while -> WHILE LPAREN condition RPAREN . LBRACE RBRACE

    LBRACE          shift and go to state 174


state 133

    (30) condition -> valor opSymbol . valor
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    valor                          shift and go to state 175
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 134

    (32) opSymbol -> EQ .

    INT             reduce using rule 32 (opSymbol -> EQ .)
    FLOAT           reduce using rule 32 (opSymbol -> EQ .)
    VARIABLE        reduce using rule 32 (opSymbol -> EQ .)
    STRING          reduce using rule 32 (opSymbol -> EQ .)
    TRUE            reduce using rule 32 (opSymbol -> EQ .)
    FALSE           reduce using rule 32 (opSymbol -> EQ .)
    THIS            reduce using rule 32 (opSymbol -> EQ .)
    ID              reduce using rule 32 (opSymbol -> EQ .)


state 135

    (33) opSymbol -> NEQ .

    INT             reduce using rule 33 (opSymbol -> NEQ .)
    FLOAT           reduce using rule 33 (opSymbol -> NEQ .)
    VARIABLE        reduce using rule 33 (opSymbol -> NEQ .)
    STRING          reduce using rule 33 (opSymbol -> NEQ .)
    TRUE            reduce using rule 33 (opSymbol -> NEQ .)
    FALSE           reduce using rule 33 (opSymbol -> NEQ .)
    THIS            reduce using rule 33 (opSymbol -> NEQ .)
    ID              reduce using rule 33 (opSymbol -> NEQ .)


state 136

    (34) opSymbol -> STRICTEQ .

    INT             reduce using rule 34 (opSymbol -> STRICTEQ .)
    FLOAT           reduce using rule 34 (opSymbol -> STRICTEQ .)
    VARIABLE        reduce using rule 34 (opSymbol -> STRICTEQ .)
    STRING          reduce using rule 34 (opSymbol -> STRICTEQ .)
    TRUE            reduce using rule 34 (opSymbol -> STRICTEQ .)
    FALSE           reduce using rule 34 (opSymbol -> STRICTEQ .)
    THIS            reduce using rule 34 (opSymbol -> STRICTEQ .)
    ID              reduce using rule 34 (opSymbol -> STRICTEQ .)


state 137

    (35) opSymbol -> STRICTNEQ .

    INT             reduce using rule 35 (opSymbol -> STRICTNEQ .)
    FLOAT           reduce using rule 35 (opSymbol -> STRICTNEQ .)
    VARIABLE        reduce using rule 35 (opSymbol -> STRICTNEQ .)
    STRING          reduce using rule 35 (opSymbol -> STRICTNEQ .)
    TRUE            reduce using rule 35 (opSymbol -> STRICTNEQ .)
    FALSE           reduce using rule 35 (opSymbol -> STRICTNEQ .)
    THIS            reduce using rule 35 (opSymbol -> STRICTNEQ .)
    ID              reduce using rule 35 (opSymbol -> STRICTNEQ .)


state 138

    (36) opSymbol -> LT .

    INT             reduce using rule 36 (opSymbol -> LT .)
    FLOAT           reduce using rule 36 (opSymbol -> LT .)
    VARIABLE        reduce using rule 36 (opSymbol -> LT .)
    STRING          reduce using rule 36 (opSymbol -> LT .)
    TRUE            reduce using rule 36 (opSymbol -> LT .)
    FALSE           reduce using rule 36 (opSymbol -> LT .)
    THIS            reduce using rule 36 (opSymbol -> LT .)
    ID              reduce using rule 36 (opSymbol -> LT .)


state 139

    (37) opSymbol -> GT .

    INT             reduce using rule 37 (opSymbol -> GT .)
    FLOAT           reduce using rule 37 (opSymbol -> GT .)
    VARIABLE        reduce using rule 37 (opSymbol -> GT .)
    STRING          reduce using rule 37 (opSymbol -> GT .)
    TRUE            reduce using rule 37 (opSymbol -> GT .)
    FALSE           reduce using rule 37 (opSymbol -> GT .)
    THIS            reduce using rule 37 (opSymbol -> GT .)
    ID              reduce using rule 37 (opSymbol -> GT .)


state 140

    (38) opSymbol -> LEQ .

    INT             reduce using rule 38 (opSymbol -> LEQ .)
    FLOAT           reduce using rule 38 (opSymbol -> LEQ .)
    VARIABLE        reduce using rule 38 (opSymbol -> LEQ .)
    STRING          reduce using rule 38 (opSymbol -> LEQ .)
    TRUE            reduce using rule 38 (opSymbol -> LEQ .)
    FALSE           reduce using rule 38 (opSymbol -> LEQ .)
    THIS            reduce using rule 38 (opSymbol -> LEQ .)
    ID              reduce using rule 38 (opSymbol -> LEQ .)


state 141

    (39) opSymbol -> GEQ .

    INT             reduce using rule 39 (opSymbol -> GEQ .)
    FLOAT           reduce using rule 39 (opSymbol -> GEQ .)
    VARIABLE        reduce using rule 39 (opSymbol -> GEQ .)
    STRING          reduce using rule 39 (opSymbol -> GEQ .)
    TRUE            reduce using rule 39 (opSymbol -> GEQ .)
    FALSE           reduce using rule 39 (opSymbol -> GEQ .)
    THIS            reduce using rule 39 (opSymbol -> GEQ .)
    ID              reduce using rule 39 (opSymbol -> GEQ .)


state 142

    (50) switch -> SWITCH LPAREN condition RPAREN . LBRACE caseLists RBRACE
    (51) switch -> SWITCH LPAREN condition RPAREN . LBRACE RBRACE

    LBRACE          shift and go to state 176


state 143

    (27) statementif -> IF LPAREN conditionProdu RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 177


state 144

    (29) conditionProdu -> condition opLogic . condition conditionProdu
    (30) condition -> . valor opSymbol valor
    (31) condition -> . LPAREN conditionProdu RPAREN
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 89
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    condition                      shift and go to state 178
    valor                          shift and go to state 91
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 145

    (40) opLogic -> AND .

    LPAREN          reduce using rule 40 (opLogic -> AND .)
    INT             reduce using rule 40 (opLogic -> AND .)
    FLOAT           reduce using rule 40 (opLogic -> AND .)
    VARIABLE        reduce using rule 40 (opLogic -> AND .)
    STRING          reduce using rule 40 (opLogic -> AND .)
    TRUE            reduce using rule 40 (opLogic -> AND .)
    FALSE           reduce using rule 40 (opLogic -> AND .)
    THIS            reduce using rule 40 (opLogic -> AND .)
    ID              reduce using rule 40 (opLogic -> AND .)


state 146

    (41) opLogic -> OR .

    LPAREN          reduce using rule 41 (opLogic -> OR .)
    INT             reduce using rule 41 (opLogic -> OR .)
    FLOAT           reduce using rule 41 (opLogic -> OR .)
    VARIABLE        reduce using rule 41 (opLogic -> OR .)
    STRING          reduce using rule 41 (opLogic -> OR .)
    TRUE            reduce using rule 41 (opLogic -> OR .)
    FALSE           reduce using rule 41 (opLogic -> OR .)
    THIS            reduce using rule 41 (opLogic -> OR .)
    ID              reduce using rule 41 (opLogic -> OR .)


state 147

    (42) opLogic -> NOT .

    LPAREN          reduce using rule 42 (opLogic -> NOT .)
    INT             reduce using rule 42 (opLogic -> NOT .)
    FLOAT           reduce using rule 42 (opLogic -> NOT .)
    VARIABLE        reduce using rule 42 (opLogic -> NOT .)
    STRING          reduce using rule 42 (opLogic -> NOT .)
    TRUE            reduce using rule 42 (opLogic -> NOT .)
    FALSE           reduce using rule 42 (opLogic -> NOT .)
    THIS            reduce using rule 42 (opLogic -> NOT .)
    ID              reduce using rule 42 (opLogic -> NOT .)


state 148

    (44) forStatement -> FOR LPAREN forcondition RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 179


state 149

    (46) forcondition -> VARIABLE EQUALS . INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (47) forcondition -> VARIABLE EQUALS . INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    INT             shift and go to state 180


state 150

    (45) forStatement -> FOREACH LPAREN forcondition RPAREN . LBRACE body BREAK SEMICOLON RBRACE

    LBRACE          shift and go to state 181


state 151

    (8) asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN . RPAREN SEMICOLON

    RPAREN          shift and go to state 182


state 152

    (90) array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 183


state 153

    (93) array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET . SEMICOLON
    (94) map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 184


state 154

    (98) mapArrow -> valor ARROWMAP . valor
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    valor                          shift and go to state 185
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 155

    (97) mapProduc -> mapArrow COMMA . mapProduc
    (96) mapProduc -> . mapArrow
    (97) mapProduc -> . mapArrow COMMA mapProduc
    (98) mapArrow -> . valor ARROWMAP valor
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    mapArrow                       shift and go to state 103
    mapProduc                      shift and go to state 186
    valor                          shift and go to state 187
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 156

    (91) array -> VARIABLE EQUALS ARRAY LPAREN repiteValores . RPAREN SEMICOLON

    RPAREN          shift and go to state 188


state 157

    (92) array -> VARIABLE EQUALS ARRAY LPAREN mapProduc . RPAREN SEMICOLON
    (95) map -> VARIABLE EQUALS ARRAY LPAREN mapProduc . RPAREN SEMICOLON

    RPAREN          shift and go to state 189


state 158

    (126) operaArit -> valor operador operaArit .

    SEMICOLON       reduce using rule 126 (operaArit -> valor operador operaArit .)
    COMMA           reduce using rule 126 (operaArit -> valor operador operaArit .)
    RPAREN          reduce using rule 126 (operaArit -> valor operador operaArit .)
    COLON           reduce using rule 126 (operaArit -> valor operador operaArit .)


state 159

    (127) operaArit -> valor DOT valor .

    SEMICOLON       reduce using rule 127 (operaArit -> valor DOT valor .)
    COMMA           reduce using rule 127 (operaArit -> valor DOT valor .)
    RPAREN          reduce using rule 127 (operaArit -> valor DOT valor .)
    COLON           reduce using rule 127 (operaArit -> valor DOT valor .)


state 160

    (75) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN . parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON
    (66) parametros -> . parametro
    (67) parametros -> . parametro COMMA parametros
    (68) parametros -> . empty
    (69) parametro -> . ID
    (70) parametro -> . dataType ID
    (71) parametro -> . ID EQUALS valor
    (72) parametro -> . dataType ID EQUALS valor
    (139) empty -> .
    (114) dataType -> . INTEGER
    (115) dataType -> . FLOATING
    (116) dataType -> . STRINGS
    (117) dataType -> . BOOLEAN
    (118) dataType -> . VOID

    ID              shift and go to state 110
    RPAREN          reduce using rule 139 (empty -> .)
    INTEGER         shift and go to state 115
    FLOATING        shift and go to state 116
    STRINGS         shift and go to state 117
    BOOLEAN         shift and go to state 118
    VOID            shift and go to state 119

    parametros                     shift and go to state 190
    parametro                      shift and go to state 112
    empty                          shift and go to state 113
    dataType                       shift and go to state 114

state 161

    (71) parametro -> ID EQUALS . valor
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    valor                          shift and go to state 191
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 162

    (74) funcionParen -> ID LPAREN parametros RPAREN .

    COMMA           reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    SEMICOLON       reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    DOT             reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    PLUS            reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    MINUS           reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    TIMES           reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    DIVIDE          reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    MODULO          reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    RPAREN          reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    EQ              reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    NEQ             reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    STRICTEQ        reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    STRICTNEQ       reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    LT              reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    GT              reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    LEQ             reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    GEQ             reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    ARROWMAP        reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    RBRACKET        reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    COLON           reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    AND             reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    OR              reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    NOT             reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    LPAREN          reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    INT             reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    FLOAT           reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    VARIABLE        reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    STRING          reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    TRUE            reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    FALSE           reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    THIS            reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    ID              reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)
    QUESTION        reduce using rule 74 (funcionParen -> ID LPAREN parametros RPAREN .)


state 163

    (67) parametros -> parametro COMMA . parametros
    (66) parametros -> . parametro
    (67) parametros -> . parametro COMMA parametros
    (68) parametros -> . empty
    (69) parametro -> . ID
    (70) parametro -> . dataType ID
    (71) parametro -> . ID EQUALS valor
    (72) parametro -> . dataType ID EQUALS valor
    (139) empty -> .
    (114) dataType -> . INTEGER
    (115) dataType -> . FLOATING
    (116) dataType -> . STRINGS
    (117) dataType -> . BOOLEAN
    (118) dataType -> . VOID

    ID              shift and go to state 110
    RPAREN          reduce using rule 139 (empty -> .)
    INTEGER         shift and go to state 115
    FLOATING        shift and go to state 116
    STRINGS         shift and go to state 117
    BOOLEAN         shift and go to state 118
    VOID            shift and go to state 119

    parametro                      shift and go to state 112
    parametros                     shift and go to state 192
    empty                          shift and go to state 113
    dataType                       shift and go to state 114

state 164

    (70) parametro -> dataType ID .
    (72) parametro -> dataType ID . EQUALS valor

    COMMA           reduce using rule 70 (parametro -> dataType ID .)
    RPAREN          reduce using rule 70 (parametro -> dataType ID .)
    EQUALS          shift and go to state 193


state 165

    (62) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN . LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN . DOUBLEDOT dataType LBRACE funcionBody RBRACE

    LBRACE          shift and go to state 194
    DOUBLEDOT       shift and go to state 195


state 166

    (76) classDeclarate -> CLASS ID LBRACE classBody RBRACE .

    VARIABLE        reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    ECHO            reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    PRINT           reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    INT             reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    FLOAT           reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    FUNCTION        reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    CLASS           reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    WHILE           reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    SWITCH          reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    IF              reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    FOR             reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    FOREACH         reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    $end            reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    RBRACE          reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    BREAK           reduce using rule 76 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)


state 167

    (78) classBody -> classMember classBody .

    RBRACE          reduce using rule 78 (classBody -> classMember classBody .)


state 168

    (80) classMember -> dataType VARIABLE . SEMICOLON

    SEMICOLON       shift and go to state 196


state 169

    (81) classMember -> dataType FUNCTION . ID LPAREN parametros RPAREN brace

    ID              shift and go to state 197


state 170

    (85) objectInstantiation -> NEW ID . LPAREN argumentos RPAREN
    (86) objectInstantiation -> NEW ID . LPAREN RPAREN

    LPAREN          shift and go to state 198


state 171

    (77) classDeclarate -> CLASS ID EXTENDS ID LBRACE . classBody RBRACE
    (78) classBody -> . classMember classBody
    (79) classBody -> . empty
    (80) classMember -> . dataType VARIABLE SEMICOLON
    (81) classMember -> . dataType FUNCTION ID LPAREN parametros RPAREN brace
    (82) classMember -> . objectInstantiation
    (139) empty -> .
    (114) dataType -> . INTEGER
    (115) dataType -> . FLOATING
    (116) dataType -> . STRINGS
    (117) dataType -> . BOOLEAN
    (118) dataType -> . VOID
    (85) objectInstantiation -> . NEW ID LPAREN argumentos RPAREN
    (86) objectInstantiation -> . NEW ID LPAREN RPAREN

    RBRACE          reduce using rule 139 (empty -> .)
    INTEGER         shift and go to state 115
    FLOATING        shift and go to state 116
    STRINGS         shift and go to state 117
    BOOLEAN         shift and go to state 118
    VOID            shift and go to state 119
    NEW             shift and go to state 126

    classBody                      shift and go to state 199
    classMember                    shift and go to state 122
    empty                          shift and go to state 123
    dataType                       shift and go to state 124
    objectInstantiation            shift and go to state 125

state 172

    (10) sentencias -> sentencia sentencias .

    VARIABLE        reduce using rule 10 (sentencias -> sentencia sentencias .)
    ECHO            reduce using rule 10 (sentencias -> sentencia sentencias .)
    PRINT           reduce using rule 10 (sentencias -> sentencia sentencias .)
    INT             reduce using rule 10 (sentencias -> sentencia sentencias .)
    FLOAT           reduce using rule 10 (sentencias -> sentencia sentencias .)
    FUNCTION        reduce using rule 10 (sentencias -> sentencia sentencias .)
    CLASS           reduce using rule 10 (sentencias -> sentencia sentencias .)
    WHILE           reduce using rule 10 (sentencias -> sentencia sentencias .)
    SWITCH          reduce using rule 10 (sentencias -> sentencia sentencias .)
    IF              reduce using rule 10 (sentencias -> sentencia sentencias .)
    FOR             reduce using rule 10 (sentencias -> sentencia sentencias .)
    FOREACH         reduce using rule 10 (sentencias -> sentencia sentencias .)
    $end            reduce using rule 10 (sentencias -> sentencia sentencias .)
    RBRACE          reduce using rule 10 (sentencias -> sentencia sentencias .)
    BREAK           reduce using rule 10 (sentencias -> sentencia sentencias .)


state 173

    (31) condition -> LPAREN conditionProdu RPAREN .

    RPAREN          reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    AND             reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    OR              reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    NOT             reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    LPAREN          reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    INT             reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    FLOAT           reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    VARIABLE        reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    STRING          reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    TRUE            reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    FALSE           reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    THIS            reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    ID              reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    QUESTION        reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    COMMA           reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    SEMICOLON       reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)
    COLON           reduce using rule 31 (condition -> LPAREN conditionProdu RPAREN .)


state 174

    (48) while -> WHILE LPAREN condition RPAREN LBRACE . body RBRACE
    (49) while -> WHILE LPAREN condition RPAREN LBRACE . RBRACE
    (99) body -> . sentencia
    (100) body -> . sentencia sentencias
    (101) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) sentencia -> . asignacion_fgets
    (139) empty -> .
    (12) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (13) impresion -> . ECHO imprimir SEMICOLON
    (14) impresion -> . PRINT imprimir SEMICOLON
    (119) comparacion -> . INT operador INT
    (120) comparacion -> . FLOAT operador FLOAT
    (121) comparacion -> . INT operador FLOAT
    (122) comparacion -> . FLOAT operador INT
    (15) estructurasProgram -> . controlStructure
    (16) estructurasProgram -> . dataStructure
    (17) estructurasProgram -> . funcionDeclarate
    (18) estructurasProgram -> . classDeclarate
    (8) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (19) controlStructure -> . if
    (20) controlStructure -> . for
    (21) controlStructure -> . while
    (22) controlStructure -> . switch
    (60) dataStructure -> . array
    (61) dataStructure -> . map
    (62) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (76) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (77) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (43) for -> . forStatement
    (48) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (50) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (90) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (44) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (45) forStatement -> . FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
    RBRACE          shift and go to state 201
    VARIABLE        shift and go to state 8
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    FUNCTION        shift and go to state 23
    CLASS           shift and go to state 24
    WHILE           shift and go to state 27
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    FOREACH         shift and go to state 31

  ! RBRACE          [ reduce using rule 139 (empty -> .) ]

    body                           shift and go to state 200
    sentencia                      shift and go to state 86
    empty                          shift and go to state 87
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    asignacion_fgets               shift and go to state 7
    controlStructure               shift and go to state 13
    dataStructure                  shift and go to state 14
    funcionDeclarate               shift and go to state 15
    classDeclarate                 shift and go to state 16
    if                             shift and go to state 17
    for                            shift and go to state 18
    while                          shift and go to state 19
    switch                         shift and go to state 20
    array                          shift and go to state 21
    map                            shift and go to state 22
    statementif                    shift and go to state 25
    forStatement                   shift and go to state 26

state 175

    (30) condition -> valor opSymbol valor .

    RPAREN          reduce using rule 30 (condition -> valor opSymbol valor .)
    AND             reduce using rule 30 (condition -> valor opSymbol valor .)
    OR              reduce using rule 30 (condition -> valor opSymbol valor .)
    NOT             reduce using rule 30 (condition -> valor opSymbol valor .)
    LPAREN          reduce using rule 30 (condition -> valor opSymbol valor .)
    INT             reduce using rule 30 (condition -> valor opSymbol valor .)
    FLOAT           reduce using rule 30 (condition -> valor opSymbol valor .)
    VARIABLE        reduce using rule 30 (condition -> valor opSymbol valor .)
    STRING          reduce using rule 30 (condition -> valor opSymbol valor .)
    TRUE            reduce using rule 30 (condition -> valor opSymbol valor .)
    FALSE           reduce using rule 30 (condition -> valor opSymbol valor .)
    THIS            reduce using rule 30 (condition -> valor opSymbol valor .)
    ID              reduce using rule 30 (condition -> valor opSymbol valor .)
    QUESTION        reduce using rule 30 (condition -> valor opSymbol valor .)
    COMMA           reduce using rule 30 (condition -> valor opSymbol valor .)
    SEMICOLON       reduce using rule 30 (condition -> valor opSymbol valor .)
    COLON           reduce using rule 30 (condition -> valor opSymbol valor .)


state 176

    (50) switch -> SWITCH LPAREN condition RPAREN LBRACE . caseLists RBRACE
    (51) switch -> SWITCH LPAREN condition RPAREN LBRACE . RBRACE
    (52) caseLists -> . cases default
    (53) caseLists -> . cases
    (54) caseLists -> . default
    (55) caseLists -> . empty
    (56) cases -> . case cases
    (57) cases -> . case
    (59) default -> . DEFAULT COLON body BREAK SEMICOLON
    (139) empty -> .
    (58) case -> . CASE valor COLON body BREAK SEMICOLON

  ! shift/reduce conflict for RBRACE resolved as shift
    RBRACE          shift and go to state 203
    DEFAULT         shift and go to state 208
    CASE            shift and go to state 209

  ! RBRACE          [ reduce using rule 139 (empty -> .) ]

    caseLists                      shift and go to state 202
    cases                          shift and go to state 204
    default                        shift and go to state 205
    empty                          shift and go to state 206
    case                           shift and go to state 207

state 177

    (27) statementif -> IF LPAREN conditionProdu RPAREN LBRACE . body RBRACE
    (99) body -> . sentencia
    (100) body -> . sentencia sentencias
    (101) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) sentencia -> . asignacion_fgets
    (139) empty -> .
    (12) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (13) impresion -> . ECHO imprimir SEMICOLON
    (14) impresion -> . PRINT imprimir SEMICOLON
    (119) comparacion -> . INT operador INT
    (120) comparacion -> . FLOAT operador FLOAT
    (121) comparacion -> . INT operador FLOAT
    (122) comparacion -> . FLOAT operador INT
    (15) estructurasProgram -> . controlStructure
    (16) estructurasProgram -> . dataStructure
    (17) estructurasProgram -> . funcionDeclarate
    (18) estructurasProgram -> . classDeclarate
    (8) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (19) controlStructure -> . if
    (20) controlStructure -> . for
    (21) controlStructure -> . while
    (22) controlStructure -> . switch
    (60) dataStructure -> . array
    (61) dataStructure -> . map
    (62) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (76) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (77) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (43) for -> . forStatement
    (48) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (50) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (90) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (44) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (45) forStatement -> . FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

    RBRACE          reduce using rule 139 (empty -> .)
    VARIABLE        shift and go to state 8
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    FUNCTION        shift and go to state 23
    CLASS           shift and go to state 24
    WHILE           shift and go to state 27
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    FOREACH         shift and go to state 31

    body                           shift and go to state 210
    sentencia                      shift and go to state 86
    empty                          shift and go to state 87
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    asignacion_fgets               shift and go to state 7
    controlStructure               shift and go to state 13
    dataStructure                  shift and go to state 14
    funcionDeclarate               shift and go to state 15
    classDeclarate                 shift and go to state 16
    if                             shift and go to state 17
    for                            shift and go to state 18
    while                          shift and go to state 19
    switch                         shift and go to state 20
    array                          shift and go to state 21
    map                            shift and go to state 22
    statementif                    shift and go to state 25
    forStatement                   shift and go to state 26

state 178

    (29) conditionProdu -> condition opLogic condition . conditionProdu
    (28) conditionProdu -> . condition
    (29) conditionProdu -> . condition opLogic condition conditionProdu
    (30) condition -> . valor opSymbol valor
    (31) condition -> . LPAREN conditionProdu RPAREN
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 89
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    condition                      shift and go to state 94
    conditionProdu                 shift and go to state 211
    valor                          shift and go to state 91
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 179

    (44) forStatement -> FOR LPAREN forcondition RPAREN LBRACE . body RBRACE
    (99) body -> . sentencia
    (100) body -> . sentencia sentencias
    (101) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) sentencia -> . asignacion_fgets
    (139) empty -> .
    (12) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (13) impresion -> . ECHO imprimir SEMICOLON
    (14) impresion -> . PRINT imprimir SEMICOLON
    (119) comparacion -> . INT operador INT
    (120) comparacion -> . FLOAT operador FLOAT
    (121) comparacion -> . INT operador FLOAT
    (122) comparacion -> . FLOAT operador INT
    (15) estructurasProgram -> . controlStructure
    (16) estructurasProgram -> . dataStructure
    (17) estructurasProgram -> . funcionDeclarate
    (18) estructurasProgram -> . classDeclarate
    (8) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (19) controlStructure -> . if
    (20) controlStructure -> . for
    (21) controlStructure -> . while
    (22) controlStructure -> . switch
    (60) dataStructure -> . array
    (61) dataStructure -> . map
    (62) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (76) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (77) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (43) for -> . forStatement
    (48) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (50) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (90) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (44) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (45) forStatement -> . FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

    RBRACE          reduce using rule 139 (empty -> .)
    VARIABLE        shift and go to state 8
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    FUNCTION        shift and go to state 23
    CLASS           shift and go to state 24
    WHILE           shift and go to state 27
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    FOREACH         shift and go to state 31

    body                           shift and go to state 212
    sentencia                      shift and go to state 86
    empty                          shift and go to state 87
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    asignacion_fgets               shift and go to state 7
    controlStructure               shift and go to state 13
    dataStructure                  shift and go to state 14
    funcionDeclarate               shift and go to state 15
    classDeclarate                 shift and go to state 16
    if                             shift and go to state 17
    for                            shift and go to state 18
    while                          shift and go to state 19
    switch                         shift and go to state 20
    array                          shift and go to state 21
    map                            shift and go to state 22
    statementif                    shift and go to state 25
    forStatement                   shift and go to state 26

state 180

    (46) forcondition -> VARIABLE EQUALS INT . SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (47) forcondition -> VARIABLE EQUALS INT . SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    SEMICOLON       shift and go to state 213


state 181

    (45) forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE . body BREAK SEMICOLON RBRACE
    (99) body -> . sentencia
    (100) body -> . sentencia sentencias
    (101) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) sentencia -> . asignacion_fgets
    (139) empty -> .
    (12) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (13) impresion -> . ECHO imprimir SEMICOLON
    (14) impresion -> . PRINT imprimir SEMICOLON
    (119) comparacion -> . INT operador INT
    (120) comparacion -> . FLOAT operador FLOAT
    (121) comparacion -> . INT operador FLOAT
    (122) comparacion -> . FLOAT operador INT
    (15) estructurasProgram -> . controlStructure
    (16) estructurasProgram -> . dataStructure
    (17) estructurasProgram -> . funcionDeclarate
    (18) estructurasProgram -> . classDeclarate
    (8) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (19) controlStructure -> . if
    (20) controlStructure -> . for
    (21) controlStructure -> . while
    (22) controlStructure -> . switch
    (60) dataStructure -> . array
    (61) dataStructure -> . map
    (62) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (76) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (77) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (43) for -> . forStatement
    (48) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (50) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (90) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (44) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (45) forStatement -> . FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

    BREAK           reduce using rule 139 (empty -> .)
    VARIABLE        shift and go to state 8
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    FUNCTION        shift and go to state 23
    CLASS           shift and go to state 24
    WHILE           shift and go to state 27
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    FOREACH         shift and go to state 31

    body                           shift and go to state 214
    sentencia                      shift and go to state 86
    empty                          shift and go to state 87
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    asignacion_fgets               shift and go to state 7
    controlStructure               shift and go to state 13
    dataStructure                  shift and go to state 14
    funcionDeclarate               shift and go to state 15
    classDeclarate                 shift and go to state 16
    if                             shift and go to state 17
    for                            shift and go to state 18
    while                          shift and go to state 19
    switch                         shift and go to state 20
    array                          shift and go to state 21
    map                            shift and go to state 22
    statementif                    shift and go to state 25
    forStatement                   shift and go to state 26

state 182

    (8) asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 215


state 183

    (90) array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .

    VARIABLE        reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    ECHO            reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    PRINT           reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    INT             reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    FUNCTION        reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    CLASS           reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    WHILE           reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    SWITCH          reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    IF              reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    FOR             reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    FOREACH         reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    $end            reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    BREAK           reduce using rule 90 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)


state 184

    (93) array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .
    (94) map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .

  ! reduce/reduce conflict for VARIABLE resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for ECHO resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for PRINT resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for INT resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for FLOAT resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for CLASS resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for WHILE resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for SWITCH resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for IF resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for FOR resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for FOREACH resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for $end resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for RBRACE resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for BREAK resolved using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    VARIABLE        reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    ECHO            reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    PRINT           reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    INT             reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    FUNCTION        reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    CLASS           reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    WHILE           reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    SWITCH          reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    IF              reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    FOR             reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    FOREACH         reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    $end            reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    BREAK           reduce using rule 93 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)

  ! VARIABLE        [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! ECHO            [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! PRINT           [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! INT             [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! FUNCTION        [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! CLASS           [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! WHILE           [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! SWITCH          [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! IF              [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! FOR             [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! FOREACH         [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! $end            [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! RBRACE          [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! BREAK           [ reduce using rule 94 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]


state 185

    (98) mapArrow -> valor ARROWMAP valor .

    COMMA           reduce using rule 98 (mapArrow -> valor ARROWMAP valor .)
    RBRACKET        reduce using rule 98 (mapArrow -> valor ARROWMAP valor .)
    RPAREN          reduce using rule 98 (mapArrow -> valor ARROWMAP valor .)


state 186

    (97) mapProduc -> mapArrow COMMA mapProduc .

    RBRACKET        reduce using rule 97 (mapProduc -> mapArrow COMMA mapProduc .)
    RPAREN          reduce using rule 97 (mapProduc -> mapArrow COMMA mapProduc .)


state 187

    (98) mapArrow -> valor . ARROWMAP valor

    ARROWMAP        shift and go to state 154


state 188

    (91) array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 216


state 189

    (92) array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN . SEMICOLON
    (95) map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 217


state 190

    (75) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros . RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    RPAREN          shift and go to state 218


state 191

    (71) parametro -> ID EQUALS valor .

    COMMA           reduce using rule 71 (parametro -> ID EQUALS valor .)
    RPAREN          reduce using rule 71 (parametro -> ID EQUALS valor .)


state 192

    (67) parametros -> parametro COMMA parametros .

    RPAREN          reduce using rule 67 (parametros -> parametro COMMA parametros .)


state 193

    (72) parametro -> dataType ID EQUALS . valor
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    valor                          shift and go to state 219
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 194

    (62) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE . funcionBody RBRACE
    (64) funcionBody -> . body
    (65) funcionBody -> . RETURN expresion SEMICOLON
    (99) body -> . sentencia
    (100) body -> . sentencia sentencias
    (101) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) sentencia -> . asignacion_fgets
    (139) empty -> .
    (12) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (13) impresion -> . ECHO imprimir SEMICOLON
    (14) impresion -> . PRINT imprimir SEMICOLON
    (119) comparacion -> . INT operador INT
    (120) comparacion -> . FLOAT operador FLOAT
    (121) comparacion -> . INT operador FLOAT
    (122) comparacion -> . FLOAT operador INT
    (15) estructurasProgram -> . controlStructure
    (16) estructurasProgram -> . dataStructure
    (17) estructurasProgram -> . funcionDeclarate
    (18) estructurasProgram -> . classDeclarate
    (8) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (19) controlStructure -> . if
    (20) controlStructure -> . for
    (21) controlStructure -> . while
    (22) controlStructure -> . switch
    (60) dataStructure -> . array
    (61) dataStructure -> . map
    (62) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (76) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (77) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (43) for -> . forStatement
    (48) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (50) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (90) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (44) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (45) forStatement -> . FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

    RETURN          shift and go to state 222
    RBRACE          reduce using rule 139 (empty -> .)
    VARIABLE        shift and go to state 8
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    FUNCTION        shift and go to state 23
    CLASS           shift and go to state 24
    WHILE           shift and go to state 27
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    FOREACH         shift and go to state 31

    funcionBody                    shift and go to state 220
    body                           shift and go to state 221
    sentencia                      shift and go to state 86
    empty                          shift and go to state 87
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    asignacion_fgets               shift and go to state 7
    controlStructure               shift and go to state 13
    dataStructure                  shift and go to state 14
    funcionDeclarate               shift and go to state 15
    classDeclarate                 shift and go to state 16
    if                             shift and go to state 17
    for                            shift and go to state 18
    while                          shift and go to state 19
    switch                         shift and go to state 20
    array                          shift and go to state 21
    map                            shift and go to state 22
    statementif                    shift and go to state 25
    forStatement                   shift and go to state 26

state 195

    (63) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT . dataType LBRACE funcionBody RBRACE
    (114) dataType -> . INTEGER
    (115) dataType -> . FLOATING
    (116) dataType -> . STRINGS
    (117) dataType -> . BOOLEAN
    (118) dataType -> . VOID

    INTEGER         shift and go to state 115
    FLOATING        shift and go to state 116
    STRINGS         shift and go to state 117
    BOOLEAN         shift and go to state 118
    VOID            shift and go to state 119

    dataType                       shift and go to state 223

state 196

    (80) classMember -> dataType VARIABLE SEMICOLON .

    INTEGER         reduce using rule 80 (classMember -> dataType VARIABLE SEMICOLON .)
    FLOATING        reduce using rule 80 (classMember -> dataType VARIABLE SEMICOLON .)
    STRINGS         reduce using rule 80 (classMember -> dataType VARIABLE SEMICOLON .)
    BOOLEAN         reduce using rule 80 (classMember -> dataType VARIABLE SEMICOLON .)
    VOID            reduce using rule 80 (classMember -> dataType VARIABLE SEMICOLON .)
    NEW             reduce using rule 80 (classMember -> dataType VARIABLE SEMICOLON .)
    RBRACE          reduce using rule 80 (classMember -> dataType VARIABLE SEMICOLON .)


state 197

    (81) classMember -> dataType FUNCTION ID . LPAREN parametros RPAREN brace

    LPAREN          shift and go to state 224


state 198

    (85) objectInstantiation -> NEW ID LPAREN . argumentos RPAREN
    (86) objectInstantiation -> NEW ID LPAREN . RPAREN
    (87) argumentos -> . expresion
    (88) argumentos -> . expresion COMMA argumentos
    (89) argumentos -> . empty
    (128) expresion -> . valor
    (129) expresion -> . operaArit
    (130) expresion -> . conditionProdu
    (131) expresion -> . ternario
    (132) expresion -> . accessMember
    (139) empty -> .
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (125) operaArit -> . valor
    (126) operaArit -> . valor operador operaArit
    (127) operaArit -> . valor DOT valor
    (28) conditionProdu -> . condition
    (29) conditionProdu -> . condition opLogic condition conditionProdu
    (138) ternario -> . conditionProdu QUESTION expresion COLON expresion
    (83) accessMember -> . VARIABLE ARROW ID
    (84) accessMember -> . VARIABLE ARROW funcionParen
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON
    (30) condition -> . valor opSymbol valor
    (31) condition -> . LPAREN conditionProdu RPAREN

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 226
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 234
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47
    LPAREN          shift and go to state 89

  ! RPAREN          [ reduce using rule 139 (empty -> .) ]

    argumentos                     shift and go to state 225
    expresion                      shift and go to state 227
    empty                          shift and go to state 228
    valor                          shift and go to state 229
    operaArit                      shift and go to state 230
    conditionProdu                 shift and go to state 231
    ternario                       shift and go to state 232
    accessMember                   shift and go to state 233
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46
    condition                      shift and go to state 94

state 199

    (77) classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody . RBRACE

    RBRACE          shift and go to state 235


state 200

    (48) while -> WHILE LPAREN condition RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 236


state 201

    (49) while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .

    VARIABLE        reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    ECHO            reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    PRINT           reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    INT             reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    FLOAT           reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    FUNCTION        reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    CLASS           reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    WHILE           reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    SWITCH          reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    IF              reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    FOR             reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    FOREACH         reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    $end            reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    RBRACE          reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    BREAK           reduce using rule 49 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)


state 202

    (50) switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists . RBRACE

    RBRACE          shift and go to state 237


state 203

    (51) switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .

    VARIABLE        reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    ECHO            reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    PRINT           reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    INT             reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    FLOAT           reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    FUNCTION        reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    CLASS           reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    WHILE           reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    SWITCH          reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    IF              reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    FOR             reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    FOREACH         reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    $end            reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    RBRACE          reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    BREAK           reduce using rule 51 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)


state 204

    (52) caseLists -> cases . default
    (53) caseLists -> cases .
    (59) default -> . DEFAULT COLON body BREAK SEMICOLON

    RBRACE          reduce using rule 53 (caseLists -> cases .)
    DEFAULT         shift and go to state 208

    default                        shift and go to state 238

state 205

    (54) caseLists -> default .

    RBRACE          reduce using rule 54 (caseLists -> default .)


state 206

    (55) caseLists -> empty .

    RBRACE          reduce using rule 55 (caseLists -> empty .)


state 207

    (56) cases -> case . cases
    (57) cases -> case .
    (56) cases -> . case cases
    (57) cases -> . case
    (58) case -> . CASE valor COLON body BREAK SEMICOLON

    DEFAULT         reduce using rule 57 (cases -> case .)
    RBRACE          reduce using rule 57 (cases -> case .)
    CASE            shift and go to state 209

    case                           shift and go to state 207
    cases                          shift and go to state 239

state 208

    (59) default -> DEFAULT . COLON body BREAK SEMICOLON

    COLON           shift and go to state 240


state 209

    (58) case -> CASE . valor COLON body BREAK SEMICOLON
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 40
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47

    valor                          shift and go to state 241
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46

state 210

    (27) statementif -> IF LPAREN conditionProdu RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 242


state 211

    (29) conditionProdu -> condition opLogic condition conditionProdu .

    RPAREN          reduce using rule 29 (conditionProdu -> condition opLogic condition conditionProdu .)
    QUESTION        reduce using rule 29 (conditionProdu -> condition opLogic condition conditionProdu .)
    COMMA           reduce using rule 29 (conditionProdu -> condition opLogic condition conditionProdu .)
    SEMICOLON       reduce using rule 29 (conditionProdu -> condition opLogic condition conditionProdu .)
    COLON           reduce using rule 29 (conditionProdu -> condition opLogic condition conditionProdu .)


state 212

    (44) forStatement -> FOR LPAREN forcondition RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 243


state 213

    (46) forcondition -> VARIABLE EQUALS INT SEMICOLON . VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (47) forcondition -> VARIABLE EQUALS INT SEMICOLON . VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    VARIABLE        shift and go to state 244


state 214

    (45) forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body . BREAK SEMICOLON RBRACE

    BREAK           shift and go to state 245


state 215

    (8) asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .

    VARIABLE        reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    ECHO            reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    PRINT           reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    INT             reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    CLASS           reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    WHILE           reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    SWITCH          reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    IF              reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FOR             reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FOREACH         reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    $end            reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    BREAK           reduce using rule 8 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)


state 216

    (91) array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .

    VARIABLE        reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    ECHO            reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    PRINT           reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    INT             reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    FLOAT           reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    CLASS           reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    WHILE           reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    SWITCH          reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    IF              reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    FOR             reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    FOREACH         reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    $end            reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    RBRACE          reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    BREAK           reduce using rule 91 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)


state 217

    (92) array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .
    (95) map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .

  ! reduce/reduce conflict for VARIABLE resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for ECHO resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for PRINT resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for INT resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FLOAT resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for CLASS resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for WHILE resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for SWITCH resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for IF resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FOR resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FOREACH resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for $end resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for RBRACE resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for BREAK resolved using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    VARIABLE        reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    ECHO            reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    PRINT           reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    INT             reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    FLOAT           reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    CLASS           reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    WHILE           reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    SWITCH          reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    IF              reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    FOR             reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    FOREACH         reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    $end            reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    RBRACE          reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    BREAK           reduce using rule 92 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)

  ! VARIABLE        [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! ECHO            [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! PRINT           [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! INT             [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! FUNCTION        [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! CLASS           [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! WHILE           [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! SWITCH          [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! IF              [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! FOR             [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! FOREACH         [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! $end            [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! RBRACE          [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! BREAK           [ reduce using rule 95 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]


state 218

    (75) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN . LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LBRACE          shift and go to state 246


state 219

    (72) parametro -> dataType ID EQUALS valor .

    COMMA           reduce using rule 72 (parametro -> dataType ID EQUALS valor .)
    RPAREN          reduce using rule 72 (parametro -> dataType ID EQUALS valor .)


state 220

    (62) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody . RBRACE

    RBRACE          shift and go to state 247


state 221

    (64) funcionBody -> body .

    RBRACE          reduce using rule 64 (funcionBody -> body .)


state 222

    (65) funcionBody -> RETURN . expresion SEMICOLON
    (128) expresion -> . valor
    (129) expresion -> . operaArit
    (130) expresion -> . conditionProdu
    (131) expresion -> . ternario
    (132) expresion -> . accessMember
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (125) operaArit -> . valor
    (126) operaArit -> . valor operador operaArit
    (127) operaArit -> . valor DOT valor
    (28) conditionProdu -> . condition
    (29) conditionProdu -> . condition opLogic condition conditionProdu
    (138) ternario -> . conditionProdu QUESTION expresion COLON expresion
    (83) accessMember -> . VARIABLE ARROW ID
    (84) accessMember -> . VARIABLE ARROW funcionParen
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON
    (30) condition -> . valor opSymbol valor
    (31) condition -> . LPAREN conditionProdu RPAREN

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 234
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47
    LPAREN          shift and go to state 89

    expresion                      shift and go to state 248
    valor                          shift and go to state 229
    operaArit                      shift and go to state 230
    conditionProdu                 shift and go to state 231
    ternario                       shift and go to state 232
    accessMember                   shift and go to state 233
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46
    condition                      shift and go to state 94

state 223

    (63) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType . LBRACE funcionBody RBRACE

    LBRACE          shift and go to state 249


state 224

    (81) classMember -> dataType FUNCTION ID LPAREN . parametros RPAREN brace
    (66) parametros -> . parametro
    (67) parametros -> . parametro COMMA parametros
    (68) parametros -> . empty
    (69) parametro -> . ID
    (70) parametro -> . dataType ID
    (71) parametro -> . ID EQUALS valor
    (72) parametro -> . dataType ID EQUALS valor
    (139) empty -> .
    (114) dataType -> . INTEGER
    (115) dataType -> . FLOATING
    (116) dataType -> . STRINGS
    (117) dataType -> . BOOLEAN
    (118) dataType -> . VOID

    ID              shift and go to state 110
    RPAREN          reduce using rule 139 (empty -> .)
    INTEGER         shift and go to state 115
    FLOATING        shift and go to state 116
    STRINGS         shift and go to state 117
    BOOLEAN         shift and go to state 118
    VOID            shift and go to state 119

    dataType                       shift and go to state 114
    parametros                     shift and go to state 250
    parametro                      shift and go to state 112
    empty                          shift and go to state 113

state 225

    (85) objectInstantiation -> NEW ID LPAREN argumentos . RPAREN

    RPAREN          shift and go to state 251


state 226

    (86) objectInstantiation -> NEW ID LPAREN RPAREN .

    INTEGER         reduce using rule 86 (objectInstantiation -> NEW ID LPAREN RPAREN .)
    FLOATING        reduce using rule 86 (objectInstantiation -> NEW ID LPAREN RPAREN .)
    STRINGS         reduce using rule 86 (objectInstantiation -> NEW ID LPAREN RPAREN .)
    BOOLEAN         reduce using rule 86 (objectInstantiation -> NEW ID LPAREN RPAREN .)
    VOID            reduce using rule 86 (objectInstantiation -> NEW ID LPAREN RPAREN .)
    NEW             reduce using rule 86 (objectInstantiation -> NEW ID LPAREN RPAREN .)
    RBRACE          reduce using rule 86 (objectInstantiation -> NEW ID LPAREN RPAREN .)


state 227

    (87) argumentos -> expresion .
    (88) argumentos -> expresion . COMMA argumentos

    RPAREN          reduce using rule 87 (argumentos -> expresion .)
    COMMA           shift and go to state 252


state 228

    (89) argumentos -> empty .

    RPAREN          reduce using rule 89 (argumentos -> empty .)


state 229

    (128) expresion -> valor .
    (125) operaArit -> valor .
    (126) operaArit -> valor . operador operaArit
    (127) operaArit -> valor . DOT valor
    (30) condition -> valor . opSymbol valor
    (133) operador -> . PLUS
    (134) operador -> . MINUS
    (135) operador -> . TIMES
    (136) operador -> . DIVIDE
    (137) operador -> . MODULO
    (32) opSymbol -> . EQ
    (33) opSymbol -> . NEQ
    (34) opSymbol -> . STRICTEQ
    (35) opSymbol -> . STRICTNEQ
    (36) opSymbol -> . LT
    (37) opSymbol -> . GT
    (38) opSymbol -> . LEQ
    (39) opSymbol -> . GEQ

  ! reduce/reduce conflict for COMMA resolved using rule 125 (operaArit -> valor .)
  ! reduce/reduce conflict for RPAREN resolved using rule 125 (operaArit -> valor .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 125 (operaArit -> valor .)
  ! reduce/reduce conflict for COLON resolved using rule 125 (operaArit -> valor .)
    COMMA           reduce using rule 125 (operaArit -> valor .)
    RPAREN          reduce using rule 125 (operaArit -> valor .)
    SEMICOLON       reduce using rule 125 (operaArit -> valor .)
    COLON           reduce using rule 125 (operaArit -> valor .)
    DOT             shift and go to state 106
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MODULO          shift and go to state 54
    EQ              shift and go to state 134
    NEQ             shift and go to state 135
    STRICTEQ        shift and go to state 136
    STRICTNEQ       shift and go to state 137
    LT              shift and go to state 138
    GT              shift and go to state 139
    LEQ             shift and go to state 140
    GEQ             shift and go to state 141

  ! COMMA           [ reduce using rule 128 (expresion -> valor .) ]
  ! RPAREN          [ reduce using rule 128 (expresion -> valor .) ]
  ! SEMICOLON       [ reduce using rule 128 (expresion -> valor .) ]
  ! COLON           [ reduce using rule 128 (expresion -> valor .) ]

    operador                       shift and go to state 105
    opSymbol                       shift and go to state 133

state 230

    (129) expresion -> operaArit .

    COMMA           reduce using rule 129 (expresion -> operaArit .)
    RPAREN          reduce using rule 129 (expresion -> operaArit .)
    SEMICOLON       reduce using rule 129 (expresion -> operaArit .)
    COLON           reduce using rule 129 (expresion -> operaArit .)


state 231

    (130) expresion -> conditionProdu .
    (138) ternario -> conditionProdu . QUESTION expresion COLON expresion

    COMMA           reduce using rule 130 (expresion -> conditionProdu .)
    RPAREN          reduce using rule 130 (expresion -> conditionProdu .)
    SEMICOLON       reduce using rule 130 (expresion -> conditionProdu .)
    COLON           reduce using rule 130 (expresion -> conditionProdu .)
    QUESTION        shift and go to state 253


state 232

    (131) expresion -> ternario .

    COMMA           reduce using rule 131 (expresion -> ternario .)
    RPAREN          reduce using rule 131 (expresion -> ternario .)
    SEMICOLON       reduce using rule 131 (expresion -> ternario .)
    COLON           reduce using rule 131 (expresion -> ternario .)


state 233

    (132) expresion -> accessMember .

    COMMA           reduce using rule 132 (expresion -> accessMember .)
    RPAREN          reduce using rule 132 (expresion -> accessMember .)
    SEMICOLON       reduce using rule 132 (expresion -> accessMember .)
    COLON           reduce using rule 132 (expresion -> accessMember .)


state 234

    (107) valor -> VARIABLE .
    (83) accessMember -> VARIABLE . ARROW ID
    (84) accessMember -> VARIABLE . ARROW funcionParen
    (75) funcionAnonima -> VARIABLE . EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    DOT             reduce using rule 107 (valor -> VARIABLE .)
    PLUS            reduce using rule 107 (valor -> VARIABLE .)
    MINUS           reduce using rule 107 (valor -> VARIABLE .)
    TIMES           reduce using rule 107 (valor -> VARIABLE .)
    DIVIDE          reduce using rule 107 (valor -> VARIABLE .)
    MODULO          reduce using rule 107 (valor -> VARIABLE .)
    EQ              reduce using rule 107 (valor -> VARIABLE .)
    NEQ             reduce using rule 107 (valor -> VARIABLE .)
    STRICTEQ        reduce using rule 107 (valor -> VARIABLE .)
    STRICTNEQ       reduce using rule 107 (valor -> VARIABLE .)
    LT              reduce using rule 107 (valor -> VARIABLE .)
    GT              reduce using rule 107 (valor -> VARIABLE .)
    LEQ             reduce using rule 107 (valor -> VARIABLE .)
    GEQ             reduce using rule 107 (valor -> VARIABLE .)
    COMMA           reduce using rule 107 (valor -> VARIABLE .)
    RPAREN          reduce using rule 107 (valor -> VARIABLE .)
    SEMICOLON       reduce using rule 107 (valor -> VARIABLE .)
    COLON           reduce using rule 107 (valor -> VARIABLE .)
    ARROW           shift and go to state 254
    EQUALS          shift and go to state 74


state 235

    (77) classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .

    VARIABLE        reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    ECHO            reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    PRINT           reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    INT             reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    FLOAT           reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    FUNCTION        reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    CLASS           reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    WHILE           reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    SWITCH          reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    IF              reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    FOR             reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    FOREACH         reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    $end            reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    RBRACE          reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    BREAK           reduce using rule 77 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)


state 236

    (48) while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .

    VARIABLE        reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    ECHO            reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    FLOAT           reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    FUNCTION        reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    CLASS           reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    SWITCH          reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    FOREACH         reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    BREAK           reduce using rule 48 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)


state 237

    (50) switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .

    VARIABLE        reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    ECHO            reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    PRINT           reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    INT             reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    FLOAT           reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    FUNCTION        reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    CLASS           reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    WHILE           reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    SWITCH          reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    IF              reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    FOR             reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    FOREACH         reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    $end            reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    RBRACE          reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    BREAK           reduce using rule 50 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)


state 238

    (52) caseLists -> cases default .

    RBRACE          reduce using rule 52 (caseLists -> cases default .)


state 239

    (56) cases -> case cases .

    DEFAULT         reduce using rule 56 (cases -> case cases .)
    RBRACE          reduce using rule 56 (cases -> case cases .)


state 240

    (59) default -> DEFAULT COLON . body BREAK SEMICOLON
    (99) body -> . sentencia
    (100) body -> . sentencia sentencias
    (101) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) sentencia -> . asignacion_fgets
    (139) empty -> .
    (12) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (13) impresion -> . ECHO imprimir SEMICOLON
    (14) impresion -> . PRINT imprimir SEMICOLON
    (119) comparacion -> . INT operador INT
    (120) comparacion -> . FLOAT operador FLOAT
    (121) comparacion -> . INT operador FLOAT
    (122) comparacion -> . FLOAT operador INT
    (15) estructurasProgram -> . controlStructure
    (16) estructurasProgram -> . dataStructure
    (17) estructurasProgram -> . funcionDeclarate
    (18) estructurasProgram -> . classDeclarate
    (8) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (19) controlStructure -> . if
    (20) controlStructure -> . for
    (21) controlStructure -> . while
    (22) controlStructure -> . switch
    (60) dataStructure -> . array
    (61) dataStructure -> . map
    (62) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (76) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (77) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (43) for -> . forStatement
    (48) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (50) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (90) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (44) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (45) forStatement -> . FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

    BREAK           reduce using rule 139 (empty -> .)
    VARIABLE        shift and go to state 8
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    FUNCTION        shift and go to state 23
    CLASS           shift and go to state 24
    WHILE           shift and go to state 27
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    FOREACH         shift and go to state 31

    body                           shift and go to state 255
    sentencia                      shift and go to state 86
    empty                          shift and go to state 87
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    asignacion_fgets               shift and go to state 7
    controlStructure               shift and go to state 13
    dataStructure                  shift and go to state 14
    funcionDeclarate               shift and go to state 15
    classDeclarate                 shift and go to state 16
    if                             shift and go to state 17
    for                            shift and go to state 18
    while                          shift and go to state 19
    switch                         shift and go to state 20
    array                          shift and go to state 21
    map                            shift and go to state 22
    statementif                    shift and go to state 25
    forStatement                   shift and go to state 26

state 241

    (58) case -> CASE valor . COLON body BREAK SEMICOLON

    COLON           shift and go to state 256


state 242

    (27) statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .

    ELSE            reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    ELSEIF          reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    VARIABLE        reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    ECHO            reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    FLOAT           reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    FUNCTION        reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    CLASS           reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    SWITCH          reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    FOREACH         reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    BREAK           reduce using rule 27 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)


state 243

    (44) forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .

    VARIABLE        reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    ECHO            reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    FLOAT           reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    FUNCTION        reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    CLASS           reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    SWITCH          reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    FOREACH         reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    BREAK           reduce using rule 44 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)


state 244

    (46) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE . opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (47) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE . opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS
    (32) opSymbol -> . EQ
    (33) opSymbol -> . NEQ
    (34) opSymbol -> . STRICTEQ
    (35) opSymbol -> . STRICTNEQ
    (36) opSymbol -> . LT
    (37) opSymbol -> . GT
    (38) opSymbol -> . LEQ
    (39) opSymbol -> . GEQ

    EQ              shift and go to state 134
    NEQ             shift and go to state 135
    STRICTEQ        shift and go to state 136
    STRICTNEQ       shift and go to state 137
    LT              shift and go to state 138
    GT              shift and go to state 139
    LEQ             shift and go to state 140
    GEQ             shift and go to state 141

    opSymbol                       shift and go to state 257

state 245

    (45) forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK . SEMICOLON RBRACE

    SEMICOLON       shift and go to state 258


state 246

    (75) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE . RETURN expresion SEMICOLON RBRACE SEMICOLON

    RETURN          shift and go to state 259


state 247

    (62) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .

    VARIABLE        reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    ECHO            reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    PRINT           reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    INT             reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    FLOAT           reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    FUNCTION        reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    CLASS           reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    WHILE           reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    SWITCH          reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    IF              reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    FOR             reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    FOREACH         reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    $end            reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    RBRACE          reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    BREAK           reduce using rule 62 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)


state 248

    (65) funcionBody -> RETURN expresion . SEMICOLON

    SEMICOLON       shift and go to state 260


state 249

    (63) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE . funcionBody RBRACE
    (64) funcionBody -> . body
    (65) funcionBody -> . RETURN expresion SEMICOLON
    (99) body -> . sentencia
    (100) body -> . sentencia sentencias
    (101) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) sentencia -> . asignacion_fgets
    (139) empty -> .
    (12) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (13) impresion -> . ECHO imprimir SEMICOLON
    (14) impresion -> . PRINT imprimir SEMICOLON
    (119) comparacion -> . INT operador INT
    (120) comparacion -> . FLOAT operador FLOAT
    (121) comparacion -> . INT operador FLOAT
    (122) comparacion -> . FLOAT operador INT
    (15) estructurasProgram -> . controlStructure
    (16) estructurasProgram -> . dataStructure
    (17) estructurasProgram -> . funcionDeclarate
    (18) estructurasProgram -> . classDeclarate
    (8) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (19) controlStructure -> . if
    (20) controlStructure -> . for
    (21) controlStructure -> . while
    (22) controlStructure -> . switch
    (60) dataStructure -> . array
    (61) dataStructure -> . map
    (62) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (76) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (77) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (43) for -> . forStatement
    (48) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (50) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (90) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (44) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (45) forStatement -> . FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

    RETURN          shift and go to state 222
    RBRACE          reduce using rule 139 (empty -> .)
    VARIABLE        shift and go to state 8
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    FUNCTION        shift and go to state 23
    CLASS           shift and go to state 24
    WHILE           shift and go to state 27
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    FOREACH         shift and go to state 31

    funcionBody                    shift and go to state 261
    body                           shift and go to state 221
    sentencia                      shift and go to state 86
    empty                          shift and go to state 87
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    asignacion_fgets               shift and go to state 7
    controlStructure               shift and go to state 13
    dataStructure                  shift and go to state 14
    funcionDeclarate               shift and go to state 15
    classDeclarate                 shift and go to state 16
    if                             shift and go to state 17
    for                            shift and go to state 18
    while                          shift and go to state 19
    switch                         shift and go to state 20
    array                          shift and go to state 21
    map                            shift and go to state 22
    statementif                    shift and go to state 25
    forStatement                   shift and go to state 26

state 250

    (81) classMember -> dataType FUNCTION ID LPAREN parametros . RPAREN brace

    RPAREN          shift and go to state 262


state 251

    (85) objectInstantiation -> NEW ID LPAREN argumentos RPAREN .

    INTEGER         reduce using rule 85 (objectInstantiation -> NEW ID LPAREN argumentos RPAREN .)
    FLOATING        reduce using rule 85 (objectInstantiation -> NEW ID LPAREN argumentos RPAREN .)
    STRINGS         reduce using rule 85 (objectInstantiation -> NEW ID LPAREN argumentos RPAREN .)
    BOOLEAN         reduce using rule 85 (objectInstantiation -> NEW ID LPAREN argumentos RPAREN .)
    VOID            reduce using rule 85 (objectInstantiation -> NEW ID LPAREN argumentos RPAREN .)
    NEW             reduce using rule 85 (objectInstantiation -> NEW ID LPAREN argumentos RPAREN .)
    RBRACE          reduce using rule 85 (objectInstantiation -> NEW ID LPAREN argumentos RPAREN .)


state 252

    (88) argumentos -> expresion COMMA . argumentos
    (87) argumentos -> . expresion
    (88) argumentos -> . expresion COMMA argumentos
    (89) argumentos -> . empty
    (128) expresion -> . valor
    (129) expresion -> . operaArit
    (130) expresion -> . conditionProdu
    (131) expresion -> . ternario
    (132) expresion -> . accessMember
    (139) empty -> .
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (125) operaArit -> . valor
    (126) operaArit -> . valor operador operaArit
    (127) operaArit -> . valor DOT valor
    (28) conditionProdu -> . condition
    (29) conditionProdu -> . condition opLogic condition conditionProdu
    (138) ternario -> . conditionProdu QUESTION expresion COLON expresion
    (83) accessMember -> . VARIABLE ARROW ID
    (84) accessMember -> . VARIABLE ARROW funcionParen
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON
    (30) condition -> . valor opSymbol valor
    (31) condition -> . LPAREN conditionProdu RPAREN

    RPAREN          reduce using rule 139 (empty -> .)
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 234
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47
    LPAREN          shift and go to state 89

    expresion                      shift and go to state 227
    argumentos                     shift and go to state 263
    empty                          shift and go to state 228
    valor                          shift and go to state 229
    operaArit                      shift and go to state 230
    conditionProdu                 shift and go to state 231
    ternario                       shift and go to state 232
    accessMember                   shift and go to state 233
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46
    condition                      shift and go to state 94

state 253

    (138) ternario -> conditionProdu QUESTION . expresion COLON expresion
    (128) expresion -> . valor
    (129) expresion -> . operaArit
    (130) expresion -> . conditionProdu
    (131) expresion -> . ternario
    (132) expresion -> . accessMember
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (125) operaArit -> . valor
    (126) operaArit -> . valor operador operaArit
    (127) operaArit -> . valor DOT valor
    (28) conditionProdu -> . condition
    (29) conditionProdu -> . condition opLogic condition conditionProdu
    (138) ternario -> . conditionProdu QUESTION expresion COLON expresion
    (83) accessMember -> . VARIABLE ARROW ID
    (84) accessMember -> . VARIABLE ARROW funcionParen
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON
    (30) condition -> . valor opSymbol valor
    (31) condition -> . LPAREN conditionProdu RPAREN

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 234
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47
    LPAREN          shift and go to state 89

    conditionProdu                 shift and go to state 231
    expresion                      shift and go to state 264
    valor                          shift and go to state 229
    operaArit                      shift and go to state 230
    ternario                       shift and go to state 232
    accessMember                   shift and go to state 233
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46
    condition                      shift and go to state 94

state 254

    (83) accessMember -> VARIABLE ARROW . ID
    (84) accessMember -> VARIABLE ARROW . funcionParen
    (74) funcionParen -> . ID LPAREN parametros RPAREN

    ID              shift and go to state 265

    funcionParen                   shift and go to state 266

state 255

    (59) default -> DEFAULT COLON body . BREAK SEMICOLON

    BREAK           shift and go to state 267


state 256

    (58) case -> CASE valor COLON . body BREAK SEMICOLON
    (99) body -> . sentencia
    (100) body -> . sentencia sentencias
    (101) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) sentencia -> . asignacion_fgets
    (139) empty -> .
    (12) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (13) impresion -> . ECHO imprimir SEMICOLON
    (14) impresion -> . PRINT imprimir SEMICOLON
    (119) comparacion -> . INT operador INT
    (120) comparacion -> . FLOAT operador FLOAT
    (121) comparacion -> . INT operador FLOAT
    (122) comparacion -> . FLOAT operador INT
    (15) estructurasProgram -> . controlStructure
    (16) estructurasProgram -> . dataStructure
    (17) estructurasProgram -> . funcionDeclarate
    (18) estructurasProgram -> . classDeclarate
    (8) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (19) controlStructure -> . if
    (20) controlStructure -> . for
    (21) controlStructure -> . while
    (22) controlStructure -> . switch
    (60) dataStructure -> . array
    (61) dataStructure -> . map
    (62) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (76) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (77) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (43) for -> . forStatement
    (48) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (50) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (90) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (44) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (45) forStatement -> . FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

    BREAK           reduce using rule 139 (empty -> .)
    VARIABLE        shift and go to state 8
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    FUNCTION        shift and go to state 23
    CLASS           shift and go to state 24
    WHILE           shift and go to state 27
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    FOREACH         shift and go to state 31

    body                           shift and go to state 268
    sentencia                      shift and go to state 86
    empty                          shift and go to state 87
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    asignacion_fgets               shift and go to state 7
    controlStructure               shift and go to state 13
    dataStructure                  shift and go to state 14
    funcionDeclarate               shift and go to state 15
    classDeclarate                 shift and go to state 16
    if                             shift and go to state 17
    for                            shift and go to state 18
    while                          shift and go to state 19
    switch                         shift and go to state 20
    array                          shift and go to state 21
    map                            shift and go to state 22
    statementif                    shift and go to state 25
    forStatement                   shift and go to state 26

state 257

    (46) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol . INT SEMICOLON VARIABLE DOUBLEPLUS
    (47) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol . INT SEMICOLON VARIABLE DOUBLEMINUS

    INT             shift and go to state 269


state 258

    (45) forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON . RBRACE

    RBRACE          shift and go to state 270


state 259

    (75) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN . expresion SEMICOLON RBRACE SEMICOLON
    (128) expresion -> . valor
    (129) expresion -> . operaArit
    (130) expresion -> . conditionProdu
    (131) expresion -> . ternario
    (132) expresion -> . accessMember
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (125) operaArit -> . valor
    (126) operaArit -> . valor operador operaArit
    (127) operaArit -> . valor DOT valor
    (28) conditionProdu -> . condition
    (29) conditionProdu -> . condition opLogic condition conditionProdu
    (138) ternario -> . conditionProdu QUESTION expresion COLON expresion
    (83) accessMember -> . VARIABLE ARROW ID
    (84) accessMember -> . VARIABLE ARROW funcionParen
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON
    (30) condition -> . valor opSymbol valor
    (31) condition -> . LPAREN conditionProdu RPAREN

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 234
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47
    LPAREN          shift and go to state 89

    expresion                      shift and go to state 271
    valor                          shift and go to state 229
    operaArit                      shift and go to state 230
    conditionProdu                 shift and go to state 231
    ternario                       shift and go to state 232
    accessMember                   shift and go to state 233
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46
    condition                      shift and go to state 94

state 260

    (65) funcionBody -> RETURN expresion SEMICOLON .

    RBRACE          reduce using rule 65 (funcionBody -> RETURN expresion SEMICOLON .)


state 261

    (63) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody . RBRACE

    RBRACE          shift and go to state 272


state 262

    (81) classMember -> dataType FUNCTION ID LPAREN parametros RPAREN . brace
    (73) brace -> . LBRACE body RBRACE

    LBRACE          shift and go to state 274

    brace                          shift and go to state 273

state 263

    (88) argumentos -> expresion COMMA argumentos .

    RPAREN          reduce using rule 88 (argumentos -> expresion COMMA argumentos .)


state 264

    (138) ternario -> conditionProdu QUESTION expresion . COLON expresion

    COLON           shift and go to state 275


state 265

    (83) accessMember -> VARIABLE ARROW ID .
    (74) funcionParen -> ID . LPAREN parametros RPAREN

    COMMA           reduce using rule 83 (accessMember -> VARIABLE ARROW ID .)
    RPAREN          reduce using rule 83 (accessMember -> VARIABLE ARROW ID .)
    SEMICOLON       reduce using rule 83 (accessMember -> VARIABLE ARROW ID .)
    COLON           reduce using rule 83 (accessMember -> VARIABLE ARROW ID .)
    LPAREN          shift and go to state 75


state 266

    (84) accessMember -> VARIABLE ARROW funcionParen .

    COMMA           reduce using rule 84 (accessMember -> VARIABLE ARROW funcionParen .)
    RPAREN          reduce using rule 84 (accessMember -> VARIABLE ARROW funcionParen .)
    SEMICOLON       reduce using rule 84 (accessMember -> VARIABLE ARROW funcionParen .)
    COLON           reduce using rule 84 (accessMember -> VARIABLE ARROW funcionParen .)


state 267

    (59) default -> DEFAULT COLON body BREAK . SEMICOLON

    SEMICOLON       shift and go to state 276


state 268

    (58) case -> CASE valor COLON body . BREAK SEMICOLON

    BREAK           shift and go to state 277


state 269

    (46) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT . SEMICOLON VARIABLE DOUBLEPLUS
    (47) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT . SEMICOLON VARIABLE DOUBLEMINUS

    SEMICOLON       shift and go to state 278


state 270

    (45) forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .

    VARIABLE        reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)
    ECHO            reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)
    PRINT           reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)
    INT             reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)
    FLOAT           reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)
    FUNCTION        reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)
    CLASS           reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)
    WHILE           reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)
    SWITCH          reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)
    IF              reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)
    FOR             reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)
    FOREACH         reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)
    $end            reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)
    RBRACE          reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)
    BREAK           reduce using rule 45 (forStatement -> FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE .)


state 271

    (75) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion . SEMICOLON RBRACE SEMICOLON

    SEMICOLON       shift and go to state 279


state 272

    (63) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .

    VARIABLE        reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    ECHO            reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    PRINT           reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    INT             reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    FLOAT           reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    FUNCTION        reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    CLASS           reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    WHILE           reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    SWITCH          reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    IF              reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    FOR             reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    FOREACH         reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    $end            reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    RBRACE          reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    BREAK           reduce using rule 63 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)


state 273

    (81) classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .

    INTEGER         reduce using rule 81 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    FLOATING        reduce using rule 81 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    STRINGS         reduce using rule 81 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    BOOLEAN         reduce using rule 81 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    VOID            reduce using rule 81 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    NEW             reduce using rule 81 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    RBRACE          reduce using rule 81 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)


state 274

    (73) brace -> LBRACE . body RBRACE
    (99) body -> . sentencia
    (100) body -> . sentencia sentencias
    (101) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (7) sentencia -> . asignacion_fgets
    (139) empty -> .
    (12) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (13) impresion -> . ECHO imprimir SEMICOLON
    (14) impresion -> . PRINT imprimir SEMICOLON
    (119) comparacion -> . INT operador INT
    (120) comparacion -> . FLOAT operador FLOAT
    (121) comparacion -> . INT operador FLOAT
    (122) comparacion -> . FLOAT operador INT
    (15) estructurasProgram -> . controlStructure
    (16) estructurasProgram -> . dataStructure
    (17) estructurasProgram -> . funcionDeclarate
    (18) estructurasProgram -> . classDeclarate
    (8) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (19) controlStructure -> . if
    (20) controlStructure -> . for
    (21) controlStructure -> . while
    (22) controlStructure -> . switch
    (60) dataStructure -> . array
    (61) dataStructure -> . map
    (62) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (63) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (76) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (77) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (23) if -> . statementif ELSE body
    (24) if -> . statementif ELSE if
    (25) if -> . statementif ELSEIF if
    (26) if -> . statementif
    (43) for -> . forStatement
    (48) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (49) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (50) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (51) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (90) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (91) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (92) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (93) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (94) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (95) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (27) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (44) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (45) forStatement -> . FOREACH LPAREN forcondition RPAREN LBRACE body BREAK SEMICOLON RBRACE

    RBRACE          reduce using rule 139 (empty -> .)
    VARIABLE        shift and go to state 8
    ECHO            shift and go to state 9
    PRINT           shift and go to state 10
    INT             shift and go to state 11
    FLOAT           shift and go to state 12
    FUNCTION        shift and go to state 23
    CLASS           shift and go to state 24
    WHILE           shift and go to state 27
    SWITCH          shift and go to state 28
    IF              shift and go to state 29
    FOR             shift and go to state 30
    FOREACH         shift and go to state 31

    body                           shift and go to state 280
    sentencia                      shift and go to state 86
    empty                          shift and go to state 87
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    asignacion_fgets               shift and go to state 7
    controlStructure               shift and go to state 13
    dataStructure                  shift and go to state 14
    funcionDeclarate               shift and go to state 15
    classDeclarate                 shift and go to state 16
    if                             shift and go to state 17
    for                            shift and go to state 18
    while                          shift and go to state 19
    switch                         shift and go to state 20
    array                          shift and go to state 21
    map                            shift and go to state 22
    statementif                    shift and go to state 25
    forStatement                   shift and go to state 26

state 275

    (138) ternario -> conditionProdu QUESTION expresion COLON . expresion
    (128) expresion -> . valor
    (129) expresion -> . operaArit
    (130) expresion -> . conditionProdu
    (131) expresion -> . ternario
    (132) expresion -> . accessMember
    (105) valor -> . INT
    (106) valor -> . FLOAT
    (107) valor -> . VARIABLE
    (108) valor -> . STRING
    (109) valor -> . TRUE
    (110) valor -> . FALSE
    (111) valor -> . THIS
    (112) valor -> . funcionParen
    (113) valor -> . funcionAnonima
    (125) operaArit -> . valor
    (126) operaArit -> . valor operador operaArit
    (127) operaArit -> . valor DOT valor
    (28) conditionProdu -> . condition
    (29) conditionProdu -> . condition opLogic condition conditionProdu
    (138) ternario -> . conditionProdu QUESTION expresion COLON expresion
    (83) accessMember -> . VARIABLE ARROW ID
    (84) accessMember -> . VARIABLE ARROW funcionParen
    (74) funcionParen -> . ID LPAREN parametros RPAREN
    (75) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON
    (30) condition -> . valor opSymbol valor
    (31) condition -> . LPAREN conditionProdu RPAREN

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    VARIABLE        shift and go to state 234
    STRING          shift and go to state 41
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    THIS            shift and go to state 44
    ID              shift and go to state 47
    LPAREN          shift and go to state 89

    conditionProdu                 shift and go to state 231
    expresion                      shift and go to state 281
    valor                          shift and go to state 229
    operaArit                      shift and go to state 230
    ternario                       shift and go to state 232
    accessMember                   shift and go to state 233
    funcionParen                   shift and go to state 45
    funcionAnonima                 shift and go to state 46
    condition                      shift and go to state 94

state 276

    (59) default -> DEFAULT COLON body BREAK SEMICOLON .

    RBRACE          reduce using rule 59 (default -> DEFAULT COLON body BREAK SEMICOLON .)


state 277

    (58) case -> CASE valor COLON body BREAK . SEMICOLON

    SEMICOLON       shift and go to state 282


state 278

    (46) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON . VARIABLE DOUBLEPLUS
    (47) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON . VARIABLE DOUBLEMINUS

    VARIABLE        shift and go to state 283


state 279

    (75) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON . RBRACE SEMICOLON

    RBRACE          shift and go to state 284


state 280

    (73) brace -> LBRACE body . RBRACE

    RBRACE          shift and go to state 285


state 281

    (138) ternario -> conditionProdu QUESTION expresion COLON expresion .

    COMMA           reduce using rule 138 (ternario -> conditionProdu QUESTION expresion COLON expresion .)
    RPAREN          reduce using rule 138 (ternario -> conditionProdu QUESTION expresion COLON expresion .)
    SEMICOLON       reduce using rule 138 (ternario -> conditionProdu QUESTION expresion COLON expresion .)
    COLON           reduce using rule 138 (ternario -> conditionProdu QUESTION expresion COLON expresion .)


state 282

    (58) case -> CASE valor COLON body BREAK SEMICOLON .

    CASE            reduce using rule 58 (case -> CASE valor COLON body BREAK SEMICOLON .)
    DEFAULT         reduce using rule 58 (case -> CASE valor COLON body BREAK SEMICOLON .)
    RBRACE          reduce using rule 58 (case -> CASE valor COLON body BREAK SEMICOLON .)


state 283

    (46) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE . DOUBLEPLUS
    (47) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE . DOUBLEMINUS

    DOUBLEPLUS      shift and go to state 286
    DOUBLEMINUS     shift and go to state 287


state 284

    (75) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 288


state 285

    (73) brace -> LBRACE body RBRACE .

    INTEGER         reduce using rule 73 (brace -> LBRACE body RBRACE .)
    FLOATING        reduce using rule 73 (brace -> LBRACE body RBRACE .)
    STRINGS         reduce using rule 73 (brace -> LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 73 (brace -> LBRACE body RBRACE .)
    VOID            reduce using rule 73 (brace -> LBRACE body RBRACE .)
    NEW             reduce using rule 73 (brace -> LBRACE body RBRACE .)
    RBRACE          reduce using rule 73 (brace -> LBRACE body RBRACE .)


state 286

    (46) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS .

    RPAREN          reduce using rule 46 (forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS .)


state 287

    (47) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS .

    RPAREN          reduce using rule 47 (forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS .)


state 288

    (75) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .

    COMMA           reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    SEMICOLON       reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    DOT             reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    PLUS            reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    MINUS           reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    TIMES           reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    DIVIDE          reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    MODULO          reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    RPAREN          reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    EQ              reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    NEQ             reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    STRICTEQ        reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    STRICTNEQ       reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    LT              reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    GT              reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    LEQ             reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    GEQ             reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    ARROWMAP        reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    RBRACKET        reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    COLON           reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    AND             reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    OR              reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    NOT             reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    LPAREN          reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    INT             reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    FLOAT           reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    VARIABLE        reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    STRING          reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    TRUE            reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    FALSE           reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    THIS            reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    ID              reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    QUESTION        reduce using rule 75 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 58 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 58 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 58 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 58 resolved as shift
WARNING: shift/reduce conflict for INT in state 58 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 58 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 58 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 58 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 58 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 58 resolved as shift
WARNING: shift/reduce conflict for FOR in state 58 resolved as shift
WARNING: shift/reduce conflict for FOREACH in state 58 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 86 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 86 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 86 resolved as shift
WARNING: shift/reduce conflict for INT in state 86 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 86 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 86 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 86 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 86 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 86 resolved as shift
WARNING: shift/reduce conflict for IF in state 86 resolved as shift
WARNING: shift/reduce conflict for FOR in state 86 resolved as shift
WARNING: shift/reduce conflict for FOREACH in state 86 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 128 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 128 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 128 resolved as shift
WARNING: shift/reduce conflict for INT in state 128 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 128 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 128 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 128 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 128 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 128 resolved as shift
WARNING: shift/reduce conflict for IF in state 128 resolved as shift
WARNING: shift/reduce conflict for FOR in state 128 resolved as shift
WARNING: shift/reduce conflict for FOREACH in state 128 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 174 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 176 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 198 resolved as shift
WARNING: reduce/reduce conflict in state 85 resolved using rule (controlStructure -> if)
WARNING: rejected rule (if -> statementif ELSE if) in state 85
WARNING: reduce/reduce conflict in state 86 resolved using rule (body -> sentencia)
WARNING: rejected rule (empty -> <empty>) in state 86
WARNING: reduce/reduce conflict in state 128 resolved using rule (sentencias -> sentencia)
WARNING: rejected rule (empty -> <empty>) in state 128
WARNING: reduce/reduce conflict in state 184 resolved using rule (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON)
WARNING: rejected rule (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON) in state 184
WARNING: reduce/reduce conflict in state 217 resolved using rule (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON)
WARNING: rejected rule (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON) in state 217
WARNING: reduce/reduce conflict in state 229 resolved using rule (operaArit -> valor)
WARNING: rejected rule (expresion -> valor) in state 229
WARNING: Rule (if -> statementif ELSE if) is never reduced
WARNING: Rule (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON) is never reduced
WARNING: Rule (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON) is never reduced
WARNING: Rule (expresion -> valor) is never reduced
