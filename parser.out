Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    ARROW
    AS
    BOOL
    CLASS
    CONCATENATEEQUAL
    CONST
    DO
    DOT
    EMPTY
    ENDSWITCH
    EXTENDS
    FINAL
    FN
    FOREACH
    FUNCTION
    ID
    IMPLEMENTS
    INCLUDE
    INSTANCEOF
    INTERFACE
    MINUSEQUAL
    NAMESPACE
    NEW
    NULL
    PLUSEQUAL
    POTENCIA
    PRIVATE
    PROTECTED
    PUBLIC
    QUESTION
    RETURN
    STATIC
    THIS
    THROW
    VOID

Grammar

Rule 0     S' -> inicio
Rule 1     inicio -> OPENTAG programa CLOSETAG
Rule 2     programa -> sentencia
Rule 3     programa -> sentencia programa
Rule 4     sentencia -> asignacion
Rule 5     sentencia -> asignacion_fgets
Rule 6     sentencia -> comparacion
Rule 7     sentencia -> impresion
Rule 8     sentencia -> estructurasPrograma
Rule 9     sentencia -> try
Rule 10    asignacion -> VARIABLE EQUALS operaArit SEMICOLON
Rule 11    asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
Rule 12    operaArit -> valor
Rule 13    operaArit -> valor operador operaArit
Rule 14    valor -> INT
Rule 15    valor -> FLOAT
Rule 16    valor -> VARIABLE
Rule 17    valor -> STRING
Rule 18    operador -> PLUS
Rule 19    operador -> MINUS
Rule 20    operador -> TIMES
Rule 21    operador -> DIVIDE
Rule 22    operador -> MODULO
Rule 23    comparacion -> valor comparador valor
Rule 24    comparador -> LT
Rule 25    comparador -> GT
Rule 26    comparador -> LEQ
Rule 27    comparador -> GEQ
Rule 28    impresion -> ECHO imprimir SEMICOLON
Rule 29    impresion -> PRINT imprimir SEMICOLON
Rule 30    imprimir -> LPAREN repiteValores RPAREN
Rule 31    imprimir -> LPAREN RPAREN
Rule 32    imprimir -> repiteValores
Rule 33    imprimir -> empty
Rule 34    repiteValores -> valor
Rule 35    repiteValores -> valor COMMA repiteValores
Rule 36    empty -> <empty>
Rule 37    estructurasPrograma -> controlStructure
Rule 38    estructurasPrograma -> dataStructure
Rule 39    controlStructure -> if
Rule 40    controlStructure -> for
Rule 41    controlStructure -> while
Rule 42    controlStructure -> switch
Rule 43    if -> IF LPAREN conditions RPAREN LBRACE body RBRACE
Rule 44    if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
Rule 45    else_blocks -> ELSE LBRACE body RBRACE
Rule 46    else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
Rule 47    conditions -> condition
Rule 48    conditions -> condition opLogic conditions
Rule 49    condition -> valor opSymbol valor
Rule 50    opSymbol -> EQ
Rule 51    opSymbol -> NEQ
Rule 52    opSymbol -> STRICTEQ
Rule 53    opSymbol -> STRICTNEQ
Rule 54    opSymbol -> LT
Rule 55    opSymbol -> GT
Rule 56    opSymbol -> LEQ
Rule 57    opSymbol -> GEQ
Rule 58    opLogic -> AND
Rule 59    opLogic -> LOGICAL_AND
Rule 60    opLogic -> OR
Rule 61    opLogic -> LOGICAL_OR
Rule 62    opLogic -> NOT
Rule 63    opLogic -> LOGICAL_NOT
Rule 64    body -> sentenciaList
Rule 65    body -> empty
Rule 66    sentenciaList -> sentencia
Rule 67    sentenciaList -> sentencia sentenciaList
Rule 68    for -> forStatement
Rule 69    forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE
Rule 70    forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
Rule 71    forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS
Rule 72    while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE
Rule 73    while -> WHILE LPAREN condition RPAREN LBRACE RBRACE
Rule 74    switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE
Rule 75    caseLists -> cases
Rule 76    caseLists -> cases default
Rule 77    caseLists -> default
Rule 78    caseLists -> empty
Rule 79    cases -> case
Rule 80    cases -> case cases
Rule 81    case -> CASE valor COLON body BREAK SEMICOLON
Rule 82    dataStructure -> array
Rule 83    array -> VARIABLE EQUALS arrays SEMICOLON
Rule 84    array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
Rule 85    array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
Rule 86    array -> map
Rule 87    arrays -> LBRACKET repiteValores RBRACKET
Rule 88    arrayAnidado -> arrays
Rule 89    arrayAnidado -> arrays COMMA arrayAnidado
Rule 90    map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON
Rule 91    map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON
Rule 92    maps -> mapArrow
Rule 93    maps -> mapArrow COMMA maps
Rule 94    mapArrow -> valor ARROWMAP valor
Rule 95    default -> DEFAULT COLON body BREAK SEMICOLON
Rule 96    try -> TRY LBRACE body RBRACE catchs
Rule 97    try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE
Rule 98    catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE
Rule 99    catchs -> catch
Rule 100   catchs -> catch catchs
Rule 101   objeto -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 58
ARRAY                : 85 91
ARROW                : 
ARROWMAP             : 94
AS                   : 
BOOL                 : 
BREAK                : 81 95
CASE                 : 81
CATCH                : 98
CLASS                : 
CLOSETAG             : 1
COLON                : 81 95
COMMA                : 35 89 93
CONCATENATEEQUAL     : 
CONST                : 
DEFAULT              : 95
DIVIDE               : 21
DO                   : 
DOT                  : 
DOUBLEMINUS          : 71
DOUBLEPLUS           : 70
ECHO                 : 28
ELSE                 : 45
ELSEIF               : 46
EMPTY                : 
ENDSWITCH            : 
EQ                   : 50
EQUALS               : 10 11 70 71 83 84 85 90 91
EXCEPTION            : 98
EXTENDS              : 
FGETS                : 11
FINAL                : 
FINALLY              : 97
FLOAT                : 15
FN                   : 
FOR                  : 69
FOREACH              : 
FUNCTION             : 
GEQ                  : 27 57
GT                   : 25 55
ID                   : 
IF                   : 43 44
IMPLEMENTS           : 
INCLUDE              : 
INSTANCEOF           : 
INT                  : 14 70 70 71 71
INTERFACE            : 
LBRACE               : 43 44 45 46 69 72 73 74 96 97 97 98
LBRACKET             : 84 87 90
LEQ                  : 26 56
LOGICAL_AND          : 59
LOGICAL_NOT          : 63
LOGICAL_OR           : 61
LPAREN               : 11 30 31 43 44 46 69 72 73 74 85 91 98
LT                   : 24 54
MINUS                : 19
MINUSEQUAL           : 
MODULO               : 22
NAMESPACE            : 
NEQ                  : 51
NEW                  : 
NOT                  : 62
NULL                 : 
OPENTAG              : 1
OR                   : 60
PLUS                 : 18
PLUSEQUAL            : 
POTENCIA             : 
PRINT                : 29
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
QUESTION             : 
RBRACE               : 43 44 45 46 69 72 73 74 96 97 97 98
RBRACKET             : 84 87 90
RETURN               : 
RPAREN               : 11 30 31 43 44 46 69 72 73 74 85 91 98
SEMICOLON            : 10 11 28 29 70 70 71 71 81 83 84 85 90 91 95
STATIC               : 
STDIN                : 11
STRICTEQ             : 52
STRICTNEQ            : 53
STRING               : 17
SWITCH               : 74
THIS                 : 
THROW                : 
TIMES                : 20
TRY                  : 96 97
VARIABLE             : 10 11 16 70 70 70 71 71 71 83 84 85 90 91 98
VOID                 : 
WHILE                : 72 73
error                : 

Nonterminals, with rules where they appear

array                : 82
arrayAnidado         : 84 89
arrays               : 83 88 89
asignacion           : 4
asignacion_fgets     : 5
body                 : 43 44 45 46 69 72 81 95 96 97 97 98
case                 : 79 80
caseLists            : 74
cases                : 75 76 80
catch                : 99 100
catchs               : 96 97 100
comparacion          : 6
comparador           : 23
condition            : 47 48 72 73
conditions           : 43 44 46 48
controlStructure     : 37
dataStructure        : 38
default              : 76 77
else_blocks          : 44 46
empty                : 33 65 78
estructurasPrograma  : 8
for                  : 40
forStatement         : 68
forcondition         : 69
if                   : 39
impresion            : 7
imprimir             : 28 29
inicio               : 0
map                  : 86
mapArrow             : 92 93
maps                 : 90 91 93
objeto               : 
opLogic              : 48
opSymbol             : 49 70 71
operaArit            : 10 13
operador             : 13
programa             : 1 3
repiteValores        : 30 32 35 85 87
sentencia            : 2 3 66 67
sentenciaList        : 64 67
switch               : 42
try                  : 9
valor                : 12 13 23 23 34 35 49 49 74 81 94 94
while                : 41

Parsing method: LALR

state 0

    (0) S' -> . inicio
    (1) inicio -> . OPENTAG programa CLOSETAG

    OPENTAG         shift and go to state 2

    inicio                         shift and go to state 1

state 1

    (0) S' -> inicio .



state 2

    (1) inicio -> OPENTAG . programa CLOSETAG
    (2) programa -> . sentencia
    (3) programa -> . sentencia programa
    (4) sentencia -> . asignacion
    (5) sentencia -> . asignacion_fgets
    (6) sentencia -> . comparacion
    (7) sentencia -> . impresion
    (8) sentencia -> . estructurasPrograma
    (9) sentencia -> . try
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (23) comparacion -> . valor comparador valor
    (28) impresion -> . ECHO imprimir SEMICOLON
    (29) impresion -> . PRINT imprimir SEMICOLON
    (37) estructurasPrograma -> . controlStructure
    (38) estructurasPrograma -> . dataStructure
    (96) try -> . TRY LBRACE body RBRACE catchs
    (97) try -> . TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING
    (39) controlStructure -> . if
    (40) controlStructure -> . for
    (41) controlStructure -> . while
    (42) controlStructure -> . switch
    (82) dataStructure -> . array
    (43) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE
    (44) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
    (68) for -> . forStatement
    (72) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (73) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (74) switch -> . SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE
    (83) array -> . VARIABLE EQUALS arrays SEMICOLON
    (84) array -> . VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (86) array -> . map
    (69) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (90) map -> . VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON
    (91) map -> . VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON

    VARIABLE        shift and go to state 11
    ECHO            shift and go to state 13
    PRINT           shift and go to state 14
    TRY             shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    SWITCH          shift and go to state 29
    FOR             shift and go to state 31

    programa                       shift and go to state 3
    sentencia                      shift and go to state 4
    asignacion                     shift and go to state 5
    asignacion_fgets               shift and go to state 6
    comparacion                    shift and go to state 7
    impresion                      shift and go to state 8
    estructurasPrograma            shift and go to state 9
    try                            shift and go to state 10
    valor                          shift and go to state 12
    controlStructure               shift and go to state 15
    dataStructure                  shift and go to state 16
    if                             shift and go to state 21
    for                            shift and go to state 22
    while                          shift and go to state 23
    switch                         shift and go to state 24
    array                          shift and go to state 25
    forStatement                   shift and go to state 27
    map                            shift and go to state 30

state 3

    (1) inicio -> OPENTAG programa . CLOSETAG

    CLOSETAG        shift and go to state 32


state 4

    (2) programa -> sentencia .
    (3) programa -> sentencia . programa
    (2) programa -> . sentencia
    (3) programa -> . sentencia programa
    (4) sentencia -> . asignacion
    (5) sentencia -> . asignacion_fgets
    (6) sentencia -> . comparacion
    (7) sentencia -> . impresion
    (8) sentencia -> . estructurasPrograma
    (9) sentencia -> . try
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (23) comparacion -> . valor comparador valor
    (28) impresion -> . ECHO imprimir SEMICOLON
    (29) impresion -> . PRINT imprimir SEMICOLON
    (37) estructurasPrograma -> . controlStructure
    (38) estructurasPrograma -> . dataStructure
    (96) try -> . TRY LBRACE body RBRACE catchs
    (97) try -> . TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING
    (39) controlStructure -> . if
    (40) controlStructure -> . for
    (41) controlStructure -> . while
    (42) controlStructure -> . switch
    (82) dataStructure -> . array
    (43) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE
    (44) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
    (68) for -> . forStatement
    (72) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (73) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (74) switch -> . SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE
    (83) array -> . VARIABLE EQUALS arrays SEMICOLON
    (84) array -> . VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (86) array -> . map
    (69) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (90) map -> . VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON
    (91) map -> . VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON

    CLOSETAG        reduce using rule 2 (programa -> sentencia .)
    VARIABLE        shift and go to state 11
    ECHO            shift and go to state 13
    PRINT           shift and go to state 14
    TRY             shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    SWITCH          shift and go to state 29
    FOR             shift and go to state 31

    sentencia                      shift and go to state 4
    programa                       shift and go to state 33
    asignacion                     shift and go to state 5
    asignacion_fgets               shift and go to state 6
    comparacion                    shift and go to state 7
    impresion                      shift and go to state 8
    estructurasPrograma            shift and go to state 9
    try                            shift and go to state 10
    valor                          shift and go to state 12
    controlStructure               shift and go to state 15
    dataStructure                  shift and go to state 16
    if                             shift and go to state 21
    for                            shift and go to state 22
    while                          shift and go to state 23
    switch                         shift and go to state 24
    array                          shift and go to state 25
    forStatement                   shift and go to state 27
    map                            shift and go to state 30

state 5

    (4) sentencia -> asignacion .

    VARIABLE        reduce using rule 4 (sentencia -> asignacion .)
    ECHO            reduce using rule 4 (sentencia -> asignacion .)
    PRINT           reduce using rule 4 (sentencia -> asignacion .)
    TRY             reduce using rule 4 (sentencia -> asignacion .)
    INT             reduce using rule 4 (sentencia -> asignacion .)
    FLOAT           reduce using rule 4 (sentencia -> asignacion .)
    STRING          reduce using rule 4 (sentencia -> asignacion .)
    IF              reduce using rule 4 (sentencia -> asignacion .)
    WHILE           reduce using rule 4 (sentencia -> asignacion .)
    SWITCH          reduce using rule 4 (sentencia -> asignacion .)
    FOR             reduce using rule 4 (sentencia -> asignacion .)
    CLOSETAG        reduce using rule 4 (sentencia -> asignacion .)
    RBRACE          reduce using rule 4 (sentencia -> asignacion .)
    BREAK           reduce using rule 4 (sentencia -> asignacion .)


state 6

    (5) sentencia -> asignacion_fgets .

    VARIABLE        reduce using rule 5 (sentencia -> asignacion_fgets .)
    ECHO            reduce using rule 5 (sentencia -> asignacion_fgets .)
    PRINT           reduce using rule 5 (sentencia -> asignacion_fgets .)
    TRY             reduce using rule 5 (sentencia -> asignacion_fgets .)
    INT             reduce using rule 5 (sentencia -> asignacion_fgets .)
    FLOAT           reduce using rule 5 (sentencia -> asignacion_fgets .)
    STRING          reduce using rule 5 (sentencia -> asignacion_fgets .)
    IF              reduce using rule 5 (sentencia -> asignacion_fgets .)
    WHILE           reduce using rule 5 (sentencia -> asignacion_fgets .)
    SWITCH          reduce using rule 5 (sentencia -> asignacion_fgets .)
    FOR             reduce using rule 5 (sentencia -> asignacion_fgets .)
    CLOSETAG        reduce using rule 5 (sentencia -> asignacion_fgets .)
    RBRACE          reduce using rule 5 (sentencia -> asignacion_fgets .)
    BREAK           reduce using rule 5 (sentencia -> asignacion_fgets .)


state 7

    (6) sentencia -> comparacion .

    VARIABLE        reduce using rule 6 (sentencia -> comparacion .)
    ECHO            reduce using rule 6 (sentencia -> comparacion .)
    PRINT           reduce using rule 6 (sentencia -> comparacion .)
    TRY             reduce using rule 6 (sentencia -> comparacion .)
    INT             reduce using rule 6 (sentencia -> comparacion .)
    FLOAT           reduce using rule 6 (sentencia -> comparacion .)
    STRING          reduce using rule 6 (sentencia -> comparacion .)
    IF              reduce using rule 6 (sentencia -> comparacion .)
    WHILE           reduce using rule 6 (sentencia -> comparacion .)
    SWITCH          reduce using rule 6 (sentencia -> comparacion .)
    FOR             reduce using rule 6 (sentencia -> comparacion .)
    CLOSETAG        reduce using rule 6 (sentencia -> comparacion .)
    RBRACE          reduce using rule 6 (sentencia -> comparacion .)
    BREAK           reduce using rule 6 (sentencia -> comparacion .)


state 8

    (7) sentencia -> impresion .

    VARIABLE        reduce using rule 7 (sentencia -> impresion .)
    ECHO            reduce using rule 7 (sentencia -> impresion .)
    PRINT           reduce using rule 7 (sentencia -> impresion .)
    TRY             reduce using rule 7 (sentencia -> impresion .)
    INT             reduce using rule 7 (sentencia -> impresion .)
    FLOAT           reduce using rule 7 (sentencia -> impresion .)
    STRING          reduce using rule 7 (sentencia -> impresion .)
    IF              reduce using rule 7 (sentencia -> impresion .)
    WHILE           reduce using rule 7 (sentencia -> impresion .)
    SWITCH          reduce using rule 7 (sentencia -> impresion .)
    FOR             reduce using rule 7 (sentencia -> impresion .)
    CLOSETAG        reduce using rule 7 (sentencia -> impresion .)
    RBRACE          reduce using rule 7 (sentencia -> impresion .)
    BREAK           reduce using rule 7 (sentencia -> impresion .)


state 9

    (8) sentencia -> estructurasPrograma .

    VARIABLE        reduce using rule 8 (sentencia -> estructurasPrograma .)
    ECHO            reduce using rule 8 (sentencia -> estructurasPrograma .)
    PRINT           reduce using rule 8 (sentencia -> estructurasPrograma .)
    TRY             reduce using rule 8 (sentencia -> estructurasPrograma .)
    INT             reduce using rule 8 (sentencia -> estructurasPrograma .)
    FLOAT           reduce using rule 8 (sentencia -> estructurasPrograma .)
    STRING          reduce using rule 8 (sentencia -> estructurasPrograma .)
    IF              reduce using rule 8 (sentencia -> estructurasPrograma .)
    WHILE           reduce using rule 8 (sentencia -> estructurasPrograma .)
    SWITCH          reduce using rule 8 (sentencia -> estructurasPrograma .)
    FOR             reduce using rule 8 (sentencia -> estructurasPrograma .)
    CLOSETAG        reduce using rule 8 (sentencia -> estructurasPrograma .)
    RBRACE          reduce using rule 8 (sentencia -> estructurasPrograma .)
    BREAK           reduce using rule 8 (sentencia -> estructurasPrograma .)


state 10

    (9) sentencia -> try .

    VARIABLE        reduce using rule 9 (sentencia -> try .)
    ECHO            reduce using rule 9 (sentencia -> try .)
    PRINT           reduce using rule 9 (sentencia -> try .)
    TRY             reduce using rule 9 (sentencia -> try .)
    INT             reduce using rule 9 (sentencia -> try .)
    FLOAT           reduce using rule 9 (sentencia -> try .)
    STRING          reduce using rule 9 (sentencia -> try .)
    IF              reduce using rule 9 (sentencia -> try .)
    WHILE           reduce using rule 9 (sentencia -> try .)
    SWITCH          reduce using rule 9 (sentencia -> try .)
    FOR             reduce using rule 9 (sentencia -> try .)
    CLOSETAG        reduce using rule 9 (sentencia -> try .)
    RBRACE          reduce using rule 9 (sentencia -> try .)
    BREAK           reduce using rule 9 (sentencia -> try .)


state 11

    (10) asignacion -> VARIABLE . EQUALS operaArit SEMICOLON
    (11) asignacion_fgets -> VARIABLE . EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (16) valor -> VARIABLE .
    (83) array -> VARIABLE . EQUALS arrays SEMICOLON
    (84) array -> VARIABLE . EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> VARIABLE . EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (90) map -> VARIABLE . EQUALS LBRACKET maps RBRACKET SEMICOLON
    (91) map -> VARIABLE . EQUALS ARRAY LPAREN maps RPAREN SEMICOLON

    EQUALS          shift and go to state 34
    LT              reduce using rule 16 (valor -> VARIABLE .)
    GT              reduce using rule 16 (valor -> VARIABLE .)
    LEQ             reduce using rule 16 (valor -> VARIABLE .)
    GEQ             reduce using rule 16 (valor -> VARIABLE .)


state 12

    (23) comparacion -> valor . comparador valor
    (24) comparador -> . LT
    (25) comparador -> . GT
    (26) comparador -> . LEQ
    (27) comparador -> . GEQ

    LT              shift and go to state 36
    GT              shift and go to state 37
    LEQ             shift and go to state 38
    GEQ             shift and go to state 39

    comparador                     shift and go to state 35

state 13

    (28) impresion -> ECHO . imprimir SEMICOLON
    (30) imprimir -> . LPAREN repiteValores RPAREN
    (31) imprimir -> . LPAREN RPAREN
    (32) imprimir -> . repiteValores
    (33) imprimir -> . empty
    (34) repiteValores -> . valor
    (35) repiteValores -> . valor COMMA repiteValores
    (36) empty -> .
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    LPAREN          shift and go to state 41
    SEMICOLON       reduce using rule 36 (empty -> .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    imprimir                       shift and go to state 40
    repiteValores                  shift and go to state 42
    empty                          shift and go to state 43
    valor                          shift and go to state 44

state 14

    (29) impresion -> PRINT . imprimir SEMICOLON
    (30) imprimir -> . LPAREN repiteValores RPAREN
    (31) imprimir -> . LPAREN RPAREN
    (32) imprimir -> . repiteValores
    (33) imprimir -> . empty
    (34) repiteValores -> . valor
    (35) repiteValores -> . valor COMMA repiteValores
    (36) empty -> .
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    LPAREN          shift and go to state 41
    SEMICOLON       reduce using rule 36 (empty -> .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    imprimir                       shift and go to state 46
    repiteValores                  shift and go to state 42
    empty                          shift and go to state 43
    valor                          shift and go to state 44

state 15

    (37) estructurasPrograma -> controlStructure .

    VARIABLE        reduce using rule 37 (estructurasPrograma -> controlStructure .)
    ECHO            reduce using rule 37 (estructurasPrograma -> controlStructure .)
    PRINT           reduce using rule 37 (estructurasPrograma -> controlStructure .)
    TRY             reduce using rule 37 (estructurasPrograma -> controlStructure .)
    INT             reduce using rule 37 (estructurasPrograma -> controlStructure .)
    FLOAT           reduce using rule 37 (estructurasPrograma -> controlStructure .)
    STRING          reduce using rule 37 (estructurasPrograma -> controlStructure .)
    IF              reduce using rule 37 (estructurasPrograma -> controlStructure .)
    WHILE           reduce using rule 37 (estructurasPrograma -> controlStructure .)
    SWITCH          reduce using rule 37 (estructurasPrograma -> controlStructure .)
    FOR             reduce using rule 37 (estructurasPrograma -> controlStructure .)
    CLOSETAG        reduce using rule 37 (estructurasPrograma -> controlStructure .)
    RBRACE          reduce using rule 37 (estructurasPrograma -> controlStructure .)
    BREAK           reduce using rule 37 (estructurasPrograma -> controlStructure .)


state 16

    (38) estructurasPrograma -> dataStructure .

    VARIABLE        reduce using rule 38 (estructurasPrograma -> dataStructure .)
    ECHO            reduce using rule 38 (estructurasPrograma -> dataStructure .)
    PRINT           reduce using rule 38 (estructurasPrograma -> dataStructure .)
    TRY             reduce using rule 38 (estructurasPrograma -> dataStructure .)
    INT             reduce using rule 38 (estructurasPrograma -> dataStructure .)
    FLOAT           reduce using rule 38 (estructurasPrograma -> dataStructure .)
    STRING          reduce using rule 38 (estructurasPrograma -> dataStructure .)
    IF              reduce using rule 38 (estructurasPrograma -> dataStructure .)
    WHILE           reduce using rule 38 (estructurasPrograma -> dataStructure .)
    SWITCH          reduce using rule 38 (estructurasPrograma -> dataStructure .)
    FOR             reduce using rule 38 (estructurasPrograma -> dataStructure .)
    CLOSETAG        reduce using rule 38 (estructurasPrograma -> dataStructure .)
    RBRACE          reduce using rule 38 (estructurasPrograma -> dataStructure .)
    BREAK           reduce using rule 38 (estructurasPrograma -> dataStructure .)


state 17

    (96) try -> TRY . LBRACE body RBRACE catchs
    (97) try -> TRY . LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE

    LBRACE          shift and go to state 47


state 18

    (14) valor -> INT .

    LT              reduce using rule 14 (valor -> INT .)
    GT              reduce using rule 14 (valor -> INT .)
    LEQ             reduce using rule 14 (valor -> INT .)
    GEQ             reduce using rule 14 (valor -> INT .)
    COMMA           reduce using rule 14 (valor -> INT .)
    SEMICOLON       reduce using rule 14 (valor -> INT .)
    PLUS            reduce using rule 14 (valor -> INT .)
    MINUS           reduce using rule 14 (valor -> INT .)
    TIMES           reduce using rule 14 (valor -> INT .)
    DIVIDE          reduce using rule 14 (valor -> INT .)
    MODULO          reduce using rule 14 (valor -> INT .)
    VARIABLE        reduce using rule 14 (valor -> INT .)
    ECHO            reduce using rule 14 (valor -> INT .)
    PRINT           reduce using rule 14 (valor -> INT .)
    TRY             reduce using rule 14 (valor -> INT .)
    INT             reduce using rule 14 (valor -> INT .)
    FLOAT           reduce using rule 14 (valor -> INT .)
    STRING          reduce using rule 14 (valor -> INT .)
    IF              reduce using rule 14 (valor -> INT .)
    WHILE           reduce using rule 14 (valor -> INT .)
    SWITCH          reduce using rule 14 (valor -> INT .)
    FOR             reduce using rule 14 (valor -> INT .)
    CLOSETAG        reduce using rule 14 (valor -> INT .)
    RBRACE          reduce using rule 14 (valor -> INT .)
    BREAK           reduce using rule 14 (valor -> INT .)
    RPAREN          reduce using rule 14 (valor -> INT .)
    EQ              reduce using rule 14 (valor -> INT .)
    NEQ             reduce using rule 14 (valor -> INT .)
    STRICTEQ        reduce using rule 14 (valor -> INT .)
    STRICTNEQ       reduce using rule 14 (valor -> INT .)
    ARROWMAP        reduce using rule 14 (valor -> INT .)
    RBRACKET        reduce using rule 14 (valor -> INT .)
    AND             reduce using rule 14 (valor -> INT .)
    LOGICAL_AND     reduce using rule 14 (valor -> INT .)
    OR              reduce using rule 14 (valor -> INT .)
    LOGICAL_OR      reduce using rule 14 (valor -> INT .)
    NOT             reduce using rule 14 (valor -> INT .)
    LOGICAL_NOT     reduce using rule 14 (valor -> INT .)
    COLON           reduce using rule 14 (valor -> INT .)


state 19

    (15) valor -> FLOAT .

    LT              reduce using rule 15 (valor -> FLOAT .)
    GT              reduce using rule 15 (valor -> FLOAT .)
    LEQ             reduce using rule 15 (valor -> FLOAT .)
    GEQ             reduce using rule 15 (valor -> FLOAT .)
    COMMA           reduce using rule 15 (valor -> FLOAT .)
    SEMICOLON       reduce using rule 15 (valor -> FLOAT .)
    PLUS            reduce using rule 15 (valor -> FLOAT .)
    MINUS           reduce using rule 15 (valor -> FLOAT .)
    TIMES           reduce using rule 15 (valor -> FLOAT .)
    DIVIDE          reduce using rule 15 (valor -> FLOAT .)
    MODULO          reduce using rule 15 (valor -> FLOAT .)
    VARIABLE        reduce using rule 15 (valor -> FLOAT .)
    ECHO            reduce using rule 15 (valor -> FLOAT .)
    PRINT           reduce using rule 15 (valor -> FLOAT .)
    TRY             reduce using rule 15 (valor -> FLOAT .)
    INT             reduce using rule 15 (valor -> FLOAT .)
    FLOAT           reduce using rule 15 (valor -> FLOAT .)
    STRING          reduce using rule 15 (valor -> FLOAT .)
    IF              reduce using rule 15 (valor -> FLOAT .)
    WHILE           reduce using rule 15 (valor -> FLOAT .)
    SWITCH          reduce using rule 15 (valor -> FLOAT .)
    FOR             reduce using rule 15 (valor -> FLOAT .)
    CLOSETAG        reduce using rule 15 (valor -> FLOAT .)
    RBRACE          reduce using rule 15 (valor -> FLOAT .)
    BREAK           reduce using rule 15 (valor -> FLOAT .)
    RPAREN          reduce using rule 15 (valor -> FLOAT .)
    EQ              reduce using rule 15 (valor -> FLOAT .)
    NEQ             reduce using rule 15 (valor -> FLOAT .)
    STRICTEQ        reduce using rule 15 (valor -> FLOAT .)
    STRICTNEQ       reduce using rule 15 (valor -> FLOAT .)
    ARROWMAP        reduce using rule 15 (valor -> FLOAT .)
    RBRACKET        reduce using rule 15 (valor -> FLOAT .)
    AND             reduce using rule 15 (valor -> FLOAT .)
    LOGICAL_AND     reduce using rule 15 (valor -> FLOAT .)
    OR              reduce using rule 15 (valor -> FLOAT .)
    LOGICAL_OR      reduce using rule 15 (valor -> FLOAT .)
    NOT             reduce using rule 15 (valor -> FLOAT .)
    LOGICAL_NOT     reduce using rule 15 (valor -> FLOAT .)
    COLON           reduce using rule 15 (valor -> FLOAT .)


state 20

    (17) valor -> STRING .

    LT              reduce using rule 17 (valor -> STRING .)
    GT              reduce using rule 17 (valor -> STRING .)
    LEQ             reduce using rule 17 (valor -> STRING .)
    GEQ             reduce using rule 17 (valor -> STRING .)
    COMMA           reduce using rule 17 (valor -> STRING .)
    SEMICOLON       reduce using rule 17 (valor -> STRING .)
    PLUS            reduce using rule 17 (valor -> STRING .)
    MINUS           reduce using rule 17 (valor -> STRING .)
    TIMES           reduce using rule 17 (valor -> STRING .)
    DIVIDE          reduce using rule 17 (valor -> STRING .)
    MODULO          reduce using rule 17 (valor -> STRING .)
    VARIABLE        reduce using rule 17 (valor -> STRING .)
    ECHO            reduce using rule 17 (valor -> STRING .)
    PRINT           reduce using rule 17 (valor -> STRING .)
    TRY             reduce using rule 17 (valor -> STRING .)
    INT             reduce using rule 17 (valor -> STRING .)
    FLOAT           reduce using rule 17 (valor -> STRING .)
    STRING          reduce using rule 17 (valor -> STRING .)
    IF              reduce using rule 17 (valor -> STRING .)
    WHILE           reduce using rule 17 (valor -> STRING .)
    SWITCH          reduce using rule 17 (valor -> STRING .)
    FOR             reduce using rule 17 (valor -> STRING .)
    CLOSETAG        reduce using rule 17 (valor -> STRING .)
    RBRACE          reduce using rule 17 (valor -> STRING .)
    BREAK           reduce using rule 17 (valor -> STRING .)
    RPAREN          reduce using rule 17 (valor -> STRING .)
    EQ              reduce using rule 17 (valor -> STRING .)
    NEQ             reduce using rule 17 (valor -> STRING .)
    STRICTEQ        reduce using rule 17 (valor -> STRING .)
    STRICTNEQ       reduce using rule 17 (valor -> STRING .)
    ARROWMAP        reduce using rule 17 (valor -> STRING .)
    RBRACKET        reduce using rule 17 (valor -> STRING .)
    AND             reduce using rule 17 (valor -> STRING .)
    LOGICAL_AND     reduce using rule 17 (valor -> STRING .)
    OR              reduce using rule 17 (valor -> STRING .)
    LOGICAL_OR      reduce using rule 17 (valor -> STRING .)
    NOT             reduce using rule 17 (valor -> STRING .)
    LOGICAL_NOT     reduce using rule 17 (valor -> STRING .)
    COLON           reduce using rule 17 (valor -> STRING .)


state 21

    (39) controlStructure -> if .

    VARIABLE        reduce using rule 39 (controlStructure -> if .)
    ECHO            reduce using rule 39 (controlStructure -> if .)
    PRINT           reduce using rule 39 (controlStructure -> if .)
    TRY             reduce using rule 39 (controlStructure -> if .)
    INT             reduce using rule 39 (controlStructure -> if .)
    FLOAT           reduce using rule 39 (controlStructure -> if .)
    STRING          reduce using rule 39 (controlStructure -> if .)
    IF              reduce using rule 39 (controlStructure -> if .)
    WHILE           reduce using rule 39 (controlStructure -> if .)
    SWITCH          reduce using rule 39 (controlStructure -> if .)
    FOR             reduce using rule 39 (controlStructure -> if .)
    CLOSETAG        reduce using rule 39 (controlStructure -> if .)
    RBRACE          reduce using rule 39 (controlStructure -> if .)
    BREAK           reduce using rule 39 (controlStructure -> if .)


state 22

    (40) controlStructure -> for .

    VARIABLE        reduce using rule 40 (controlStructure -> for .)
    ECHO            reduce using rule 40 (controlStructure -> for .)
    PRINT           reduce using rule 40 (controlStructure -> for .)
    TRY             reduce using rule 40 (controlStructure -> for .)
    INT             reduce using rule 40 (controlStructure -> for .)
    FLOAT           reduce using rule 40 (controlStructure -> for .)
    STRING          reduce using rule 40 (controlStructure -> for .)
    IF              reduce using rule 40 (controlStructure -> for .)
    WHILE           reduce using rule 40 (controlStructure -> for .)
    SWITCH          reduce using rule 40 (controlStructure -> for .)
    FOR             reduce using rule 40 (controlStructure -> for .)
    CLOSETAG        reduce using rule 40 (controlStructure -> for .)
    RBRACE          reduce using rule 40 (controlStructure -> for .)
    BREAK           reduce using rule 40 (controlStructure -> for .)


state 23

    (41) controlStructure -> while .

    VARIABLE        reduce using rule 41 (controlStructure -> while .)
    ECHO            reduce using rule 41 (controlStructure -> while .)
    PRINT           reduce using rule 41 (controlStructure -> while .)
    TRY             reduce using rule 41 (controlStructure -> while .)
    INT             reduce using rule 41 (controlStructure -> while .)
    FLOAT           reduce using rule 41 (controlStructure -> while .)
    STRING          reduce using rule 41 (controlStructure -> while .)
    IF              reduce using rule 41 (controlStructure -> while .)
    WHILE           reduce using rule 41 (controlStructure -> while .)
    SWITCH          reduce using rule 41 (controlStructure -> while .)
    FOR             reduce using rule 41 (controlStructure -> while .)
    CLOSETAG        reduce using rule 41 (controlStructure -> while .)
    RBRACE          reduce using rule 41 (controlStructure -> while .)
    BREAK           reduce using rule 41 (controlStructure -> while .)


state 24

    (42) controlStructure -> switch .

    VARIABLE        reduce using rule 42 (controlStructure -> switch .)
    ECHO            reduce using rule 42 (controlStructure -> switch .)
    PRINT           reduce using rule 42 (controlStructure -> switch .)
    TRY             reduce using rule 42 (controlStructure -> switch .)
    INT             reduce using rule 42 (controlStructure -> switch .)
    FLOAT           reduce using rule 42 (controlStructure -> switch .)
    STRING          reduce using rule 42 (controlStructure -> switch .)
    IF              reduce using rule 42 (controlStructure -> switch .)
    WHILE           reduce using rule 42 (controlStructure -> switch .)
    SWITCH          reduce using rule 42 (controlStructure -> switch .)
    FOR             reduce using rule 42 (controlStructure -> switch .)
    CLOSETAG        reduce using rule 42 (controlStructure -> switch .)
    RBRACE          reduce using rule 42 (controlStructure -> switch .)
    BREAK           reduce using rule 42 (controlStructure -> switch .)


state 25

    (82) dataStructure -> array .

    VARIABLE        reduce using rule 82 (dataStructure -> array .)
    ECHO            reduce using rule 82 (dataStructure -> array .)
    PRINT           reduce using rule 82 (dataStructure -> array .)
    TRY             reduce using rule 82 (dataStructure -> array .)
    INT             reduce using rule 82 (dataStructure -> array .)
    FLOAT           reduce using rule 82 (dataStructure -> array .)
    STRING          reduce using rule 82 (dataStructure -> array .)
    IF              reduce using rule 82 (dataStructure -> array .)
    WHILE           reduce using rule 82 (dataStructure -> array .)
    SWITCH          reduce using rule 82 (dataStructure -> array .)
    FOR             reduce using rule 82 (dataStructure -> array .)
    CLOSETAG        reduce using rule 82 (dataStructure -> array .)
    RBRACE          reduce using rule 82 (dataStructure -> array .)
    BREAK           reduce using rule 82 (dataStructure -> array .)


state 26

    (43) if -> IF . LPAREN conditions RPAREN LBRACE body RBRACE
    (44) if -> IF . LPAREN conditions RPAREN LBRACE body RBRACE else_blocks

    LPAREN          shift and go to state 48


state 27

    (68) for -> forStatement .

    VARIABLE        reduce using rule 68 (for -> forStatement .)
    ECHO            reduce using rule 68 (for -> forStatement .)
    PRINT           reduce using rule 68 (for -> forStatement .)
    TRY             reduce using rule 68 (for -> forStatement .)
    INT             reduce using rule 68 (for -> forStatement .)
    FLOAT           reduce using rule 68 (for -> forStatement .)
    STRING          reduce using rule 68 (for -> forStatement .)
    IF              reduce using rule 68 (for -> forStatement .)
    WHILE           reduce using rule 68 (for -> forStatement .)
    SWITCH          reduce using rule 68 (for -> forStatement .)
    FOR             reduce using rule 68 (for -> forStatement .)
    CLOSETAG        reduce using rule 68 (for -> forStatement .)
    RBRACE          reduce using rule 68 (for -> forStatement .)
    BREAK           reduce using rule 68 (for -> forStatement .)


state 28

    (72) while -> WHILE . LPAREN condition RPAREN LBRACE body RBRACE
    (73) while -> WHILE . LPAREN condition RPAREN LBRACE RBRACE

    LPAREN          shift and go to state 49


state 29

    (74) switch -> SWITCH . LPAREN valor RPAREN LBRACE caseLists RBRACE

    LPAREN          shift and go to state 50


state 30

    (86) array -> map .

    VARIABLE        reduce using rule 86 (array -> map .)
    ECHO            reduce using rule 86 (array -> map .)
    PRINT           reduce using rule 86 (array -> map .)
    TRY             reduce using rule 86 (array -> map .)
    INT             reduce using rule 86 (array -> map .)
    FLOAT           reduce using rule 86 (array -> map .)
    STRING          reduce using rule 86 (array -> map .)
    IF              reduce using rule 86 (array -> map .)
    WHILE           reduce using rule 86 (array -> map .)
    SWITCH          reduce using rule 86 (array -> map .)
    FOR             reduce using rule 86 (array -> map .)
    CLOSETAG        reduce using rule 86 (array -> map .)
    RBRACE          reduce using rule 86 (array -> map .)
    BREAK           reduce using rule 86 (array -> map .)


state 31

    (69) forStatement -> FOR . LPAREN forcondition RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 51


state 32

    (1) inicio -> OPENTAG programa CLOSETAG .

    $end            reduce using rule 1 (inicio -> OPENTAG programa CLOSETAG .)


state 33

    (3) programa -> sentencia programa .

    CLOSETAG        reduce using rule 3 (programa -> sentencia programa .)


state 34

    (10) asignacion -> VARIABLE EQUALS . operaArit SEMICOLON
    (11) asignacion_fgets -> VARIABLE EQUALS . FGETS LPAREN STDIN RPAREN SEMICOLON
    (83) array -> VARIABLE EQUALS . arrays SEMICOLON
    (84) array -> VARIABLE EQUALS . LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> VARIABLE EQUALS . ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (90) map -> VARIABLE EQUALS . LBRACKET maps RBRACKET SEMICOLON
    (91) map -> VARIABLE EQUALS . ARRAY LPAREN maps RPAREN SEMICOLON
    (12) operaArit -> . valor
    (13) operaArit -> . valor operador operaArit
    (87) arrays -> . LBRACKET repiteValores RBRACKET
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    FGETS           shift and go to state 53
    LBRACKET        shift and go to state 55
    ARRAY           shift and go to state 56
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    operaArit                      shift and go to state 52
    arrays                         shift and go to state 54
    valor                          shift and go to state 57

state 35

    (23) comparacion -> valor comparador . valor
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    valor                          shift and go to state 58

state 36

    (24) comparador -> LT .

    INT             reduce using rule 24 (comparador -> LT .)
    FLOAT           reduce using rule 24 (comparador -> LT .)
    VARIABLE        reduce using rule 24 (comparador -> LT .)
    STRING          reduce using rule 24 (comparador -> LT .)


state 37

    (25) comparador -> GT .

    INT             reduce using rule 25 (comparador -> GT .)
    FLOAT           reduce using rule 25 (comparador -> GT .)
    VARIABLE        reduce using rule 25 (comparador -> GT .)
    STRING          reduce using rule 25 (comparador -> GT .)


state 38

    (26) comparador -> LEQ .

    INT             reduce using rule 26 (comparador -> LEQ .)
    FLOAT           reduce using rule 26 (comparador -> LEQ .)
    VARIABLE        reduce using rule 26 (comparador -> LEQ .)
    STRING          reduce using rule 26 (comparador -> LEQ .)


state 39

    (27) comparador -> GEQ .

    INT             reduce using rule 27 (comparador -> GEQ .)
    FLOAT           reduce using rule 27 (comparador -> GEQ .)
    VARIABLE        reduce using rule 27 (comparador -> GEQ .)
    STRING          reduce using rule 27 (comparador -> GEQ .)


state 40

    (28) impresion -> ECHO imprimir . SEMICOLON

    SEMICOLON       shift and go to state 59


state 41

    (30) imprimir -> LPAREN . repiteValores RPAREN
    (31) imprimir -> LPAREN . RPAREN
    (34) repiteValores -> . valor
    (35) repiteValores -> . valor COMMA repiteValores
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    RPAREN          shift and go to state 61
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    repiteValores                  shift and go to state 60
    valor                          shift and go to state 44

state 42

    (32) imprimir -> repiteValores .

    SEMICOLON       reduce using rule 32 (imprimir -> repiteValores .)


state 43

    (33) imprimir -> empty .

    SEMICOLON       reduce using rule 33 (imprimir -> empty .)


state 44

    (34) repiteValores -> valor .
    (35) repiteValores -> valor . COMMA repiteValores

    SEMICOLON       reduce using rule 34 (repiteValores -> valor .)
    RPAREN          reduce using rule 34 (repiteValores -> valor .)
    RBRACKET        reduce using rule 34 (repiteValores -> valor .)
    COMMA           shift and go to state 62


state 45

    (16) valor -> VARIABLE .

    COMMA           reduce using rule 16 (valor -> VARIABLE .)
    SEMICOLON       reduce using rule 16 (valor -> VARIABLE .)
    PLUS            reduce using rule 16 (valor -> VARIABLE .)
    MINUS           reduce using rule 16 (valor -> VARIABLE .)
    TIMES           reduce using rule 16 (valor -> VARIABLE .)
    DIVIDE          reduce using rule 16 (valor -> VARIABLE .)
    MODULO          reduce using rule 16 (valor -> VARIABLE .)
    VARIABLE        reduce using rule 16 (valor -> VARIABLE .)
    ECHO            reduce using rule 16 (valor -> VARIABLE .)
    PRINT           reduce using rule 16 (valor -> VARIABLE .)
    TRY             reduce using rule 16 (valor -> VARIABLE .)
    INT             reduce using rule 16 (valor -> VARIABLE .)
    FLOAT           reduce using rule 16 (valor -> VARIABLE .)
    STRING          reduce using rule 16 (valor -> VARIABLE .)
    IF              reduce using rule 16 (valor -> VARIABLE .)
    WHILE           reduce using rule 16 (valor -> VARIABLE .)
    SWITCH          reduce using rule 16 (valor -> VARIABLE .)
    FOR             reduce using rule 16 (valor -> VARIABLE .)
    CLOSETAG        reduce using rule 16 (valor -> VARIABLE .)
    RBRACE          reduce using rule 16 (valor -> VARIABLE .)
    BREAK           reduce using rule 16 (valor -> VARIABLE .)
    RPAREN          reduce using rule 16 (valor -> VARIABLE .)
    EQ              reduce using rule 16 (valor -> VARIABLE .)
    NEQ             reduce using rule 16 (valor -> VARIABLE .)
    STRICTEQ        reduce using rule 16 (valor -> VARIABLE .)
    STRICTNEQ       reduce using rule 16 (valor -> VARIABLE .)
    LT              reduce using rule 16 (valor -> VARIABLE .)
    GT              reduce using rule 16 (valor -> VARIABLE .)
    LEQ             reduce using rule 16 (valor -> VARIABLE .)
    GEQ             reduce using rule 16 (valor -> VARIABLE .)
    ARROWMAP        reduce using rule 16 (valor -> VARIABLE .)
    RBRACKET        reduce using rule 16 (valor -> VARIABLE .)
    AND             reduce using rule 16 (valor -> VARIABLE .)
    LOGICAL_AND     reduce using rule 16 (valor -> VARIABLE .)
    OR              reduce using rule 16 (valor -> VARIABLE .)
    LOGICAL_OR      reduce using rule 16 (valor -> VARIABLE .)
    NOT             reduce using rule 16 (valor -> VARIABLE .)
    LOGICAL_NOT     reduce using rule 16 (valor -> VARIABLE .)
    COLON           reduce using rule 16 (valor -> VARIABLE .)


state 46

    (29) impresion -> PRINT imprimir . SEMICOLON

    SEMICOLON       shift and go to state 63


state 47

    (96) try -> TRY LBRACE . body RBRACE catchs
    (97) try -> TRY LBRACE . body RBRACE catchs FINALLY LBRACE body RBRACE
    (64) body -> . sentenciaList
    (65) body -> . empty
    (66) sentenciaList -> . sentencia
    (67) sentenciaList -> . sentencia sentenciaList
    (36) empty -> .
    (4) sentencia -> . asignacion
    (5) sentencia -> . asignacion_fgets
    (6) sentencia -> . comparacion
    (7) sentencia -> . impresion
    (8) sentencia -> . estructurasPrograma
    (9) sentencia -> . try
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (23) comparacion -> . valor comparador valor
    (28) impresion -> . ECHO imprimir SEMICOLON
    (29) impresion -> . PRINT imprimir SEMICOLON
    (37) estructurasPrograma -> . controlStructure
    (38) estructurasPrograma -> . dataStructure
    (96) try -> . TRY LBRACE body RBRACE catchs
    (97) try -> . TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING
    (39) controlStructure -> . if
    (40) controlStructure -> . for
    (41) controlStructure -> . while
    (42) controlStructure -> . switch
    (82) dataStructure -> . array
    (43) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE
    (44) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
    (68) for -> . forStatement
    (72) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (73) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (74) switch -> . SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE
    (83) array -> . VARIABLE EQUALS arrays SEMICOLON
    (84) array -> . VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (86) array -> . map
    (69) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (90) map -> . VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON
    (91) map -> . VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON

    RBRACE          reduce using rule 36 (empty -> .)
    VARIABLE        shift and go to state 11
    ECHO            shift and go to state 13
    PRINT           shift and go to state 14
    TRY             shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    SWITCH          shift and go to state 29
    FOR             shift and go to state 31

    body                           shift and go to state 64
    sentenciaList                  shift and go to state 65
    empty                          shift and go to state 66
    sentencia                      shift and go to state 67
    asignacion                     shift and go to state 5
    asignacion_fgets               shift and go to state 6
    comparacion                    shift and go to state 7
    impresion                      shift and go to state 8
    estructurasPrograma            shift and go to state 9
    try                            shift and go to state 10
    valor                          shift and go to state 12
    controlStructure               shift and go to state 15
    dataStructure                  shift and go to state 16
    if                             shift and go to state 21
    for                            shift and go to state 22
    while                          shift and go to state 23
    switch                         shift and go to state 24
    array                          shift and go to state 25
    forStatement                   shift and go to state 27
    map                            shift and go to state 30

state 48

    (43) if -> IF LPAREN . conditions RPAREN LBRACE body RBRACE
    (44) if -> IF LPAREN . conditions RPAREN LBRACE body RBRACE else_blocks
    (47) conditions -> . condition
    (48) conditions -> . condition opLogic conditions
    (49) condition -> . valor opSymbol valor
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    conditions                     shift and go to state 68
    condition                      shift and go to state 69
    valor                          shift and go to state 70

state 49

    (72) while -> WHILE LPAREN . condition RPAREN LBRACE body RBRACE
    (73) while -> WHILE LPAREN . condition RPAREN LBRACE RBRACE
    (49) condition -> . valor opSymbol valor
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    condition                      shift and go to state 71
    valor                          shift and go to state 70

state 50

    (74) switch -> SWITCH LPAREN . valor RPAREN LBRACE caseLists RBRACE
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    valor                          shift and go to state 72

state 51

    (69) forStatement -> FOR LPAREN . forcondition RPAREN LBRACE body RBRACE
    (70) forcondition -> . VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (71) forcondition -> . VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    VARIABLE        shift and go to state 74

    forcondition                   shift and go to state 73

state 52

    (10) asignacion -> VARIABLE EQUALS operaArit . SEMICOLON

    SEMICOLON       shift and go to state 75


state 53

    (11) asignacion_fgets -> VARIABLE EQUALS FGETS . LPAREN STDIN RPAREN SEMICOLON

    LPAREN          shift and go to state 76


state 54

    (83) array -> VARIABLE EQUALS arrays . SEMICOLON

    SEMICOLON       shift and go to state 77


state 55

    (84) array -> VARIABLE EQUALS LBRACKET . arrayAnidado RBRACKET SEMICOLON
    (90) map -> VARIABLE EQUALS LBRACKET . maps RBRACKET SEMICOLON
    (87) arrays -> LBRACKET . repiteValores RBRACKET
    (88) arrayAnidado -> . arrays
    (89) arrayAnidado -> . arrays COMMA arrayAnidado
    (92) maps -> . mapArrow
    (93) maps -> . mapArrow COMMA maps
    (34) repiteValores -> . valor
    (35) repiteValores -> . valor COMMA repiteValores
    (87) arrays -> . LBRACKET repiteValores RBRACKET
    (94) mapArrow -> . valor ARROWMAP valor
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    LBRACKET        shift and go to state 78
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    arrayAnidado                   shift and go to state 79
    maps                           shift and go to state 80
    repiteValores                  shift and go to state 81
    arrays                         shift and go to state 82
    mapArrow                       shift and go to state 83
    valor                          shift and go to state 84

state 56

    (85) array -> VARIABLE EQUALS ARRAY . LPAREN repiteValores RPAREN SEMICOLON
    (91) map -> VARIABLE EQUALS ARRAY . LPAREN maps RPAREN SEMICOLON

    LPAREN          shift and go to state 85


state 57

    (12) operaArit -> valor .
    (13) operaArit -> valor . operador operaArit
    (18) operador -> . PLUS
    (19) operador -> . MINUS
    (20) operador -> . TIMES
    (21) operador -> . DIVIDE
    (22) operador -> . MODULO

    SEMICOLON       reduce using rule 12 (operaArit -> valor .)
    PLUS            shift and go to state 87
    MINUS           shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MODULO          shift and go to state 91

    operador                       shift and go to state 86

state 58

    (23) comparacion -> valor comparador valor .

    VARIABLE        reduce using rule 23 (comparacion -> valor comparador valor .)
    ECHO            reduce using rule 23 (comparacion -> valor comparador valor .)
    PRINT           reduce using rule 23 (comparacion -> valor comparador valor .)
    TRY             reduce using rule 23 (comparacion -> valor comparador valor .)
    INT             reduce using rule 23 (comparacion -> valor comparador valor .)
    FLOAT           reduce using rule 23 (comparacion -> valor comparador valor .)
    STRING          reduce using rule 23 (comparacion -> valor comparador valor .)
    IF              reduce using rule 23 (comparacion -> valor comparador valor .)
    WHILE           reduce using rule 23 (comparacion -> valor comparador valor .)
    SWITCH          reduce using rule 23 (comparacion -> valor comparador valor .)
    FOR             reduce using rule 23 (comparacion -> valor comparador valor .)
    CLOSETAG        reduce using rule 23 (comparacion -> valor comparador valor .)
    RBRACE          reduce using rule 23 (comparacion -> valor comparador valor .)
    BREAK           reduce using rule 23 (comparacion -> valor comparador valor .)


state 59

    (28) impresion -> ECHO imprimir SEMICOLON .

    VARIABLE        reduce using rule 28 (impresion -> ECHO imprimir SEMICOLON .)
    ECHO            reduce using rule 28 (impresion -> ECHO imprimir SEMICOLON .)
    PRINT           reduce using rule 28 (impresion -> ECHO imprimir SEMICOLON .)
    TRY             reduce using rule 28 (impresion -> ECHO imprimir SEMICOLON .)
    INT             reduce using rule 28 (impresion -> ECHO imprimir SEMICOLON .)
    FLOAT           reduce using rule 28 (impresion -> ECHO imprimir SEMICOLON .)
    STRING          reduce using rule 28 (impresion -> ECHO imprimir SEMICOLON .)
    IF              reduce using rule 28 (impresion -> ECHO imprimir SEMICOLON .)
    WHILE           reduce using rule 28 (impresion -> ECHO imprimir SEMICOLON .)
    SWITCH          reduce using rule 28 (impresion -> ECHO imprimir SEMICOLON .)
    FOR             reduce using rule 28 (impresion -> ECHO imprimir SEMICOLON .)
    CLOSETAG        reduce using rule 28 (impresion -> ECHO imprimir SEMICOLON .)
    RBRACE          reduce using rule 28 (impresion -> ECHO imprimir SEMICOLON .)
    BREAK           reduce using rule 28 (impresion -> ECHO imprimir SEMICOLON .)


state 60

    (30) imprimir -> LPAREN repiteValores . RPAREN

    RPAREN          shift and go to state 92


state 61

    (31) imprimir -> LPAREN RPAREN .

    SEMICOLON       reduce using rule 31 (imprimir -> LPAREN RPAREN .)


state 62

    (35) repiteValores -> valor COMMA . repiteValores
    (34) repiteValores -> . valor
    (35) repiteValores -> . valor COMMA repiteValores
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    valor                          shift and go to state 44
    repiteValores                  shift and go to state 93

state 63

    (29) impresion -> PRINT imprimir SEMICOLON .

    VARIABLE        reduce using rule 29 (impresion -> PRINT imprimir SEMICOLON .)
    ECHO            reduce using rule 29 (impresion -> PRINT imprimir SEMICOLON .)
    PRINT           reduce using rule 29 (impresion -> PRINT imprimir SEMICOLON .)
    TRY             reduce using rule 29 (impresion -> PRINT imprimir SEMICOLON .)
    INT             reduce using rule 29 (impresion -> PRINT imprimir SEMICOLON .)
    FLOAT           reduce using rule 29 (impresion -> PRINT imprimir SEMICOLON .)
    STRING          reduce using rule 29 (impresion -> PRINT imprimir SEMICOLON .)
    IF              reduce using rule 29 (impresion -> PRINT imprimir SEMICOLON .)
    WHILE           reduce using rule 29 (impresion -> PRINT imprimir SEMICOLON .)
    SWITCH          reduce using rule 29 (impresion -> PRINT imprimir SEMICOLON .)
    FOR             reduce using rule 29 (impresion -> PRINT imprimir SEMICOLON .)
    CLOSETAG        reduce using rule 29 (impresion -> PRINT imprimir SEMICOLON .)
    RBRACE          reduce using rule 29 (impresion -> PRINT imprimir SEMICOLON .)
    BREAK           reduce using rule 29 (impresion -> PRINT imprimir SEMICOLON .)


state 64

    (96) try -> TRY LBRACE body . RBRACE catchs
    (97) try -> TRY LBRACE body . RBRACE catchs FINALLY LBRACE body RBRACE

    RBRACE          shift and go to state 94


state 65

    (64) body -> sentenciaList .

    RBRACE          reduce using rule 64 (body -> sentenciaList .)
    BREAK           reduce using rule 64 (body -> sentenciaList .)


state 66

    (65) body -> empty .

    RBRACE          reduce using rule 65 (body -> empty .)
    BREAK           reduce using rule 65 (body -> empty .)


state 67

    (66) sentenciaList -> sentencia .
    (67) sentenciaList -> sentencia . sentenciaList
    (66) sentenciaList -> . sentencia
    (67) sentenciaList -> . sentencia sentenciaList
    (4) sentencia -> . asignacion
    (5) sentencia -> . asignacion_fgets
    (6) sentencia -> . comparacion
    (7) sentencia -> . impresion
    (8) sentencia -> . estructurasPrograma
    (9) sentencia -> . try
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (23) comparacion -> . valor comparador valor
    (28) impresion -> . ECHO imprimir SEMICOLON
    (29) impresion -> . PRINT imprimir SEMICOLON
    (37) estructurasPrograma -> . controlStructure
    (38) estructurasPrograma -> . dataStructure
    (96) try -> . TRY LBRACE body RBRACE catchs
    (97) try -> . TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING
    (39) controlStructure -> . if
    (40) controlStructure -> . for
    (41) controlStructure -> . while
    (42) controlStructure -> . switch
    (82) dataStructure -> . array
    (43) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE
    (44) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
    (68) for -> . forStatement
    (72) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (73) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (74) switch -> . SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE
    (83) array -> . VARIABLE EQUALS arrays SEMICOLON
    (84) array -> . VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (86) array -> . map
    (69) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (90) map -> . VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON
    (91) map -> . VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON

    RBRACE          reduce using rule 66 (sentenciaList -> sentencia .)
    BREAK           reduce using rule 66 (sentenciaList -> sentencia .)
    VARIABLE        shift and go to state 11
    ECHO            shift and go to state 13
    PRINT           shift and go to state 14
    TRY             shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    SWITCH          shift and go to state 29
    FOR             shift and go to state 31

    sentencia                      shift and go to state 67
    sentenciaList                  shift and go to state 95
    asignacion                     shift and go to state 5
    asignacion_fgets               shift and go to state 6
    comparacion                    shift and go to state 7
    impresion                      shift and go to state 8
    estructurasPrograma            shift and go to state 9
    try                            shift and go to state 10
    valor                          shift and go to state 12
    controlStructure               shift and go to state 15
    dataStructure                  shift and go to state 16
    if                             shift and go to state 21
    for                            shift and go to state 22
    while                          shift and go to state 23
    switch                         shift and go to state 24
    array                          shift and go to state 25
    forStatement                   shift and go to state 27
    map                            shift and go to state 30

state 68

    (43) if -> IF LPAREN conditions . RPAREN LBRACE body RBRACE
    (44) if -> IF LPAREN conditions . RPAREN LBRACE body RBRACE else_blocks

    RPAREN          shift and go to state 96


state 69

    (47) conditions -> condition .
    (48) conditions -> condition . opLogic conditions
    (58) opLogic -> . AND
    (59) opLogic -> . LOGICAL_AND
    (60) opLogic -> . OR
    (61) opLogic -> . LOGICAL_OR
    (62) opLogic -> . NOT
    (63) opLogic -> . LOGICAL_NOT

    RPAREN          reduce using rule 47 (conditions -> condition .)
    AND             shift and go to state 98
    LOGICAL_AND     shift and go to state 99
    OR              shift and go to state 100
    LOGICAL_OR      shift and go to state 101
    NOT             shift and go to state 102
    LOGICAL_NOT     shift and go to state 103

    opLogic                        shift and go to state 97

state 70

    (49) condition -> valor . opSymbol valor
    (50) opSymbol -> . EQ
    (51) opSymbol -> . NEQ
    (52) opSymbol -> . STRICTEQ
    (53) opSymbol -> . STRICTNEQ
    (54) opSymbol -> . LT
    (55) opSymbol -> . GT
    (56) opSymbol -> . LEQ
    (57) opSymbol -> . GEQ

    EQ              shift and go to state 105
    NEQ             shift and go to state 106
    STRICTEQ        shift and go to state 107
    STRICTNEQ       shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112

    opSymbol                       shift and go to state 104

state 71

    (72) while -> WHILE LPAREN condition . RPAREN LBRACE body RBRACE
    (73) while -> WHILE LPAREN condition . RPAREN LBRACE RBRACE

    RPAREN          shift and go to state 113


state 72

    (74) switch -> SWITCH LPAREN valor . RPAREN LBRACE caseLists RBRACE

    RPAREN          shift and go to state 114


state 73

    (69) forStatement -> FOR LPAREN forcondition . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 115


state 74

    (70) forcondition -> VARIABLE . EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (71) forcondition -> VARIABLE . EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    EQUALS          shift and go to state 116


state 75

    (10) asignacion -> VARIABLE EQUALS operaArit SEMICOLON .

    VARIABLE        reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    ECHO            reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    PRINT           reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    TRY             reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    INT             reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    FLOAT           reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    STRING          reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    IF              reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    WHILE           reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    SWITCH          reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    FOR             reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    CLOSETAG        reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    RBRACE          reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    BREAK           reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)


state 76

    (11) asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN . STDIN RPAREN SEMICOLON

    STDIN           shift and go to state 117


state 77

    (83) array -> VARIABLE EQUALS arrays SEMICOLON .

    VARIABLE        reduce using rule 83 (array -> VARIABLE EQUALS arrays SEMICOLON .)
    ECHO            reduce using rule 83 (array -> VARIABLE EQUALS arrays SEMICOLON .)
    PRINT           reduce using rule 83 (array -> VARIABLE EQUALS arrays SEMICOLON .)
    TRY             reduce using rule 83 (array -> VARIABLE EQUALS arrays SEMICOLON .)
    INT             reduce using rule 83 (array -> VARIABLE EQUALS arrays SEMICOLON .)
    FLOAT           reduce using rule 83 (array -> VARIABLE EQUALS arrays SEMICOLON .)
    STRING          reduce using rule 83 (array -> VARIABLE EQUALS arrays SEMICOLON .)
    IF              reduce using rule 83 (array -> VARIABLE EQUALS arrays SEMICOLON .)
    WHILE           reduce using rule 83 (array -> VARIABLE EQUALS arrays SEMICOLON .)
    SWITCH          reduce using rule 83 (array -> VARIABLE EQUALS arrays SEMICOLON .)
    FOR             reduce using rule 83 (array -> VARIABLE EQUALS arrays SEMICOLON .)
    CLOSETAG        reduce using rule 83 (array -> VARIABLE EQUALS arrays SEMICOLON .)
    RBRACE          reduce using rule 83 (array -> VARIABLE EQUALS arrays SEMICOLON .)
    BREAK           reduce using rule 83 (array -> VARIABLE EQUALS arrays SEMICOLON .)


state 78

    (87) arrays -> LBRACKET . repiteValores RBRACKET
    (34) repiteValores -> . valor
    (35) repiteValores -> . valor COMMA repiteValores
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    repiteValores                  shift and go to state 81
    valor                          shift and go to state 44

state 79

    (84) array -> VARIABLE EQUALS LBRACKET arrayAnidado . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 118


state 80

    (90) map -> VARIABLE EQUALS LBRACKET maps . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 119


state 81

    (87) arrays -> LBRACKET repiteValores . RBRACKET

    RBRACKET        shift and go to state 120


state 82

    (88) arrayAnidado -> arrays .
    (89) arrayAnidado -> arrays . COMMA arrayAnidado

    RBRACKET        reduce using rule 88 (arrayAnidado -> arrays .)
    COMMA           shift and go to state 121


state 83

    (92) maps -> mapArrow .
    (93) maps -> mapArrow . COMMA maps

    RBRACKET        reduce using rule 92 (maps -> mapArrow .)
    RPAREN          reduce using rule 92 (maps -> mapArrow .)
    COMMA           shift and go to state 122


state 84

    (34) repiteValores -> valor .
    (35) repiteValores -> valor . COMMA repiteValores
    (94) mapArrow -> valor . ARROWMAP valor

    RBRACKET        reduce using rule 34 (repiteValores -> valor .)
    RPAREN          reduce using rule 34 (repiteValores -> valor .)
    COMMA           shift and go to state 62
    ARROWMAP        shift and go to state 123


state 85

    (85) array -> VARIABLE EQUALS ARRAY LPAREN . repiteValores RPAREN SEMICOLON
    (91) map -> VARIABLE EQUALS ARRAY LPAREN . maps RPAREN SEMICOLON
    (34) repiteValores -> . valor
    (35) repiteValores -> . valor COMMA repiteValores
    (92) maps -> . mapArrow
    (93) maps -> . mapArrow COMMA maps
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING
    (94) mapArrow -> . valor ARROWMAP valor

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    repiteValores                  shift and go to state 124
    maps                           shift and go to state 125
    valor                          shift and go to state 84
    mapArrow                       shift and go to state 83

state 86

    (13) operaArit -> valor operador . operaArit
    (12) operaArit -> . valor
    (13) operaArit -> . valor operador operaArit
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    valor                          shift and go to state 57
    operaArit                      shift and go to state 126

state 87

    (18) operador -> PLUS .

    INT             reduce using rule 18 (operador -> PLUS .)
    FLOAT           reduce using rule 18 (operador -> PLUS .)
    VARIABLE        reduce using rule 18 (operador -> PLUS .)
    STRING          reduce using rule 18 (operador -> PLUS .)


state 88

    (19) operador -> MINUS .

    INT             reduce using rule 19 (operador -> MINUS .)
    FLOAT           reduce using rule 19 (operador -> MINUS .)
    VARIABLE        reduce using rule 19 (operador -> MINUS .)
    STRING          reduce using rule 19 (operador -> MINUS .)


state 89

    (20) operador -> TIMES .

    INT             reduce using rule 20 (operador -> TIMES .)
    FLOAT           reduce using rule 20 (operador -> TIMES .)
    VARIABLE        reduce using rule 20 (operador -> TIMES .)
    STRING          reduce using rule 20 (operador -> TIMES .)


state 90

    (21) operador -> DIVIDE .

    INT             reduce using rule 21 (operador -> DIVIDE .)
    FLOAT           reduce using rule 21 (operador -> DIVIDE .)
    VARIABLE        reduce using rule 21 (operador -> DIVIDE .)
    STRING          reduce using rule 21 (operador -> DIVIDE .)


state 91

    (22) operador -> MODULO .

    INT             reduce using rule 22 (operador -> MODULO .)
    FLOAT           reduce using rule 22 (operador -> MODULO .)
    VARIABLE        reduce using rule 22 (operador -> MODULO .)
    STRING          reduce using rule 22 (operador -> MODULO .)


state 92

    (30) imprimir -> LPAREN repiteValores RPAREN .

    SEMICOLON       reduce using rule 30 (imprimir -> LPAREN repiteValores RPAREN .)


state 93

    (35) repiteValores -> valor COMMA repiteValores .

    SEMICOLON       reduce using rule 35 (repiteValores -> valor COMMA repiteValores .)
    RPAREN          reduce using rule 35 (repiteValores -> valor COMMA repiteValores .)
    RBRACKET        reduce using rule 35 (repiteValores -> valor COMMA repiteValores .)


state 94

    (96) try -> TRY LBRACE body RBRACE . catchs
    (97) try -> TRY LBRACE body RBRACE . catchs FINALLY LBRACE body RBRACE
    (99) catchs -> . catch
    (100) catchs -> . catch catchs
    (98) catch -> . CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE

    CATCH           shift and go to state 129

    catchs                         shift and go to state 127
    catch                          shift and go to state 128

state 95

    (67) sentenciaList -> sentencia sentenciaList .

    RBRACE          reduce using rule 67 (sentenciaList -> sentencia sentenciaList .)
    BREAK           reduce using rule 67 (sentenciaList -> sentencia sentenciaList .)


state 96

    (43) if -> IF LPAREN conditions RPAREN . LBRACE body RBRACE
    (44) if -> IF LPAREN conditions RPAREN . LBRACE body RBRACE else_blocks

    LBRACE          shift and go to state 130


state 97

    (48) conditions -> condition opLogic . conditions
    (47) conditions -> . condition
    (48) conditions -> . condition opLogic conditions
    (49) condition -> . valor opSymbol valor
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    condition                      shift and go to state 69
    conditions                     shift and go to state 131
    valor                          shift and go to state 70

state 98

    (58) opLogic -> AND .

    INT             reduce using rule 58 (opLogic -> AND .)
    FLOAT           reduce using rule 58 (opLogic -> AND .)
    VARIABLE        reduce using rule 58 (opLogic -> AND .)
    STRING          reduce using rule 58 (opLogic -> AND .)


state 99

    (59) opLogic -> LOGICAL_AND .

    INT             reduce using rule 59 (opLogic -> LOGICAL_AND .)
    FLOAT           reduce using rule 59 (opLogic -> LOGICAL_AND .)
    VARIABLE        reduce using rule 59 (opLogic -> LOGICAL_AND .)
    STRING          reduce using rule 59 (opLogic -> LOGICAL_AND .)


state 100

    (60) opLogic -> OR .

    INT             reduce using rule 60 (opLogic -> OR .)
    FLOAT           reduce using rule 60 (opLogic -> OR .)
    VARIABLE        reduce using rule 60 (opLogic -> OR .)
    STRING          reduce using rule 60 (opLogic -> OR .)


state 101

    (61) opLogic -> LOGICAL_OR .

    INT             reduce using rule 61 (opLogic -> LOGICAL_OR .)
    FLOAT           reduce using rule 61 (opLogic -> LOGICAL_OR .)
    VARIABLE        reduce using rule 61 (opLogic -> LOGICAL_OR .)
    STRING          reduce using rule 61 (opLogic -> LOGICAL_OR .)


state 102

    (62) opLogic -> NOT .

    INT             reduce using rule 62 (opLogic -> NOT .)
    FLOAT           reduce using rule 62 (opLogic -> NOT .)
    VARIABLE        reduce using rule 62 (opLogic -> NOT .)
    STRING          reduce using rule 62 (opLogic -> NOT .)


state 103

    (63) opLogic -> LOGICAL_NOT .

    INT             reduce using rule 63 (opLogic -> LOGICAL_NOT .)
    FLOAT           reduce using rule 63 (opLogic -> LOGICAL_NOT .)
    VARIABLE        reduce using rule 63 (opLogic -> LOGICAL_NOT .)
    STRING          reduce using rule 63 (opLogic -> LOGICAL_NOT .)


state 104

    (49) condition -> valor opSymbol . valor
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    valor                          shift and go to state 132

state 105

    (50) opSymbol -> EQ .

    INT             reduce using rule 50 (opSymbol -> EQ .)
    FLOAT           reduce using rule 50 (opSymbol -> EQ .)
    VARIABLE        reduce using rule 50 (opSymbol -> EQ .)
    STRING          reduce using rule 50 (opSymbol -> EQ .)


state 106

    (51) opSymbol -> NEQ .

    INT             reduce using rule 51 (opSymbol -> NEQ .)
    FLOAT           reduce using rule 51 (opSymbol -> NEQ .)
    VARIABLE        reduce using rule 51 (opSymbol -> NEQ .)
    STRING          reduce using rule 51 (opSymbol -> NEQ .)


state 107

    (52) opSymbol -> STRICTEQ .

    INT             reduce using rule 52 (opSymbol -> STRICTEQ .)
    FLOAT           reduce using rule 52 (opSymbol -> STRICTEQ .)
    VARIABLE        reduce using rule 52 (opSymbol -> STRICTEQ .)
    STRING          reduce using rule 52 (opSymbol -> STRICTEQ .)


state 108

    (53) opSymbol -> STRICTNEQ .

    INT             reduce using rule 53 (opSymbol -> STRICTNEQ .)
    FLOAT           reduce using rule 53 (opSymbol -> STRICTNEQ .)
    VARIABLE        reduce using rule 53 (opSymbol -> STRICTNEQ .)
    STRING          reduce using rule 53 (opSymbol -> STRICTNEQ .)


state 109

    (54) opSymbol -> LT .

    INT             reduce using rule 54 (opSymbol -> LT .)
    FLOAT           reduce using rule 54 (opSymbol -> LT .)
    VARIABLE        reduce using rule 54 (opSymbol -> LT .)
    STRING          reduce using rule 54 (opSymbol -> LT .)


state 110

    (55) opSymbol -> GT .

    INT             reduce using rule 55 (opSymbol -> GT .)
    FLOAT           reduce using rule 55 (opSymbol -> GT .)
    VARIABLE        reduce using rule 55 (opSymbol -> GT .)
    STRING          reduce using rule 55 (opSymbol -> GT .)


state 111

    (56) opSymbol -> LEQ .

    INT             reduce using rule 56 (opSymbol -> LEQ .)
    FLOAT           reduce using rule 56 (opSymbol -> LEQ .)
    VARIABLE        reduce using rule 56 (opSymbol -> LEQ .)
    STRING          reduce using rule 56 (opSymbol -> LEQ .)


state 112

    (57) opSymbol -> GEQ .

    INT             reduce using rule 57 (opSymbol -> GEQ .)
    FLOAT           reduce using rule 57 (opSymbol -> GEQ .)
    VARIABLE        reduce using rule 57 (opSymbol -> GEQ .)
    STRING          reduce using rule 57 (opSymbol -> GEQ .)


state 113

    (72) while -> WHILE LPAREN condition RPAREN . LBRACE body RBRACE
    (73) while -> WHILE LPAREN condition RPAREN . LBRACE RBRACE

    LBRACE          shift and go to state 133


state 114

    (74) switch -> SWITCH LPAREN valor RPAREN . LBRACE caseLists RBRACE

    LBRACE          shift and go to state 134


state 115

    (69) forStatement -> FOR LPAREN forcondition RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 135


state 116

    (70) forcondition -> VARIABLE EQUALS . INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (71) forcondition -> VARIABLE EQUALS . INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    INT             shift and go to state 136


state 117

    (11) asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN . RPAREN SEMICOLON

    RPAREN          shift and go to state 137


state 118

    (84) array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 138


state 119

    (90) map -> VARIABLE EQUALS LBRACKET maps RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 139


state 120

    (87) arrays -> LBRACKET repiteValores RBRACKET .

    SEMICOLON       reduce using rule 87 (arrays -> LBRACKET repiteValores RBRACKET .)
    COMMA           reduce using rule 87 (arrays -> LBRACKET repiteValores RBRACKET .)
    RBRACKET        reduce using rule 87 (arrays -> LBRACKET repiteValores RBRACKET .)


state 121

    (89) arrayAnidado -> arrays COMMA . arrayAnidado
    (88) arrayAnidado -> . arrays
    (89) arrayAnidado -> . arrays COMMA arrayAnidado
    (87) arrays -> . LBRACKET repiteValores RBRACKET

    LBRACKET        shift and go to state 78

    arrays                         shift and go to state 82
    arrayAnidado                   shift and go to state 140

state 122

    (93) maps -> mapArrow COMMA . maps
    (92) maps -> . mapArrow
    (93) maps -> . mapArrow COMMA maps
    (94) mapArrow -> . valor ARROWMAP valor
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    mapArrow                       shift and go to state 83
    maps                           shift and go to state 141
    valor                          shift and go to state 142

state 123

    (94) mapArrow -> valor ARROWMAP . valor
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    valor                          shift and go to state 143

state 124

    (85) array -> VARIABLE EQUALS ARRAY LPAREN repiteValores . RPAREN SEMICOLON

    RPAREN          shift and go to state 144


state 125

    (91) map -> VARIABLE EQUALS ARRAY LPAREN maps . RPAREN SEMICOLON

    RPAREN          shift and go to state 145


state 126

    (13) operaArit -> valor operador operaArit .

    SEMICOLON       reduce using rule 13 (operaArit -> valor operador operaArit .)


state 127

    (96) try -> TRY LBRACE body RBRACE catchs .
    (97) try -> TRY LBRACE body RBRACE catchs . FINALLY LBRACE body RBRACE

    VARIABLE        reduce using rule 96 (try -> TRY LBRACE body RBRACE catchs .)
    ECHO            reduce using rule 96 (try -> TRY LBRACE body RBRACE catchs .)
    PRINT           reduce using rule 96 (try -> TRY LBRACE body RBRACE catchs .)
    TRY             reduce using rule 96 (try -> TRY LBRACE body RBRACE catchs .)
    INT             reduce using rule 96 (try -> TRY LBRACE body RBRACE catchs .)
    FLOAT           reduce using rule 96 (try -> TRY LBRACE body RBRACE catchs .)
    STRING          reduce using rule 96 (try -> TRY LBRACE body RBRACE catchs .)
    IF              reduce using rule 96 (try -> TRY LBRACE body RBRACE catchs .)
    WHILE           reduce using rule 96 (try -> TRY LBRACE body RBRACE catchs .)
    SWITCH          reduce using rule 96 (try -> TRY LBRACE body RBRACE catchs .)
    FOR             reduce using rule 96 (try -> TRY LBRACE body RBRACE catchs .)
    CLOSETAG        reduce using rule 96 (try -> TRY LBRACE body RBRACE catchs .)
    RBRACE          reduce using rule 96 (try -> TRY LBRACE body RBRACE catchs .)
    BREAK           reduce using rule 96 (try -> TRY LBRACE body RBRACE catchs .)
    FINALLY         shift and go to state 146


state 128

    (99) catchs -> catch .
    (100) catchs -> catch . catchs
    (99) catchs -> . catch
    (100) catchs -> . catch catchs
    (98) catch -> . CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE

    FINALLY         reduce using rule 99 (catchs -> catch .)
    VARIABLE        reduce using rule 99 (catchs -> catch .)
    ECHO            reduce using rule 99 (catchs -> catch .)
    PRINT           reduce using rule 99 (catchs -> catch .)
    TRY             reduce using rule 99 (catchs -> catch .)
    INT             reduce using rule 99 (catchs -> catch .)
    FLOAT           reduce using rule 99 (catchs -> catch .)
    STRING          reduce using rule 99 (catchs -> catch .)
    IF              reduce using rule 99 (catchs -> catch .)
    WHILE           reduce using rule 99 (catchs -> catch .)
    SWITCH          reduce using rule 99 (catchs -> catch .)
    FOR             reduce using rule 99 (catchs -> catch .)
    CLOSETAG        reduce using rule 99 (catchs -> catch .)
    RBRACE          reduce using rule 99 (catchs -> catch .)
    BREAK           reduce using rule 99 (catchs -> catch .)
    CATCH           shift and go to state 129

    catch                          shift and go to state 128
    catchs                         shift and go to state 147

state 129

    (98) catch -> CATCH . LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 148


state 130

    (43) if -> IF LPAREN conditions RPAREN LBRACE . body RBRACE
    (44) if -> IF LPAREN conditions RPAREN LBRACE . body RBRACE else_blocks
    (64) body -> . sentenciaList
    (65) body -> . empty
    (66) sentenciaList -> . sentencia
    (67) sentenciaList -> . sentencia sentenciaList
    (36) empty -> .
    (4) sentencia -> . asignacion
    (5) sentencia -> . asignacion_fgets
    (6) sentencia -> . comparacion
    (7) sentencia -> . impresion
    (8) sentencia -> . estructurasPrograma
    (9) sentencia -> . try
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (23) comparacion -> . valor comparador valor
    (28) impresion -> . ECHO imprimir SEMICOLON
    (29) impresion -> . PRINT imprimir SEMICOLON
    (37) estructurasPrograma -> . controlStructure
    (38) estructurasPrograma -> . dataStructure
    (96) try -> . TRY LBRACE body RBRACE catchs
    (97) try -> . TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING
    (39) controlStructure -> . if
    (40) controlStructure -> . for
    (41) controlStructure -> . while
    (42) controlStructure -> . switch
    (82) dataStructure -> . array
    (43) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE
    (44) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
    (68) for -> . forStatement
    (72) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (73) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (74) switch -> . SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE
    (83) array -> . VARIABLE EQUALS arrays SEMICOLON
    (84) array -> . VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (86) array -> . map
    (69) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (90) map -> . VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON
    (91) map -> . VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON

    RBRACE          reduce using rule 36 (empty -> .)
    VARIABLE        shift and go to state 11
    ECHO            shift and go to state 13
    PRINT           shift and go to state 14
    TRY             shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    SWITCH          shift and go to state 29
    FOR             shift and go to state 31

    body                           shift and go to state 149
    sentenciaList                  shift and go to state 65
    empty                          shift and go to state 66
    sentencia                      shift and go to state 67
    asignacion                     shift and go to state 5
    asignacion_fgets               shift and go to state 6
    comparacion                    shift and go to state 7
    impresion                      shift and go to state 8
    estructurasPrograma            shift and go to state 9
    try                            shift and go to state 10
    valor                          shift and go to state 12
    controlStructure               shift and go to state 15
    dataStructure                  shift and go to state 16
    if                             shift and go to state 21
    for                            shift and go to state 22
    while                          shift and go to state 23
    switch                         shift and go to state 24
    array                          shift and go to state 25
    forStatement                   shift and go to state 27
    map                            shift and go to state 30

state 131

    (48) conditions -> condition opLogic conditions .

    RPAREN          reduce using rule 48 (conditions -> condition opLogic conditions .)


state 132

    (49) condition -> valor opSymbol valor .

    AND             reduce using rule 49 (condition -> valor opSymbol valor .)
    LOGICAL_AND     reduce using rule 49 (condition -> valor opSymbol valor .)
    OR              reduce using rule 49 (condition -> valor opSymbol valor .)
    LOGICAL_OR      reduce using rule 49 (condition -> valor opSymbol valor .)
    NOT             reduce using rule 49 (condition -> valor opSymbol valor .)
    LOGICAL_NOT     reduce using rule 49 (condition -> valor opSymbol valor .)
    RPAREN          reduce using rule 49 (condition -> valor opSymbol valor .)


state 133

    (72) while -> WHILE LPAREN condition RPAREN LBRACE . body RBRACE
    (73) while -> WHILE LPAREN condition RPAREN LBRACE . RBRACE
    (64) body -> . sentenciaList
    (65) body -> . empty
    (66) sentenciaList -> . sentencia
    (67) sentenciaList -> . sentencia sentenciaList
    (36) empty -> .
    (4) sentencia -> . asignacion
    (5) sentencia -> . asignacion_fgets
    (6) sentencia -> . comparacion
    (7) sentencia -> . impresion
    (8) sentencia -> . estructurasPrograma
    (9) sentencia -> . try
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (23) comparacion -> . valor comparador valor
    (28) impresion -> . ECHO imprimir SEMICOLON
    (29) impresion -> . PRINT imprimir SEMICOLON
    (37) estructurasPrograma -> . controlStructure
    (38) estructurasPrograma -> . dataStructure
    (96) try -> . TRY LBRACE body RBRACE catchs
    (97) try -> . TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING
    (39) controlStructure -> . if
    (40) controlStructure -> . for
    (41) controlStructure -> . while
    (42) controlStructure -> . switch
    (82) dataStructure -> . array
    (43) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE
    (44) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
    (68) for -> . forStatement
    (72) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (73) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (74) switch -> . SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE
    (83) array -> . VARIABLE EQUALS arrays SEMICOLON
    (84) array -> . VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (86) array -> . map
    (69) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (90) map -> . VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON
    (91) map -> . VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON

  ! shift/reduce conflict for RBRACE resolved as shift
    RBRACE          shift and go to state 151
    VARIABLE        shift and go to state 11
    ECHO            shift and go to state 13
    PRINT           shift and go to state 14
    TRY             shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    SWITCH          shift and go to state 29
    FOR             shift and go to state 31

  ! RBRACE          [ reduce using rule 36 (empty -> .) ]

    body                           shift and go to state 150
    sentenciaList                  shift and go to state 65
    empty                          shift and go to state 66
    sentencia                      shift and go to state 67
    asignacion                     shift and go to state 5
    asignacion_fgets               shift and go to state 6
    comparacion                    shift and go to state 7
    impresion                      shift and go to state 8
    estructurasPrograma            shift and go to state 9
    try                            shift and go to state 10
    valor                          shift and go to state 12
    controlStructure               shift and go to state 15
    dataStructure                  shift and go to state 16
    if                             shift and go to state 21
    for                            shift and go to state 22
    while                          shift and go to state 23
    switch                         shift and go to state 24
    array                          shift and go to state 25
    forStatement                   shift and go to state 27
    map                            shift and go to state 30

state 134

    (74) switch -> SWITCH LPAREN valor RPAREN LBRACE . caseLists RBRACE
    (75) caseLists -> . cases
    (76) caseLists -> . cases default
    (77) caseLists -> . default
    (78) caseLists -> . empty
    (79) cases -> . case
    (80) cases -> . case cases
    (95) default -> . DEFAULT COLON body BREAK SEMICOLON
    (36) empty -> .
    (81) case -> . CASE valor COLON body BREAK SEMICOLON

    DEFAULT         shift and go to state 157
    RBRACE          reduce using rule 36 (empty -> .)
    CASE            shift and go to state 158

    caseLists                      shift and go to state 152
    cases                          shift and go to state 153
    default                        shift and go to state 154
    empty                          shift and go to state 155
    case                           shift and go to state 156

state 135

    (69) forStatement -> FOR LPAREN forcondition RPAREN LBRACE . body RBRACE
    (64) body -> . sentenciaList
    (65) body -> . empty
    (66) sentenciaList -> . sentencia
    (67) sentenciaList -> . sentencia sentenciaList
    (36) empty -> .
    (4) sentencia -> . asignacion
    (5) sentencia -> . asignacion_fgets
    (6) sentencia -> . comparacion
    (7) sentencia -> . impresion
    (8) sentencia -> . estructurasPrograma
    (9) sentencia -> . try
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (23) comparacion -> . valor comparador valor
    (28) impresion -> . ECHO imprimir SEMICOLON
    (29) impresion -> . PRINT imprimir SEMICOLON
    (37) estructurasPrograma -> . controlStructure
    (38) estructurasPrograma -> . dataStructure
    (96) try -> . TRY LBRACE body RBRACE catchs
    (97) try -> . TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING
    (39) controlStructure -> . if
    (40) controlStructure -> . for
    (41) controlStructure -> . while
    (42) controlStructure -> . switch
    (82) dataStructure -> . array
    (43) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE
    (44) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
    (68) for -> . forStatement
    (72) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (73) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (74) switch -> . SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE
    (83) array -> . VARIABLE EQUALS arrays SEMICOLON
    (84) array -> . VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (86) array -> . map
    (69) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (90) map -> . VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON
    (91) map -> . VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON

    RBRACE          reduce using rule 36 (empty -> .)
    VARIABLE        shift and go to state 11
    ECHO            shift and go to state 13
    PRINT           shift and go to state 14
    TRY             shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    SWITCH          shift and go to state 29
    FOR             shift and go to state 31

    body                           shift and go to state 159
    sentenciaList                  shift and go to state 65
    empty                          shift and go to state 66
    sentencia                      shift and go to state 67
    asignacion                     shift and go to state 5
    asignacion_fgets               shift and go to state 6
    comparacion                    shift and go to state 7
    impresion                      shift and go to state 8
    estructurasPrograma            shift and go to state 9
    try                            shift and go to state 10
    valor                          shift and go to state 12
    controlStructure               shift and go to state 15
    dataStructure                  shift and go to state 16
    if                             shift and go to state 21
    for                            shift and go to state 22
    while                          shift and go to state 23
    switch                         shift and go to state 24
    array                          shift and go to state 25
    forStatement                   shift and go to state 27
    map                            shift and go to state 30

state 136

    (70) forcondition -> VARIABLE EQUALS INT . SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (71) forcondition -> VARIABLE EQUALS INT . SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    SEMICOLON       shift and go to state 160


state 137

    (11) asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 161


state 138

    (84) array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .

    VARIABLE        reduce using rule 84 (array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .)
    ECHO            reduce using rule 84 (array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .)
    PRINT           reduce using rule 84 (array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .)
    TRY             reduce using rule 84 (array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .)
    INT             reduce using rule 84 (array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 84 (array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .)
    STRING          reduce using rule 84 (array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .)
    IF              reduce using rule 84 (array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .)
    WHILE           reduce using rule 84 (array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .)
    SWITCH          reduce using rule 84 (array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .)
    FOR             reduce using rule 84 (array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .)
    CLOSETAG        reduce using rule 84 (array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 84 (array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .)
    BREAK           reduce using rule 84 (array -> VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON .)


state 139

    (90) map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .

    VARIABLE        reduce using rule 90 (map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .)
    ECHO            reduce using rule 90 (map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .)
    PRINT           reduce using rule 90 (map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .)
    TRY             reduce using rule 90 (map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .)
    INT             reduce using rule 90 (map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 90 (map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .)
    STRING          reduce using rule 90 (map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .)
    IF              reduce using rule 90 (map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .)
    WHILE           reduce using rule 90 (map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .)
    SWITCH          reduce using rule 90 (map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .)
    FOR             reduce using rule 90 (map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .)
    CLOSETAG        reduce using rule 90 (map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 90 (map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .)
    BREAK           reduce using rule 90 (map -> VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON .)


state 140

    (89) arrayAnidado -> arrays COMMA arrayAnidado .

    RBRACKET        reduce using rule 89 (arrayAnidado -> arrays COMMA arrayAnidado .)


state 141

    (93) maps -> mapArrow COMMA maps .

    RBRACKET        reduce using rule 93 (maps -> mapArrow COMMA maps .)
    RPAREN          reduce using rule 93 (maps -> mapArrow COMMA maps .)


state 142

    (94) mapArrow -> valor . ARROWMAP valor

    ARROWMAP        shift and go to state 123


state 143

    (94) mapArrow -> valor ARROWMAP valor .

    COMMA           reduce using rule 94 (mapArrow -> valor ARROWMAP valor .)
    RBRACKET        reduce using rule 94 (mapArrow -> valor ARROWMAP valor .)
    RPAREN          reduce using rule 94 (mapArrow -> valor ARROWMAP valor .)


state 144

    (85) array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 162


state 145

    (91) map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 163


state 146

    (97) try -> TRY LBRACE body RBRACE catchs FINALLY . LBRACE body RBRACE

    LBRACE          shift and go to state 164


state 147

    (100) catchs -> catch catchs .

    FINALLY         reduce using rule 100 (catchs -> catch catchs .)
    VARIABLE        reduce using rule 100 (catchs -> catch catchs .)
    ECHO            reduce using rule 100 (catchs -> catch catchs .)
    PRINT           reduce using rule 100 (catchs -> catch catchs .)
    TRY             reduce using rule 100 (catchs -> catch catchs .)
    INT             reduce using rule 100 (catchs -> catch catchs .)
    FLOAT           reduce using rule 100 (catchs -> catch catchs .)
    STRING          reduce using rule 100 (catchs -> catch catchs .)
    IF              reduce using rule 100 (catchs -> catch catchs .)
    WHILE           reduce using rule 100 (catchs -> catch catchs .)
    SWITCH          reduce using rule 100 (catchs -> catch catchs .)
    FOR             reduce using rule 100 (catchs -> catch catchs .)
    CLOSETAG        reduce using rule 100 (catchs -> catch catchs .)
    RBRACE          reduce using rule 100 (catchs -> catch catchs .)
    BREAK           reduce using rule 100 (catchs -> catch catchs .)


state 148

    (98) catch -> CATCH LPAREN . EXCEPTION VARIABLE RPAREN LBRACE body RBRACE

    EXCEPTION       shift and go to state 165


state 149

    (43) if -> IF LPAREN conditions RPAREN LBRACE body . RBRACE
    (44) if -> IF LPAREN conditions RPAREN LBRACE body . RBRACE else_blocks

    RBRACE          shift and go to state 166


state 150

    (72) while -> WHILE LPAREN condition RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 167


state 151

    (73) while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .

    VARIABLE        reduce using rule 73 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    ECHO            reduce using rule 73 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    PRINT           reduce using rule 73 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    TRY             reduce using rule 73 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    INT             reduce using rule 73 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    FLOAT           reduce using rule 73 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    STRING          reduce using rule 73 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    IF              reduce using rule 73 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    WHILE           reduce using rule 73 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    SWITCH          reduce using rule 73 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    FOR             reduce using rule 73 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    CLOSETAG        reduce using rule 73 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    RBRACE          reduce using rule 73 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    BREAK           reduce using rule 73 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)


state 152

    (74) switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists . RBRACE

    RBRACE          shift and go to state 168


state 153

    (75) caseLists -> cases .
    (76) caseLists -> cases . default
    (95) default -> . DEFAULT COLON body BREAK SEMICOLON

    RBRACE          reduce using rule 75 (caseLists -> cases .)
    DEFAULT         shift and go to state 157

    default                        shift and go to state 169

state 154

    (77) caseLists -> default .

    RBRACE          reduce using rule 77 (caseLists -> default .)


state 155

    (78) caseLists -> empty .

    RBRACE          reduce using rule 78 (caseLists -> empty .)


state 156

    (79) cases -> case .
    (80) cases -> case . cases
    (79) cases -> . case
    (80) cases -> . case cases
    (81) case -> . CASE valor COLON body BREAK SEMICOLON

    DEFAULT         reduce using rule 79 (cases -> case .)
    RBRACE          reduce using rule 79 (cases -> case .)
    CASE            shift and go to state 158

    case                           shift and go to state 156
    cases                          shift and go to state 170

state 157

    (95) default -> DEFAULT . COLON body BREAK SEMICOLON

    COLON           shift and go to state 171


state 158

    (81) case -> CASE . valor COLON body BREAK SEMICOLON
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    valor                          shift and go to state 172

state 159

    (69) forStatement -> FOR LPAREN forcondition RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 173


state 160

    (70) forcondition -> VARIABLE EQUALS INT SEMICOLON . VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (71) forcondition -> VARIABLE EQUALS INT SEMICOLON . VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    VARIABLE        shift and go to state 174


state 161

    (11) asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .

    VARIABLE        reduce using rule 11 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    ECHO            reduce using rule 11 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    PRINT           reduce using rule 11 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    TRY             reduce using rule 11 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    INT             reduce using rule 11 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FLOAT           reduce using rule 11 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    STRING          reduce using rule 11 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    IF              reduce using rule 11 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    WHILE           reduce using rule 11 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    SWITCH          reduce using rule 11 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    FOR             reduce using rule 11 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    CLOSETAG        reduce using rule 11 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 11 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)
    BREAK           reduce using rule 11 (asignacion_fgets -> VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON .)


state 162

    (85) array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .

    VARIABLE        reduce using rule 85 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    ECHO            reduce using rule 85 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    PRINT           reduce using rule 85 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    TRY             reduce using rule 85 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    INT             reduce using rule 85 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    FLOAT           reduce using rule 85 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    STRING          reduce using rule 85 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    IF              reduce using rule 85 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    WHILE           reduce using rule 85 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    SWITCH          reduce using rule 85 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    FOR             reduce using rule 85 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    CLOSETAG        reduce using rule 85 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    RBRACE          reduce using rule 85 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    BREAK           reduce using rule 85 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)


state 163

    (91) map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .

    VARIABLE        reduce using rule 91 (map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .)
    ECHO            reduce using rule 91 (map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .)
    PRINT           reduce using rule 91 (map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .)
    TRY             reduce using rule 91 (map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .)
    INT             reduce using rule 91 (map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .)
    FLOAT           reduce using rule 91 (map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .)
    STRING          reduce using rule 91 (map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .)
    IF              reduce using rule 91 (map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .)
    WHILE           reduce using rule 91 (map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .)
    SWITCH          reduce using rule 91 (map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .)
    FOR             reduce using rule 91 (map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .)
    CLOSETAG        reduce using rule 91 (map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .)
    RBRACE          reduce using rule 91 (map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .)
    BREAK           reduce using rule 91 (map -> VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON .)


state 164

    (97) try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE . body RBRACE
    (64) body -> . sentenciaList
    (65) body -> . empty
    (66) sentenciaList -> . sentencia
    (67) sentenciaList -> . sentencia sentenciaList
    (36) empty -> .
    (4) sentencia -> . asignacion
    (5) sentencia -> . asignacion_fgets
    (6) sentencia -> . comparacion
    (7) sentencia -> . impresion
    (8) sentencia -> . estructurasPrograma
    (9) sentencia -> . try
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (23) comparacion -> . valor comparador valor
    (28) impresion -> . ECHO imprimir SEMICOLON
    (29) impresion -> . PRINT imprimir SEMICOLON
    (37) estructurasPrograma -> . controlStructure
    (38) estructurasPrograma -> . dataStructure
    (96) try -> . TRY LBRACE body RBRACE catchs
    (97) try -> . TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING
    (39) controlStructure -> . if
    (40) controlStructure -> . for
    (41) controlStructure -> . while
    (42) controlStructure -> . switch
    (82) dataStructure -> . array
    (43) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE
    (44) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
    (68) for -> . forStatement
    (72) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (73) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (74) switch -> . SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE
    (83) array -> . VARIABLE EQUALS arrays SEMICOLON
    (84) array -> . VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (86) array -> . map
    (69) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (90) map -> . VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON
    (91) map -> . VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON

    RBRACE          reduce using rule 36 (empty -> .)
    VARIABLE        shift and go to state 11
    ECHO            shift and go to state 13
    PRINT           shift and go to state 14
    TRY             shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    SWITCH          shift and go to state 29
    FOR             shift and go to state 31

    body                           shift and go to state 175
    sentenciaList                  shift and go to state 65
    empty                          shift and go to state 66
    sentencia                      shift and go to state 67
    asignacion                     shift and go to state 5
    asignacion_fgets               shift and go to state 6
    comparacion                    shift and go to state 7
    impresion                      shift and go to state 8
    estructurasPrograma            shift and go to state 9
    try                            shift and go to state 10
    valor                          shift and go to state 12
    controlStructure               shift and go to state 15
    dataStructure                  shift and go to state 16
    if                             shift and go to state 21
    for                            shift and go to state 22
    while                          shift and go to state 23
    switch                         shift and go to state 24
    array                          shift and go to state 25
    forStatement                   shift and go to state 27
    map                            shift and go to state 30

state 165

    (98) catch -> CATCH LPAREN EXCEPTION . VARIABLE RPAREN LBRACE body RBRACE

    VARIABLE        shift and go to state 176


state 166

    (43) if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .
    (44) if -> IF LPAREN conditions RPAREN LBRACE body RBRACE . else_blocks
    (45) else_blocks -> . ELSE LBRACE body RBRACE
    (46) else_blocks -> . ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks

    VARIABLE        reduce using rule 43 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .)
    ECHO            reduce using rule 43 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 43 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .)
    TRY             reduce using rule 43 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 43 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .)
    FLOAT           reduce using rule 43 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 43 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 43 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 43 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .)
    SWITCH          reduce using rule 43 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 43 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .)
    CLOSETAG        reduce using rule 43 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 43 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .)
    BREAK           reduce using rule 43 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE .)
    ELSE            shift and go to state 178
    ELSEIF          shift and go to state 179

    else_blocks                    shift and go to state 177

state 167

    (72) while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .

    VARIABLE        reduce using rule 72 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    ECHO            reduce using rule 72 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 72 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    TRY             reduce using rule 72 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 72 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    FLOAT           reduce using rule 72 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 72 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 72 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 72 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    SWITCH          reduce using rule 72 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 72 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    CLOSETAG        reduce using rule 72 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 72 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    BREAK           reduce using rule 72 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)


state 168

    (74) switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .

    VARIABLE        reduce using rule 74 (switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .)
    ECHO            reduce using rule 74 (switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .)
    PRINT           reduce using rule 74 (switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .)
    TRY             reduce using rule 74 (switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .)
    INT             reduce using rule 74 (switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .)
    FLOAT           reduce using rule 74 (switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .)
    STRING          reduce using rule 74 (switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .)
    IF              reduce using rule 74 (switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .)
    WHILE           reduce using rule 74 (switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .)
    SWITCH          reduce using rule 74 (switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .)
    FOR             reduce using rule 74 (switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .)
    CLOSETAG        reduce using rule 74 (switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .)
    RBRACE          reduce using rule 74 (switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .)
    BREAK           reduce using rule 74 (switch -> SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE .)


state 169

    (76) caseLists -> cases default .

    RBRACE          reduce using rule 76 (caseLists -> cases default .)


state 170

    (80) cases -> case cases .

    DEFAULT         reduce using rule 80 (cases -> case cases .)
    RBRACE          reduce using rule 80 (cases -> case cases .)


state 171

    (95) default -> DEFAULT COLON . body BREAK SEMICOLON
    (64) body -> . sentenciaList
    (65) body -> . empty
    (66) sentenciaList -> . sentencia
    (67) sentenciaList -> . sentencia sentenciaList
    (36) empty -> .
    (4) sentencia -> . asignacion
    (5) sentencia -> . asignacion_fgets
    (6) sentencia -> . comparacion
    (7) sentencia -> . impresion
    (8) sentencia -> . estructurasPrograma
    (9) sentencia -> . try
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (23) comparacion -> . valor comparador valor
    (28) impresion -> . ECHO imprimir SEMICOLON
    (29) impresion -> . PRINT imprimir SEMICOLON
    (37) estructurasPrograma -> . controlStructure
    (38) estructurasPrograma -> . dataStructure
    (96) try -> . TRY LBRACE body RBRACE catchs
    (97) try -> . TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING
    (39) controlStructure -> . if
    (40) controlStructure -> . for
    (41) controlStructure -> . while
    (42) controlStructure -> . switch
    (82) dataStructure -> . array
    (43) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE
    (44) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
    (68) for -> . forStatement
    (72) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (73) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (74) switch -> . SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE
    (83) array -> . VARIABLE EQUALS arrays SEMICOLON
    (84) array -> . VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (86) array -> . map
    (69) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (90) map -> . VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON
    (91) map -> . VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON

    BREAK           reduce using rule 36 (empty -> .)
    VARIABLE        shift and go to state 11
    ECHO            shift and go to state 13
    PRINT           shift and go to state 14
    TRY             shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    SWITCH          shift and go to state 29
    FOR             shift and go to state 31

    body                           shift and go to state 180
    sentenciaList                  shift and go to state 65
    empty                          shift and go to state 66
    sentencia                      shift and go to state 67
    asignacion                     shift and go to state 5
    asignacion_fgets               shift and go to state 6
    comparacion                    shift and go to state 7
    impresion                      shift and go to state 8
    estructurasPrograma            shift and go to state 9
    try                            shift and go to state 10
    valor                          shift and go to state 12
    controlStructure               shift and go to state 15
    dataStructure                  shift and go to state 16
    if                             shift and go to state 21
    for                            shift and go to state 22
    while                          shift and go to state 23
    switch                         shift and go to state 24
    array                          shift and go to state 25
    forStatement                   shift and go to state 27
    map                            shift and go to state 30

state 172

    (81) case -> CASE valor . COLON body BREAK SEMICOLON

    COLON           shift and go to state 181


state 173

    (69) forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .

    VARIABLE        reduce using rule 69 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    ECHO            reduce using rule 69 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 69 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    TRY             reduce using rule 69 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 69 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    FLOAT           reduce using rule 69 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 69 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 69 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 69 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    SWITCH          reduce using rule 69 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 69 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    CLOSETAG        reduce using rule 69 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 69 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    BREAK           reduce using rule 69 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)


state 174

    (70) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE . opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (71) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE . opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS
    (50) opSymbol -> . EQ
    (51) opSymbol -> . NEQ
    (52) opSymbol -> . STRICTEQ
    (53) opSymbol -> . STRICTNEQ
    (54) opSymbol -> . LT
    (55) opSymbol -> . GT
    (56) opSymbol -> . LEQ
    (57) opSymbol -> . GEQ

    EQ              shift and go to state 105
    NEQ             shift and go to state 106
    STRICTEQ        shift and go to state 107
    STRICTNEQ       shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112

    opSymbol                       shift and go to state 182

state 175

    (97) try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body . RBRACE

    RBRACE          shift and go to state 183


state 176

    (98) catch -> CATCH LPAREN EXCEPTION VARIABLE . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 184


state 177

    (44) if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .

    VARIABLE        reduce using rule 44 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    ECHO            reduce using rule 44 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    PRINT           reduce using rule 44 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    TRY             reduce using rule 44 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    INT             reduce using rule 44 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    FLOAT           reduce using rule 44 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    STRING          reduce using rule 44 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    IF              reduce using rule 44 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    WHILE           reduce using rule 44 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    SWITCH          reduce using rule 44 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    FOR             reduce using rule 44 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    CLOSETAG        reduce using rule 44 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    RBRACE          reduce using rule 44 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    BREAK           reduce using rule 44 (if -> IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)


state 178

    (45) else_blocks -> ELSE . LBRACE body RBRACE

    LBRACE          shift and go to state 185


state 179

    (46) else_blocks -> ELSEIF . LPAREN conditions RPAREN LBRACE body RBRACE else_blocks

    LPAREN          shift and go to state 186


state 180

    (95) default -> DEFAULT COLON body . BREAK SEMICOLON

    BREAK           shift and go to state 187


state 181

    (81) case -> CASE valor COLON . body BREAK SEMICOLON
    (64) body -> . sentenciaList
    (65) body -> . empty
    (66) sentenciaList -> . sentencia
    (67) sentenciaList -> . sentencia sentenciaList
    (36) empty -> .
    (4) sentencia -> . asignacion
    (5) sentencia -> . asignacion_fgets
    (6) sentencia -> . comparacion
    (7) sentencia -> . impresion
    (8) sentencia -> . estructurasPrograma
    (9) sentencia -> . try
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (23) comparacion -> . valor comparador valor
    (28) impresion -> . ECHO imprimir SEMICOLON
    (29) impresion -> . PRINT imprimir SEMICOLON
    (37) estructurasPrograma -> . controlStructure
    (38) estructurasPrograma -> . dataStructure
    (96) try -> . TRY LBRACE body RBRACE catchs
    (97) try -> . TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING
    (39) controlStructure -> . if
    (40) controlStructure -> . for
    (41) controlStructure -> . while
    (42) controlStructure -> . switch
    (82) dataStructure -> . array
    (43) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE
    (44) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
    (68) for -> . forStatement
    (72) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (73) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (74) switch -> . SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE
    (83) array -> . VARIABLE EQUALS arrays SEMICOLON
    (84) array -> . VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (86) array -> . map
    (69) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (90) map -> . VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON
    (91) map -> . VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON

    BREAK           reduce using rule 36 (empty -> .)
    VARIABLE        shift and go to state 11
    ECHO            shift and go to state 13
    PRINT           shift and go to state 14
    TRY             shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    SWITCH          shift and go to state 29
    FOR             shift and go to state 31

    valor                          shift and go to state 12
    body                           shift and go to state 188
    sentenciaList                  shift and go to state 65
    empty                          shift and go to state 66
    sentencia                      shift and go to state 67
    asignacion                     shift and go to state 5
    asignacion_fgets               shift and go to state 6
    comparacion                    shift and go to state 7
    impresion                      shift and go to state 8
    estructurasPrograma            shift and go to state 9
    try                            shift and go to state 10
    controlStructure               shift and go to state 15
    dataStructure                  shift and go to state 16
    if                             shift and go to state 21
    for                            shift and go to state 22
    while                          shift and go to state 23
    switch                         shift and go to state 24
    array                          shift and go to state 25
    forStatement                   shift and go to state 27
    map                            shift and go to state 30

state 182

    (70) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol . INT SEMICOLON VARIABLE DOUBLEPLUS
    (71) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol . INT SEMICOLON VARIABLE DOUBLEMINUS

    INT             shift and go to state 189


state 183

    (97) try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .

    VARIABLE        reduce using rule 97 (try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .)
    ECHO            reduce using rule 97 (try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .)
    PRINT           reduce using rule 97 (try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .)
    TRY             reduce using rule 97 (try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .)
    INT             reduce using rule 97 (try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .)
    FLOAT           reduce using rule 97 (try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .)
    STRING          reduce using rule 97 (try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .)
    IF              reduce using rule 97 (try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .)
    WHILE           reduce using rule 97 (try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .)
    SWITCH          reduce using rule 97 (try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .)
    FOR             reduce using rule 97 (try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .)
    CLOSETAG        reduce using rule 97 (try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .)
    RBRACE          reduce using rule 97 (try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .)
    BREAK           reduce using rule 97 (try -> TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE .)


state 184

    (98) catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 190


state 185

    (45) else_blocks -> ELSE LBRACE . body RBRACE
    (64) body -> . sentenciaList
    (65) body -> . empty
    (66) sentenciaList -> . sentencia
    (67) sentenciaList -> . sentencia sentenciaList
    (36) empty -> .
    (4) sentencia -> . asignacion
    (5) sentencia -> . asignacion_fgets
    (6) sentencia -> . comparacion
    (7) sentencia -> . impresion
    (8) sentencia -> . estructurasPrograma
    (9) sentencia -> . try
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (23) comparacion -> . valor comparador valor
    (28) impresion -> . ECHO imprimir SEMICOLON
    (29) impresion -> . PRINT imprimir SEMICOLON
    (37) estructurasPrograma -> . controlStructure
    (38) estructurasPrograma -> . dataStructure
    (96) try -> . TRY LBRACE body RBRACE catchs
    (97) try -> . TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING
    (39) controlStructure -> . if
    (40) controlStructure -> . for
    (41) controlStructure -> . while
    (42) controlStructure -> . switch
    (82) dataStructure -> . array
    (43) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE
    (44) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
    (68) for -> . forStatement
    (72) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (73) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (74) switch -> . SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE
    (83) array -> . VARIABLE EQUALS arrays SEMICOLON
    (84) array -> . VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (86) array -> . map
    (69) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (90) map -> . VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON
    (91) map -> . VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON

    RBRACE          reduce using rule 36 (empty -> .)
    VARIABLE        shift and go to state 11
    ECHO            shift and go to state 13
    PRINT           shift and go to state 14
    TRY             shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    SWITCH          shift and go to state 29
    FOR             shift and go to state 31

    body                           shift and go to state 191
    sentenciaList                  shift and go to state 65
    empty                          shift and go to state 66
    sentencia                      shift and go to state 67
    asignacion                     shift and go to state 5
    asignacion_fgets               shift and go to state 6
    comparacion                    shift and go to state 7
    impresion                      shift and go to state 8
    estructurasPrograma            shift and go to state 9
    try                            shift and go to state 10
    valor                          shift and go to state 12
    controlStructure               shift and go to state 15
    dataStructure                  shift and go to state 16
    if                             shift and go to state 21
    for                            shift and go to state 22
    while                          shift and go to state 23
    switch                         shift and go to state 24
    array                          shift and go to state 25
    forStatement                   shift and go to state 27
    map                            shift and go to state 30

state 186

    (46) else_blocks -> ELSEIF LPAREN . conditions RPAREN LBRACE body RBRACE else_blocks
    (47) conditions -> . condition
    (48) conditions -> . condition opLogic conditions
    (49) condition -> . valor opSymbol valor
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    VARIABLE        shift and go to state 45
    STRING          shift and go to state 20

    conditions                     shift and go to state 192
    condition                      shift and go to state 69
    valor                          shift and go to state 70

state 187

    (95) default -> DEFAULT COLON body BREAK . SEMICOLON

    SEMICOLON       shift and go to state 193


state 188

    (81) case -> CASE valor COLON body . BREAK SEMICOLON

    BREAK           shift and go to state 194


state 189

    (70) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT . SEMICOLON VARIABLE DOUBLEPLUS
    (71) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT . SEMICOLON VARIABLE DOUBLEMINUS

    SEMICOLON       shift and go to state 195


state 190

    (98) catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE . body RBRACE
    (64) body -> . sentenciaList
    (65) body -> . empty
    (66) sentenciaList -> . sentencia
    (67) sentenciaList -> . sentencia sentenciaList
    (36) empty -> .
    (4) sentencia -> . asignacion
    (5) sentencia -> . asignacion_fgets
    (6) sentencia -> . comparacion
    (7) sentencia -> . impresion
    (8) sentencia -> . estructurasPrograma
    (9) sentencia -> . try
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (23) comparacion -> . valor comparador valor
    (28) impresion -> . ECHO imprimir SEMICOLON
    (29) impresion -> . PRINT imprimir SEMICOLON
    (37) estructurasPrograma -> . controlStructure
    (38) estructurasPrograma -> . dataStructure
    (96) try -> . TRY LBRACE body RBRACE catchs
    (97) try -> . TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING
    (39) controlStructure -> . if
    (40) controlStructure -> . for
    (41) controlStructure -> . while
    (42) controlStructure -> . switch
    (82) dataStructure -> . array
    (43) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE
    (44) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
    (68) for -> . forStatement
    (72) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (73) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (74) switch -> . SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE
    (83) array -> . VARIABLE EQUALS arrays SEMICOLON
    (84) array -> . VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (86) array -> . map
    (69) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (90) map -> . VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON
    (91) map -> . VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON

    RBRACE          reduce using rule 36 (empty -> .)
    VARIABLE        shift and go to state 11
    ECHO            shift and go to state 13
    PRINT           shift and go to state 14
    TRY             shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    SWITCH          shift and go to state 29
    FOR             shift and go to state 31

    body                           shift and go to state 196
    sentenciaList                  shift and go to state 65
    empty                          shift and go to state 66
    sentencia                      shift and go to state 67
    asignacion                     shift and go to state 5
    asignacion_fgets               shift and go to state 6
    comparacion                    shift and go to state 7
    impresion                      shift and go to state 8
    estructurasPrograma            shift and go to state 9
    try                            shift and go to state 10
    valor                          shift and go to state 12
    controlStructure               shift and go to state 15
    dataStructure                  shift and go to state 16
    if                             shift and go to state 21
    for                            shift and go to state 22
    while                          shift and go to state 23
    switch                         shift and go to state 24
    array                          shift and go to state 25
    forStatement                   shift and go to state 27
    map                            shift and go to state 30

state 191

    (45) else_blocks -> ELSE LBRACE body . RBRACE

    RBRACE          shift and go to state 197


state 192

    (46) else_blocks -> ELSEIF LPAREN conditions . RPAREN LBRACE body RBRACE else_blocks

    RPAREN          shift and go to state 198


state 193

    (95) default -> DEFAULT COLON body BREAK SEMICOLON .

    RBRACE          reduce using rule 95 (default -> DEFAULT COLON body BREAK SEMICOLON .)


state 194

    (81) case -> CASE valor COLON body BREAK . SEMICOLON

    SEMICOLON       shift and go to state 199


state 195

    (70) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON . VARIABLE DOUBLEPLUS
    (71) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON . VARIABLE DOUBLEMINUS

    VARIABLE        shift and go to state 200


state 196

    (98) catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 201


state 197

    (45) else_blocks -> ELSE LBRACE body RBRACE .

    VARIABLE        reduce using rule 45 (else_blocks -> ELSE LBRACE body RBRACE .)
    ECHO            reduce using rule 45 (else_blocks -> ELSE LBRACE body RBRACE .)
    PRINT           reduce using rule 45 (else_blocks -> ELSE LBRACE body RBRACE .)
    TRY             reduce using rule 45 (else_blocks -> ELSE LBRACE body RBRACE .)
    INT             reduce using rule 45 (else_blocks -> ELSE LBRACE body RBRACE .)
    FLOAT           reduce using rule 45 (else_blocks -> ELSE LBRACE body RBRACE .)
    STRING          reduce using rule 45 (else_blocks -> ELSE LBRACE body RBRACE .)
    IF              reduce using rule 45 (else_blocks -> ELSE LBRACE body RBRACE .)
    WHILE           reduce using rule 45 (else_blocks -> ELSE LBRACE body RBRACE .)
    SWITCH          reduce using rule 45 (else_blocks -> ELSE LBRACE body RBRACE .)
    FOR             reduce using rule 45 (else_blocks -> ELSE LBRACE body RBRACE .)
    CLOSETAG        reduce using rule 45 (else_blocks -> ELSE LBRACE body RBRACE .)
    RBRACE          reduce using rule 45 (else_blocks -> ELSE LBRACE body RBRACE .)
    BREAK           reduce using rule 45 (else_blocks -> ELSE LBRACE body RBRACE .)


state 198

    (46) else_blocks -> ELSEIF LPAREN conditions RPAREN . LBRACE body RBRACE else_blocks

    LBRACE          shift and go to state 202


state 199

    (81) case -> CASE valor COLON body BREAK SEMICOLON .

    CASE            reduce using rule 81 (case -> CASE valor COLON body BREAK SEMICOLON .)
    DEFAULT         reduce using rule 81 (case -> CASE valor COLON body BREAK SEMICOLON .)
    RBRACE          reduce using rule 81 (case -> CASE valor COLON body BREAK SEMICOLON .)


state 200

    (70) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE . DOUBLEPLUS
    (71) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE . DOUBLEMINUS

    DOUBLEPLUS      shift and go to state 203
    DOUBLEMINUS     shift and go to state 204


state 201

    (98) catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .

    CATCH           reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    FINALLY         reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    VARIABLE        reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    ECHO            reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    TRY             reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    FLOAT           reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    STRING          reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    SWITCH          reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    CLOSETAG        reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)
    BREAK           reduce using rule 98 (catch -> CATCH LPAREN EXCEPTION VARIABLE RPAREN LBRACE body RBRACE .)


state 202

    (46) else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE . body RBRACE else_blocks
    (64) body -> . sentenciaList
    (65) body -> . empty
    (66) sentenciaList -> . sentencia
    (67) sentenciaList -> . sentencia sentenciaList
    (36) empty -> .
    (4) sentencia -> . asignacion
    (5) sentencia -> . asignacion_fgets
    (6) sentencia -> . comparacion
    (7) sentencia -> . impresion
    (8) sentencia -> . estructurasPrograma
    (9) sentencia -> . try
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) asignacion_fgets -> . VARIABLE EQUALS FGETS LPAREN STDIN RPAREN SEMICOLON
    (23) comparacion -> . valor comparador valor
    (28) impresion -> . ECHO imprimir SEMICOLON
    (29) impresion -> . PRINT imprimir SEMICOLON
    (37) estructurasPrograma -> . controlStructure
    (38) estructurasPrograma -> . dataStructure
    (96) try -> . TRY LBRACE body RBRACE catchs
    (97) try -> . TRY LBRACE body RBRACE catchs FINALLY LBRACE body RBRACE
    (14) valor -> . INT
    (15) valor -> . FLOAT
    (16) valor -> . VARIABLE
    (17) valor -> . STRING
    (39) controlStructure -> . if
    (40) controlStructure -> . for
    (41) controlStructure -> . while
    (42) controlStructure -> . switch
    (82) dataStructure -> . array
    (43) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE
    (44) if -> . IF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks
    (68) for -> . forStatement
    (72) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (73) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (74) switch -> . SWITCH LPAREN valor RPAREN LBRACE caseLists RBRACE
    (83) array -> . VARIABLE EQUALS arrays SEMICOLON
    (84) array -> . VARIABLE EQUALS LBRACKET arrayAnidado RBRACKET SEMICOLON
    (85) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (86) array -> . map
    (69) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE
    (90) map -> . VARIABLE EQUALS LBRACKET maps RBRACKET SEMICOLON
    (91) map -> . VARIABLE EQUALS ARRAY LPAREN maps RPAREN SEMICOLON

    RBRACE          reduce using rule 36 (empty -> .)
    VARIABLE        shift and go to state 11
    ECHO            shift and go to state 13
    PRINT           shift and go to state 14
    TRY             shift and go to state 17
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    IF              shift and go to state 26
    WHILE           shift and go to state 28
    SWITCH          shift and go to state 29
    FOR             shift and go to state 31

    body                           shift and go to state 205
    sentenciaList                  shift and go to state 65
    empty                          shift and go to state 66
    sentencia                      shift and go to state 67
    asignacion                     shift and go to state 5
    asignacion_fgets               shift and go to state 6
    comparacion                    shift and go to state 7
    impresion                      shift and go to state 8
    estructurasPrograma            shift and go to state 9
    try                            shift and go to state 10
    valor                          shift and go to state 12
    controlStructure               shift and go to state 15
    dataStructure                  shift and go to state 16
    if                             shift and go to state 21
    for                            shift and go to state 22
    while                          shift and go to state 23
    switch                         shift and go to state 24
    array                          shift and go to state 25
    forStatement                   shift and go to state 27
    map                            shift and go to state 30

state 203

    (70) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS .

    RPAREN          reduce using rule 70 (forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS .)


state 204

    (71) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS .

    RPAREN          reduce using rule 71 (forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS .)


state 205

    (46) else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body . RBRACE else_blocks

    RBRACE          shift and go to state 206


state 206

    (46) else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE . else_blocks
    (45) else_blocks -> . ELSE LBRACE body RBRACE
    (46) else_blocks -> . ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks

    ELSE            shift and go to state 178
    ELSEIF          shift and go to state 179

    else_blocks                    shift and go to state 207

state 207

    (46) else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .

    VARIABLE        reduce using rule 46 (else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    ECHO            reduce using rule 46 (else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    PRINT           reduce using rule 46 (else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    TRY             reduce using rule 46 (else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    INT             reduce using rule 46 (else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    FLOAT           reduce using rule 46 (else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    STRING          reduce using rule 46 (else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    IF              reduce using rule 46 (else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    WHILE           reduce using rule 46 (else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    SWITCH          reduce using rule 46 (else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    FOR             reduce using rule 46 (else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    CLOSETAG        reduce using rule 46 (else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    RBRACE          reduce using rule 46 (else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)
    BREAK           reduce using rule 46 (else_blocks -> ELSEIF LPAREN conditions RPAREN LBRACE body RBRACE else_blocks .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RBRACE in state 133 resolved as shift
