Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    BOOL
    CATCH
    CLONE
    CLOSETAG
    CONCATENATEEQUAL
    CONST
    CONTINUE
    DECLARE
    DO
    EMPTY
    ENDSWITCH
    EXCEPTION
    FGETS
    FINAL
    FINALLY
    FOREACH
    GLOBAL
    IMPLEMENTS
    INCLUDE
    INSTANCEOF
    INTERFACE
    ISSET
    LIST
    MINUSEQUAL
    NAMESPACE
    NEW
    OPENTAG
    PLUSEQUAL
    POTENCIA
    PRIVATE
    PROTECTED
    PUBLIC
    STATIC
    STDIN
    THROW
    TRY

Grammar

Rule 0     S' -> programa
Rule 1     programa -> sentencia
Rule 2     programa -> sentencia programa
Rule 3     sentencia -> asignacion
Rule 4     sentencia -> impresion
Rule 5     sentencia -> comparacion
Rule 6     sentencia -> estructurasProgram
Rule 7     sentencias -> sentencia
Rule 8     sentencias -> sentencia sentencias
Rule 9     sentencias -> empty
Rule 10    asignacion -> VARIABLE EQUALS operaArit SEMICOLON
Rule 11    impresion -> ECHO imprimir SEMICOLON
Rule 12    impresion -> PRINT imprimir SEMICOLON
Rule 13    estructurasProgram -> controlStructure
Rule 14    estructurasProgram -> dataStructure
Rule 15    estructurasProgram -> funcionDeclarate
Rule 16    estructurasProgram -> classDeclarate
Rule 17    controlStructure -> if
Rule 18    controlStructure -> for
Rule 19    controlStructure -> while
Rule 20    controlStructure -> switch
Rule 21    if -> statementif ELSE body
Rule 22    if -> statementif ELSE if
Rule 23    if -> statementif ELSEIF if
Rule 24    if -> statementif
Rule 25    statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
Rule 26    conditionProdu -> condition
Rule 27    conditionProdu -> condition opLogic conditionProdu
Rule 28    condition -> valor opSymbol valor
Rule 29    condition -> LPAREN conditionProdu RPAREN
Rule 30    opSymbol -> EQ
Rule 31    opSymbol -> NEQ
Rule 32    opSymbol -> STRICTEQ
Rule 33    opSymbol -> STRICTNEQ
Rule 34    opSymbol -> LT
Rule 35    opSymbol -> GT
Rule 36    opSymbol -> LEQ
Rule 37    opSymbol -> GEQ
Rule 38    opLogic -> AND
Rule 39    opLogic -> OR
Rule 40    opLogic -> NOT
Rule 41    for -> forStatement
Rule 42    forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE
Rule 43    forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
Rule 44    forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS
Rule 45    while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE
Rule 46    while -> WHILE LPAREN condition RPAREN LBRACE RBRACE
Rule 47    switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
Rule 48    switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE
Rule 49    caseLists -> cases default
Rule 50    caseLists -> cases
Rule 51    caseLists -> default
Rule 52    caseLists -> empty
Rule 53    cases -> case cases
Rule 54    cases -> case
Rule 55    case -> CASE valor COLON body BREAK SEMICOLON
Rule 56    default -> DEFAULT COLON body BREAK SEMICOLON
Rule 57    dataStructure -> array
Rule 58    dataStructure -> map
Rule 59    funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
Rule 60    funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
Rule 61    funcionBody -> body
Rule 62    funcionBody -> RETURN expresion SEMICOLON
Rule 63    parametros -> parametro
Rule 64    parametros -> parametro COMMA parametros
Rule 65    parametros -> empty
Rule 66    parametro -> ID
Rule 67    parametro -> dataType ID
Rule 68    parametro -> ID EQUALS valor
Rule 69    parametro -> dataType ID EQUALS valor
Rule 70    arrowfunction -> FN LPAREN parametros RPAREN ARROWMAP expresion SEMICOLON
Rule 71    brace -> LBRACE body RBRACE
Rule 72    funcionParen -> ID LPAREN parametros RPAREN
Rule 73    classDeclarate -> CLASS ID LBRACE classBody RBRACE
Rule 74    classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE
Rule 75    classBody -> classMember classBody
Rule 76    classBody -> empty
Rule 77    classMember -> dataType VARIABLE SEMICOLON
Rule 78    classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace
Rule 79    accessMember -> VARIABLE ARROW ID
Rule 80    accessMember -> VARIABLE ARROW funcionParen
Rule 81    array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
Rule 82    array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
Rule 83    map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
Rule 84    map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
Rule 85    mapProduc -> mapArrow
Rule 86    mapProduc -> mapArrow COMMA mapProduc
Rule 87    mapArrow -> valor ARROWMAP valor
Rule 88    body -> sentencia
Rule 89    body -> sentencia sentencias
Rule 90    body -> empty
Rule 91    imprimir -> LPAREN repiteValores RPAREN
Rule 92    imprimir -> LPAREN RPAREN
Rule 93    imprimir -> repiteValores
Rule 94    valor -> INT
Rule 95    valor -> FLOAT
Rule 96    valor -> VARIABLE
Rule 97    valor -> STRING
Rule 98    valor -> TRUE
Rule 99    valor -> FALSE
Rule 100   valor -> THIS
Rule 101   valor -> funcionParen
Rule 102   dataType -> INTEGER
Rule 103   dataType -> FLOATING
Rule 104   dataType -> STRINGS
Rule 105   dataType -> BOOLEAN
Rule 106   dataType -> VOID
Rule 107   comparacion -> INT operador INT
Rule 108   comparacion -> FLOAT operador FLOAT
Rule 109   comparacion -> INT operador FLOAT
Rule 110   comparacion -> FLOAT operador INT
Rule 111   repiteValores -> valor COMMA repiteValores
Rule 112   repiteValores -> valor
Rule 113   operaArit -> valor
Rule 114   operaArit -> valor operador operaArit
Rule 115   operaArit -> valor DOT valor
Rule 116   expresion -> valor
Rule 117   expresion -> operaArit
Rule 118   expresion -> conditionProdu
Rule 119   expresion -> ternario
Rule 120   expresion -> accessMember
Rule 121   operador -> PLUS
Rule 122   operador -> MINUS
Rule 123   operador -> TIMES
Rule 124   operador -> DIVIDE
Rule 125   operador -> MODULO
Rule 126   ternario -> conditionProdu QUESTION expresion COLON expresion
Rule 127   empty -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 38
ARRAY                : 82 84
ARROW                : 79 80
ARROWMAP             : 70 87
AS                   : 
BOOL                 : 
BOOLEAN              : 105
BREAK                : 55 56
CASE                 : 55
CATCH                : 
CLASS                : 73 74
CLONE                : 
CLOSETAG             : 
COLON                : 55 56 126
COMMA                : 64 86 111
CONCATENATEEQUAL     : 
CONST                : 
CONTINUE             : 
DECLARE              : 
DEFAULT              : 56
DIVIDE               : 124
DO                   : 
DOT                  : 115
DOUBLEDOT            : 60
DOUBLEMINUS          : 44
DOUBLEPLUS           : 43
ECHO                 : 11
ELSE                 : 21 22
ELSEIF               : 23
EMPTY                : 
ENDSWITCH            : 
EQ                   : 30
EQUALS               : 10 43 44 68 69 81 82 83 84
EXCEPTION            : 
EXTENDS              : 74
FALSE                : 99
FGETS                : 
FINAL                : 
FINALLY              : 
FLOAT                : 95 108 108 109 110
FLOATING             : 103
FN                   : 70
FOR                  : 42
FOREACH              : 
FUNCTION             : 59 60 78
GEQ                  : 37
GLOBAL               : 
GT                   : 35
ID                   : 59 60 66 67 68 69 72 73 74 74 78 79
IF                   : 25
IMPLEMENTS           : 
INCLUDE              : 
INSTANCEOF           : 
INT                  : 43 43 44 44 94 107 107 109 110
INTEGER              : 102
INTERFACE            : 
ISSET                : 
LBRACE               : 25 42 45 46 47 48 59 60 71 73 74
LBRACKET             : 81 83
LEQ                  : 36
LIST                 : 
LPAREN               : 25 29 42 45 46 47 48 59 60 70 72 78 82 84 91 92
LT                   : 34
MINUS                : 122
MINUSEQUAL           : 
MODULO               : 125
NAMESPACE            : 
NEQ                  : 31
NEW                  : 
NOT                  : 40
OPENTAG              : 
OR                   : 39
PLUS                 : 121
PLUSEQUAL            : 
POTENCIA             : 
PRINT                : 12
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
QUESTION             : 126
RBRACE               : 25 42 45 46 47 48 59 60 71 73 74
RBRACKET             : 81 83
RETURN               : 62
RPAREN               : 25 29 42 45 46 47 48 59 60 70 72 78 82 84 91 92
SEMICOLON            : 10 11 12 43 43 44 44 55 56 62 70 77 81 82 83 84
STATIC               : 
STDIN                : 
STRICTEQ             : 32
STRICTNEQ            : 33
STRING               : 97
STRINGS              : 104
SWITCH               : 47 48
THIS                 : 100
THROW                : 
TIMES                : 123
TRUE                 : 98
TRY                  : 
VARIABLE             : 10 43 43 43 44 44 44 77 79 80 81 82 83 84 96
VOID                 : 106
WHILE                : 45 46
error                : 

Nonterminals, with rules where they appear

accessMember         : 120
array                : 57
arrowfunction        : 
asignacion           : 3
body                 : 21 25 42 45 55 56 61 71
brace                : 78
case                 : 53 54
caseLists            : 47
cases                : 49 50 53
classBody            : 73 74 75
classDeclarate       : 16
classMember          : 75
comparacion          : 5
condition            : 26 27 45 46 47 48
conditionProdu       : 25 27 29 118 126
controlStructure     : 13
dataStructure        : 14
dataType             : 60 67 69 77 78
default              : 49 51
empty                : 9 52 65 76 90
estructurasProgram   : 6
expresion            : 62 70 126 126
for                  : 18
forStatement         : 41
forcondition         : 42
funcionBody          : 59 60
funcionDeclarate     : 15
funcionParen         : 80 101
if                   : 17 22 23
impresion            : 4
imprimir             : 11 12
map                  : 58
mapArrow             : 85 86
mapProduc            : 83 84 86
opLogic              : 27
opSymbol             : 28 43 44
operaArit            : 10 114 117
operador             : 107 108 109 110 114
parametro            : 63 64
parametros           : 59 60 64 70 72 78
programa             : 2 0
repiteValores        : 81 82 91 93 111
sentencia            : 1 2 7 8 88 89
sentencias           : 8 89
statementif          : 21 22 23 24
switch               : 20
ternario             : 119
valor                : 28 28 55 68 69 87 87 111 112 113 114 115 115 116
while                : 19

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . sentencia
    (2) programa -> . sentencia programa
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (107) comparacion -> . INT operador INT
    (108) comparacion -> . FLOAT operador FLOAT
    (109) comparacion -> . INT operador FLOAT
    (110) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (73) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (74) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (81) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    programa                       shift and go to state 1
    sentencia                      shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 1

    (0) S' -> programa .



state 2

    (1) programa -> sentencia .
    (2) programa -> sentencia . programa
    (1) programa -> . sentencia
    (2) programa -> . sentencia programa
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (107) comparacion -> . INT operador INT
    (108) comparacion -> . FLOAT operador FLOAT
    (109) comparacion -> . INT operador FLOAT
    (110) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (73) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (74) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (81) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    $end            reduce using rule 1 (programa -> sentencia .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    sentencia                      shift and go to state 2
    programa                       shift and go to state 30
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 3

    (3) sentencia -> asignacion .

    VARIABLE        reduce using rule 3 (sentencia -> asignacion .)
    ECHO            reduce using rule 3 (sentencia -> asignacion .)
    PRINT           reduce using rule 3 (sentencia -> asignacion .)
    INT             reduce using rule 3 (sentencia -> asignacion .)
    FLOAT           reduce using rule 3 (sentencia -> asignacion .)
    FUNCTION        reduce using rule 3 (sentencia -> asignacion .)
    CLASS           reduce using rule 3 (sentencia -> asignacion .)
    WHILE           reduce using rule 3 (sentencia -> asignacion .)
    SWITCH          reduce using rule 3 (sentencia -> asignacion .)
    IF              reduce using rule 3 (sentencia -> asignacion .)
    FOR             reduce using rule 3 (sentencia -> asignacion .)
    $end            reduce using rule 3 (sentencia -> asignacion .)
    RBRACE          reduce using rule 3 (sentencia -> asignacion .)
    BREAK           reduce using rule 3 (sentencia -> asignacion .)


state 4

    (4) sentencia -> impresion .

    VARIABLE        reduce using rule 4 (sentencia -> impresion .)
    ECHO            reduce using rule 4 (sentencia -> impresion .)
    PRINT           reduce using rule 4 (sentencia -> impresion .)
    INT             reduce using rule 4 (sentencia -> impresion .)
    FLOAT           reduce using rule 4 (sentencia -> impresion .)
    FUNCTION        reduce using rule 4 (sentencia -> impresion .)
    CLASS           reduce using rule 4 (sentencia -> impresion .)
    WHILE           reduce using rule 4 (sentencia -> impresion .)
    SWITCH          reduce using rule 4 (sentencia -> impresion .)
    IF              reduce using rule 4 (sentencia -> impresion .)
    FOR             reduce using rule 4 (sentencia -> impresion .)
    $end            reduce using rule 4 (sentencia -> impresion .)
    RBRACE          reduce using rule 4 (sentencia -> impresion .)
    BREAK           reduce using rule 4 (sentencia -> impresion .)


state 5

    (5) sentencia -> comparacion .

    VARIABLE        reduce using rule 5 (sentencia -> comparacion .)
    ECHO            reduce using rule 5 (sentencia -> comparacion .)
    PRINT           reduce using rule 5 (sentencia -> comparacion .)
    INT             reduce using rule 5 (sentencia -> comparacion .)
    FLOAT           reduce using rule 5 (sentencia -> comparacion .)
    FUNCTION        reduce using rule 5 (sentencia -> comparacion .)
    CLASS           reduce using rule 5 (sentencia -> comparacion .)
    WHILE           reduce using rule 5 (sentencia -> comparacion .)
    SWITCH          reduce using rule 5 (sentencia -> comparacion .)
    IF              reduce using rule 5 (sentencia -> comparacion .)
    FOR             reduce using rule 5 (sentencia -> comparacion .)
    $end            reduce using rule 5 (sentencia -> comparacion .)
    RBRACE          reduce using rule 5 (sentencia -> comparacion .)
    BREAK           reduce using rule 5 (sentencia -> comparacion .)


state 6

    (6) sentencia -> estructurasProgram .

    VARIABLE        reduce using rule 6 (sentencia -> estructurasProgram .)
    ECHO            reduce using rule 6 (sentencia -> estructurasProgram .)
    PRINT           reduce using rule 6 (sentencia -> estructurasProgram .)
    INT             reduce using rule 6 (sentencia -> estructurasProgram .)
    FLOAT           reduce using rule 6 (sentencia -> estructurasProgram .)
    FUNCTION        reduce using rule 6 (sentencia -> estructurasProgram .)
    CLASS           reduce using rule 6 (sentencia -> estructurasProgram .)
    WHILE           reduce using rule 6 (sentencia -> estructurasProgram .)
    SWITCH          reduce using rule 6 (sentencia -> estructurasProgram .)
    IF              reduce using rule 6 (sentencia -> estructurasProgram .)
    FOR             reduce using rule 6 (sentencia -> estructurasProgram .)
    $end            reduce using rule 6 (sentencia -> estructurasProgram .)
    RBRACE          reduce using rule 6 (sentencia -> estructurasProgram .)
    BREAK           reduce using rule 6 (sentencia -> estructurasProgram .)


state 7

    (10) asignacion -> VARIABLE . EQUALS operaArit SEMICOLON
    (81) array -> VARIABLE . EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> VARIABLE . EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> VARIABLE . EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> VARIABLE . EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON

    EQUALS          shift and go to state 31


state 8

    (11) impresion -> ECHO . imprimir SEMICOLON
    (91) imprimir -> . LPAREN repiteValores RPAREN
    (92) imprimir -> . LPAREN RPAREN
    (93) imprimir -> . repiteValores
    (111) repiteValores -> . valor COMMA repiteValores
    (112) repiteValores -> . valor
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    LPAREN          shift and go to state 33
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    imprimir                       shift and go to state 32
    repiteValores                  shift and go to state 34
    valor                          shift and go to state 35
    funcionParen                   shift and go to state 43

state 9

    (12) impresion -> PRINT . imprimir SEMICOLON
    (91) imprimir -> . LPAREN repiteValores RPAREN
    (92) imprimir -> . LPAREN RPAREN
    (93) imprimir -> . repiteValores
    (111) repiteValores -> . valor COMMA repiteValores
    (112) repiteValores -> . valor
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    LPAREN          shift and go to state 33
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    imprimir                       shift and go to state 45
    repiteValores                  shift and go to state 34
    valor                          shift and go to state 35
    funcionParen                   shift and go to state 43

state 10

    (107) comparacion -> INT . operador INT
    (109) comparacion -> INT . operador FLOAT
    (121) operador -> . PLUS
    (122) operador -> . MINUS
    (123) operador -> . TIMES
    (124) operador -> . DIVIDE
    (125) operador -> . MODULO

    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50
    MODULO          shift and go to state 51

    operador                       shift and go to state 46

state 11

    (108) comparacion -> FLOAT . operador FLOAT
    (110) comparacion -> FLOAT . operador INT
    (121) operador -> . PLUS
    (122) operador -> . MINUS
    (123) operador -> . TIMES
    (124) operador -> . DIVIDE
    (125) operador -> . MODULO

    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50
    MODULO          shift and go to state 51

    operador                       shift and go to state 52

state 12

    (13) estructurasProgram -> controlStructure .

    VARIABLE        reduce using rule 13 (estructurasProgram -> controlStructure .)
    ECHO            reduce using rule 13 (estructurasProgram -> controlStructure .)
    PRINT           reduce using rule 13 (estructurasProgram -> controlStructure .)
    INT             reduce using rule 13 (estructurasProgram -> controlStructure .)
    FLOAT           reduce using rule 13 (estructurasProgram -> controlStructure .)
    FUNCTION        reduce using rule 13 (estructurasProgram -> controlStructure .)
    CLASS           reduce using rule 13 (estructurasProgram -> controlStructure .)
    WHILE           reduce using rule 13 (estructurasProgram -> controlStructure .)
    SWITCH          reduce using rule 13 (estructurasProgram -> controlStructure .)
    IF              reduce using rule 13 (estructurasProgram -> controlStructure .)
    FOR             reduce using rule 13 (estructurasProgram -> controlStructure .)
    $end            reduce using rule 13 (estructurasProgram -> controlStructure .)
    RBRACE          reduce using rule 13 (estructurasProgram -> controlStructure .)
    BREAK           reduce using rule 13 (estructurasProgram -> controlStructure .)


state 13

    (14) estructurasProgram -> dataStructure .

    VARIABLE        reduce using rule 14 (estructurasProgram -> dataStructure .)
    ECHO            reduce using rule 14 (estructurasProgram -> dataStructure .)
    PRINT           reduce using rule 14 (estructurasProgram -> dataStructure .)
    INT             reduce using rule 14 (estructurasProgram -> dataStructure .)
    FLOAT           reduce using rule 14 (estructurasProgram -> dataStructure .)
    FUNCTION        reduce using rule 14 (estructurasProgram -> dataStructure .)
    CLASS           reduce using rule 14 (estructurasProgram -> dataStructure .)
    WHILE           reduce using rule 14 (estructurasProgram -> dataStructure .)
    SWITCH          reduce using rule 14 (estructurasProgram -> dataStructure .)
    IF              reduce using rule 14 (estructurasProgram -> dataStructure .)
    FOR             reduce using rule 14 (estructurasProgram -> dataStructure .)
    $end            reduce using rule 14 (estructurasProgram -> dataStructure .)
    RBRACE          reduce using rule 14 (estructurasProgram -> dataStructure .)
    BREAK           reduce using rule 14 (estructurasProgram -> dataStructure .)


state 14

    (15) estructurasProgram -> funcionDeclarate .

    VARIABLE        reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    ECHO            reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    PRINT           reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    INT             reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    FLOAT           reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    FUNCTION        reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    CLASS           reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    WHILE           reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    SWITCH          reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    IF              reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    FOR             reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    $end            reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    RBRACE          reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    BREAK           reduce using rule 15 (estructurasProgram -> funcionDeclarate .)


state 15

    (16) estructurasProgram -> classDeclarate .

    VARIABLE        reduce using rule 16 (estructurasProgram -> classDeclarate .)
    ECHO            reduce using rule 16 (estructurasProgram -> classDeclarate .)
    PRINT           reduce using rule 16 (estructurasProgram -> classDeclarate .)
    INT             reduce using rule 16 (estructurasProgram -> classDeclarate .)
    FLOAT           reduce using rule 16 (estructurasProgram -> classDeclarate .)
    FUNCTION        reduce using rule 16 (estructurasProgram -> classDeclarate .)
    CLASS           reduce using rule 16 (estructurasProgram -> classDeclarate .)
    WHILE           reduce using rule 16 (estructurasProgram -> classDeclarate .)
    SWITCH          reduce using rule 16 (estructurasProgram -> classDeclarate .)
    IF              reduce using rule 16 (estructurasProgram -> classDeclarate .)
    FOR             reduce using rule 16 (estructurasProgram -> classDeclarate .)
    $end            reduce using rule 16 (estructurasProgram -> classDeclarate .)
    RBRACE          reduce using rule 16 (estructurasProgram -> classDeclarate .)
    BREAK           reduce using rule 16 (estructurasProgram -> classDeclarate .)


state 16

    (17) controlStructure -> if .

    VARIABLE        reduce using rule 17 (controlStructure -> if .)
    ECHO            reduce using rule 17 (controlStructure -> if .)
    PRINT           reduce using rule 17 (controlStructure -> if .)
    INT             reduce using rule 17 (controlStructure -> if .)
    FLOAT           reduce using rule 17 (controlStructure -> if .)
    FUNCTION        reduce using rule 17 (controlStructure -> if .)
    CLASS           reduce using rule 17 (controlStructure -> if .)
    WHILE           reduce using rule 17 (controlStructure -> if .)
    SWITCH          reduce using rule 17 (controlStructure -> if .)
    IF              reduce using rule 17 (controlStructure -> if .)
    FOR             reduce using rule 17 (controlStructure -> if .)
    $end            reduce using rule 17 (controlStructure -> if .)
    RBRACE          reduce using rule 17 (controlStructure -> if .)
    BREAK           reduce using rule 17 (controlStructure -> if .)


state 17

    (18) controlStructure -> for .

    VARIABLE        reduce using rule 18 (controlStructure -> for .)
    ECHO            reduce using rule 18 (controlStructure -> for .)
    PRINT           reduce using rule 18 (controlStructure -> for .)
    INT             reduce using rule 18 (controlStructure -> for .)
    FLOAT           reduce using rule 18 (controlStructure -> for .)
    FUNCTION        reduce using rule 18 (controlStructure -> for .)
    CLASS           reduce using rule 18 (controlStructure -> for .)
    WHILE           reduce using rule 18 (controlStructure -> for .)
    SWITCH          reduce using rule 18 (controlStructure -> for .)
    IF              reduce using rule 18 (controlStructure -> for .)
    FOR             reduce using rule 18 (controlStructure -> for .)
    $end            reduce using rule 18 (controlStructure -> for .)
    RBRACE          reduce using rule 18 (controlStructure -> for .)
    BREAK           reduce using rule 18 (controlStructure -> for .)


state 18

    (19) controlStructure -> while .

    VARIABLE        reduce using rule 19 (controlStructure -> while .)
    ECHO            reduce using rule 19 (controlStructure -> while .)
    PRINT           reduce using rule 19 (controlStructure -> while .)
    INT             reduce using rule 19 (controlStructure -> while .)
    FLOAT           reduce using rule 19 (controlStructure -> while .)
    FUNCTION        reduce using rule 19 (controlStructure -> while .)
    CLASS           reduce using rule 19 (controlStructure -> while .)
    WHILE           reduce using rule 19 (controlStructure -> while .)
    SWITCH          reduce using rule 19 (controlStructure -> while .)
    IF              reduce using rule 19 (controlStructure -> while .)
    FOR             reduce using rule 19 (controlStructure -> while .)
    $end            reduce using rule 19 (controlStructure -> while .)
    RBRACE          reduce using rule 19 (controlStructure -> while .)
    BREAK           reduce using rule 19 (controlStructure -> while .)


state 19

    (20) controlStructure -> switch .

    VARIABLE        reduce using rule 20 (controlStructure -> switch .)
    ECHO            reduce using rule 20 (controlStructure -> switch .)
    PRINT           reduce using rule 20 (controlStructure -> switch .)
    INT             reduce using rule 20 (controlStructure -> switch .)
    FLOAT           reduce using rule 20 (controlStructure -> switch .)
    FUNCTION        reduce using rule 20 (controlStructure -> switch .)
    CLASS           reduce using rule 20 (controlStructure -> switch .)
    WHILE           reduce using rule 20 (controlStructure -> switch .)
    SWITCH          reduce using rule 20 (controlStructure -> switch .)
    IF              reduce using rule 20 (controlStructure -> switch .)
    FOR             reduce using rule 20 (controlStructure -> switch .)
    $end            reduce using rule 20 (controlStructure -> switch .)
    RBRACE          reduce using rule 20 (controlStructure -> switch .)
    BREAK           reduce using rule 20 (controlStructure -> switch .)


state 20

    (57) dataStructure -> array .

    VARIABLE        reduce using rule 57 (dataStructure -> array .)
    ECHO            reduce using rule 57 (dataStructure -> array .)
    PRINT           reduce using rule 57 (dataStructure -> array .)
    INT             reduce using rule 57 (dataStructure -> array .)
    FLOAT           reduce using rule 57 (dataStructure -> array .)
    FUNCTION        reduce using rule 57 (dataStructure -> array .)
    CLASS           reduce using rule 57 (dataStructure -> array .)
    WHILE           reduce using rule 57 (dataStructure -> array .)
    SWITCH          reduce using rule 57 (dataStructure -> array .)
    IF              reduce using rule 57 (dataStructure -> array .)
    FOR             reduce using rule 57 (dataStructure -> array .)
    $end            reduce using rule 57 (dataStructure -> array .)
    RBRACE          reduce using rule 57 (dataStructure -> array .)
    BREAK           reduce using rule 57 (dataStructure -> array .)


state 21

    (58) dataStructure -> map .

    VARIABLE        reduce using rule 58 (dataStructure -> map .)
    ECHO            reduce using rule 58 (dataStructure -> map .)
    PRINT           reduce using rule 58 (dataStructure -> map .)
    INT             reduce using rule 58 (dataStructure -> map .)
    FLOAT           reduce using rule 58 (dataStructure -> map .)
    FUNCTION        reduce using rule 58 (dataStructure -> map .)
    CLASS           reduce using rule 58 (dataStructure -> map .)
    WHILE           reduce using rule 58 (dataStructure -> map .)
    SWITCH          reduce using rule 58 (dataStructure -> map .)
    IF              reduce using rule 58 (dataStructure -> map .)
    FOR             reduce using rule 58 (dataStructure -> map .)
    $end            reduce using rule 58 (dataStructure -> map .)
    RBRACE          reduce using rule 58 (dataStructure -> map .)
    BREAK           reduce using rule 58 (dataStructure -> map .)


state 22

    (59) funcionDeclarate -> FUNCTION . ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> FUNCTION . ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE

    ID              shift and go to state 53


state 23

    (73) classDeclarate -> CLASS . ID LBRACE classBody RBRACE
    (74) classDeclarate -> CLASS . ID EXTENDS ID LBRACE classBody RBRACE

    ID              shift and go to state 54


state 24

    (21) if -> statementif . ELSE body
    (22) if -> statementif . ELSE if
    (23) if -> statementif . ELSEIF if
    (24) if -> statementif .

    ELSE            shift and go to state 55
    ELSEIF          shift and go to state 56
    VARIABLE        reduce using rule 24 (if -> statementif .)
    ECHO            reduce using rule 24 (if -> statementif .)
    PRINT           reduce using rule 24 (if -> statementif .)
    INT             reduce using rule 24 (if -> statementif .)
    FLOAT           reduce using rule 24 (if -> statementif .)
    FUNCTION        reduce using rule 24 (if -> statementif .)
    CLASS           reduce using rule 24 (if -> statementif .)
    WHILE           reduce using rule 24 (if -> statementif .)
    SWITCH          reduce using rule 24 (if -> statementif .)
    IF              reduce using rule 24 (if -> statementif .)
    FOR             reduce using rule 24 (if -> statementif .)
    $end            reduce using rule 24 (if -> statementif .)
    RBRACE          reduce using rule 24 (if -> statementif .)
    BREAK           reduce using rule 24 (if -> statementif .)


state 25

    (41) for -> forStatement .

    VARIABLE        reduce using rule 41 (for -> forStatement .)
    ECHO            reduce using rule 41 (for -> forStatement .)
    PRINT           reduce using rule 41 (for -> forStatement .)
    INT             reduce using rule 41 (for -> forStatement .)
    FLOAT           reduce using rule 41 (for -> forStatement .)
    FUNCTION        reduce using rule 41 (for -> forStatement .)
    CLASS           reduce using rule 41 (for -> forStatement .)
    WHILE           reduce using rule 41 (for -> forStatement .)
    SWITCH          reduce using rule 41 (for -> forStatement .)
    IF              reduce using rule 41 (for -> forStatement .)
    FOR             reduce using rule 41 (for -> forStatement .)
    $end            reduce using rule 41 (for -> forStatement .)
    RBRACE          reduce using rule 41 (for -> forStatement .)
    BREAK           reduce using rule 41 (for -> forStatement .)


state 26

    (45) while -> WHILE . LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> WHILE . LPAREN condition RPAREN LBRACE RBRACE

    LPAREN          shift and go to state 57


state 27

    (47) switch -> SWITCH . LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> SWITCH . LPAREN condition RPAREN LBRACE RBRACE

    LPAREN          shift and go to state 58


state 28

    (25) statementif -> IF . LPAREN conditionProdu RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 59


state 29

    (42) forStatement -> FOR . LPAREN forcondition RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 60


state 30

    (2) programa -> sentencia programa .

    $end            reduce using rule 2 (programa -> sentencia programa .)


state 31

    (10) asignacion -> VARIABLE EQUALS . operaArit SEMICOLON
    (81) array -> VARIABLE EQUALS . LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> VARIABLE EQUALS . ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> VARIABLE EQUALS . LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> VARIABLE EQUALS . ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (113) operaArit -> . valor
    (114) operaArit -> . valor operador operaArit
    (115) operaArit -> . valor DOT valor
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    LBRACKET        shift and go to state 62
    ARRAY           shift and go to state 63
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    operaArit                      shift and go to state 61
    valor                          shift and go to state 64
    funcionParen                   shift and go to state 43

state 32

    (11) impresion -> ECHO imprimir . SEMICOLON

    SEMICOLON       shift and go to state 65


state 33

    (91) imprimir -> LPAREN . repiteValores RPAREN
    (92) imprimir -> LPAREN . RPAREN
    (111) repiteValores -> . valor COMMA repiteValores
    (112) repiteValores -> . valor
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    RPAREN          shift and go to state 67
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    repiteValores                  shift and go to state 66
    valor                          shift and go to state 35
    funcionParen                   shift and go to state 43

state 34

    (93) imprimir -> repiteValores .

    SEMICOLON       reduce using rule 93 (imprimir -> repiteValores .)


state 35

    (111) repiteValores -> valor . COMMA repiteValores
    (112) repiteValores -> valor .

    COMMA           shift and go to state 68
    SEMICOLON       reduce using rule 112 (repiteValores -> valor .)
    RPAREN          reduce using rule 112 (repiteValores -> valor .)
    RBRACKET        reduce using rule 112 (repiteValores -> valor .)


state 36

    (94) valor -> INT .

    COMMA           reduce using rule 94 (valor -> INT .)
    SEMICOLON       reduce using rule 94 (valor -> INT .)
    DOT             reduce using rule 94 (valor -> INT .)
    PLUS            reduce using rule 94 (valor -> INT .)
    MINUS           reduce using rule 94 (valor -> INT .)
    TIMES           reduce using rule 94 (valor -> INT .)
    DIVIDE          reduce using rule 94 (valor -> INT .)
    MODULO          reduce using rule 94 (valor -> INT .)
    RPAREN          reduce using rule 94 (valor -> INT .)
    EQ              reduce using rule 94 (valor -> INT .)
    NEQ             reduce using rule 94 (valor -> INT .)
    STRICTEQ        reduce using rule 94 (valor -> INT .)
    STRICTNEQ       reduce using rule 94 (valor -> INT .)
    LT              reduce using rule 94 (valor -> INT .)
    GT              reduce using rule 94 (valor -> INT .)
    LEQ             reduce using rule 94 (valor -> INT .)
    GEQ             reduce using rule 94 (valor -> INT .)
    ARROWMAP        reduce using rule 94 (valor -> INT .)
    RBRACKET        reduce using rule 94 (valor -> INT .)
    COLON           reduce using rule 94 (valor -> INT .)
    AND             reduce using rule 94 (valor -> INT .)
    OR              reduce using rule 94 (valor -> INT .)
    NOT             reduce using rule 94 (valor -> INT .)
    QUESTION        reduce using rule 94 (valor -> INT .)


state 37

    (95) valor -> FLOAT .

    COMMA           reduce using rule 95 (valor -> FLOAT .)
    SEMICOLON       reduce using rule 95 (valor -> FLOAT .)
    DOT             reduce using rule 95 (valor -> FLOAT .)
    PLUS            reduce using rule 95 (valor -> FLOAT .)
    MINUS           reduce using rule 95 (valor -> FLOAT .)
    TIMES           reduce using rule 95 (valor -> FLOAT .)
    DIVIDE          reduce using rule 95 (valor -> FLOAT .)
    MODULO          reduce using rule 95 (valor -> FLOAT .)
    RPAREN          reduce using rule 95 (valor -> FLOAT .)
    EQ              reduce using rule 95 (valor -> FLOAT .)
    NEQ             reduce using rule 95 (valor -> FLOAT .)
    STRICTEQ        reduce using rule 95 (valor -> FLOAT .)
    STRICTNEQ       reduce using rule 95 (valor -> FLOAT .)
    LT              reduce using rule 95 (valor -> FLOAT .)
    GT              reduce using rule 95 (valor -> FLOAT .)
    LEQ             reduce using rule 95 (valor -> FLOAT .)
    GEQ             reduce using rule 95 (valor -> FLOAT .)
    ARROWMAP        reduce using rule 95 (valor -> FLOAT .)
    RBRACKET        reduce using rule 95 (valor -> FLOAT .)
    COLON           reduce using rule 95 (valor -> FLOAT .)
    AND             reduce using rule 95 (valor -> FLOAT .)
    OR              reduce using rule 95 (valor -> FLOAT .)
    NOT             reduce using rule 95 (valor -> FLOAT .)
    QUESTION        reduce using rule 95 (valor -> FLOAT .)


state 38

    (96) valor -> VARIABLE .

    COMMA           reduce using rule 96 (valor -> VARIABLE .)
    SEMICOLON       reduce using rule 96 (valor -> VARIABLE .)
    DOT             reduce using rule 96 (valor -> VARIABLE .)
    PLUS            reduce using rule 96 (valor -> VARIABLE .)
    MINUS           reduce using rule 96 (valor -> VARIABLE .)
    TIMES           reduce using rule 96 (valor -> VARIABLE .)
    DIVIDE          reduce using rule 96 (valor -> VARIABLE .)
    MODULO          reduce using rule 96 (valor -> VARIABLE .)
    RPAREN          reduce using rule 96 (valor -> VARIABLE .)
    EQ              reduce using rule 96 (valor -> VARIABLE .)
    NEQ             reduce using rule 96 (valor -> VARIABLE .)
    STRICTEQ        reduce using rule 96 (valor -> VARIABLE .)
    STRICTNEQ       reduce using rule 96 (valor -> VARIABLE .)
    LT              reduce using rule 96 (valor -> VARIABLE .)
    GT              reduce using rule 96 (valor -> VARIABLE .)
    LEQ             reduce using rule 96 (valor -> VARIABLE .)
    GEQ             reduce using rule 96 (valor -> VARIABLE .)
    ARROWMAP        reduce using rule 96 (valor -> VARIABLE .)
    RBRACKET        reduce using rule 96 (valor -> VARIABLE .)
    COLON           reduce using rule 96 (valor -> VARIABLE .)
    AND             reduce using rule 96 (valor -> VARIABLE .)
    OR              reduce using rule 96 (valor -> VARIABLE .)
    NOT             reduce using rule 96 (valor -> VARIABLE .)
    QUESTION        reduce using rule 96 (valor -> VARIABLE .)


state 39

    (97) valor -> STRING .

    COMMA           reduce using rule 97 (valor -> STRING .)
    SEMICOLON       reduce using rule 97 (valor -> STRING .)
    DOT             reduce using rule 97 (valor -> STRING .)
    PLUS            reduce using rule 97 (valor -> STRING .)
    MINUS           reduce using rule 97 (valor -> STRING .)
    TIMES           reduce using rule 97 (valor -> STRING .)
    DIVIDE          reduce using rule 97 (valor -> STRING .)
    MODULO          reduce using rule 97 (valor -> STRING .)
    RPAREN          reduce using rule 97 (valor -> STRING .)
    EQ              reduce using rule 97 (valor -> STRING .)
    NEQ             reduce using rule 97 (valor -> STRING .)
    STRICTEQ        reduce using rule 97 (valor -> STRING .)
    STRICTNEQ       reduce using rule 97 (valor -> STRING .)
    LT              reduce using rule 97 (valor -> STRING .)
    GT              reduce using rule 97 (valor -> STRING .)
    LEQ             reduce using rule 97 (valor -> STRING .)
    GEQ             reduce using rule 97 (valor -> STRING .)
    ARROWMAP        reduce using rule 97 (valor -> STRING .)
    RBRACKET        reduce using rule 97 (valor -> STRING .)
    COLON           reduce using rule 97 (valor -> STRING .)
    AND             reduce using rule 97 (valor -> STRING .)
    OR              reduce using rule 97 (valor -> STRING .)
    NOT             reduce using rule 97 (valor -> STRING .)
    QUESTION        reduce using rule 97 (valor -> STRING .)


state 40

    (98) valor -> TRUE .

    COMMA           reduce using rule 98 (valor -> TRUE .)
    SEMICOLON       reduce using rule 98 (valor -> TRUE .)
    DOT             reduce using rule 98 (valor -> TRUE .)
    PLUS            reduce using rule 98 (valor -> TRUE .)
    MINUS           reduce using rule 98 (valor -> TRUE .)
    TIMES           reduce using rule 98 (valor -> TRUE .)
    DIVIDE          reduce using rule 98 (valor -> TRUE .)
    MODULO          reduce using rule 98 (valor -> TRUE .)
    RPAREN          reduce using rule 98 (valor -> TRUE .)
    EQ              reduce using rule 98 (valor -> TRUE .)
    NEQ             reduce using rule 98 (valor -> TRUE .)
    STRICTEQ        reduce using rule 98 (valor -> TRUE .)
    STRICTNEQ       reduce using rule 98 (valor -> TRUE .)
    LT              reduce using rule 98 (valor -> TRUE .)
    GT              reduce using rule 98 (valor -> TRUE .)
    LEQ             reduce using rule 98 (valor -> TRUE .)
    GEQ             reduce using rule 98 (valor -> TRUE .)
    ARROWMAP        reduce using rule 98 (valor -> TRUE .)
    RBRACKET        reduce using rule 98 (valor -> TRUE .)
    COLON           reduce using rule 98 (valor -> TRUE .)
    AND             reduce using rule 98 (valor -> TRUE .)
    OR              reduce using rule 98 (valor -> TRUE .)
    NOT             reduce using rule 98 (valor -> TRUE .)
    QUESTION        reduce using rule 98 (valor -> TRUE .)


state 41

    (99) valor -> FALSE .

    COMMA           reduce using rule 99 (valor -> FALSE .)
    SEMICOLON       reduce using rule 99 (valor -> FALSE .)
    DOT             reduce using rule 99 (valor -> FALSE .)
    PLUS            reduce using rule 99 (valor -> FALSE .)
    MINUS           reduce using rule 99 (valor -> FALSE .)
    TIMES           reduce using rule 99 (valor -> FALSE .)
    DIVIDE          reduce using rule 99 (valor -> FALSE .)
    MODULO          reduce using rule 99 (valor -> FALSE .)
    RPAREN          reduce using rule 99 (valor -> FALSE .)
    EQ              reduce using rule 99 (valor -> FALSE .)
    NEQ             reduce using rule 99 (valor -> FALSE .)
    STRICTEQ        reduce using rule 99 (valor -> FALSE .)
    STRICTNEQ       reduce using rule 99 (valor -> FALSE .)
    LT              reduce using rule 99 (valor -> FALSE .)
    GT              reduce using rule 99 (valor -> FALSE .)
    LEQ             reduce using rule 99 (valor -> FALSE .)
    GEQ             reduce using rule 99 (valor -> FALSE .)
    ARROWMAP        reduce using rule 99 (valor -> FALSE .)
    RBRACKET        reduce using rule 99 (valor -> FALSE .)
    COLON           reduce using rule 99 (valor -> FALSE .)
    AND             reduce using rule 99 (valor -> FALSE .)
    OR              reduce using rule 99 (valor -> FALSE .)
    NOT             reduce using rule 99 (valor -> FALSE .)
    QUESTION        reduce using rule 99 (valor -> FALSE .)


state 42

    (100) valor -> THIS .

    COMMA           reduce using rule 100 (valor -> THIS .)
    SEMICOLON       reduce using rule 100 (valor -> THIS .)
    DOT             reduce using rule 100 (valor -> THIS .)
    PLUS            reduce using rule 100 (valor -> THIS .)
    MINUS           reduce using rule 100 (valor -> THIS .)
    TIMES           reduce using rule 100 (valor -> THIS .)
    DIVIDE          reduce using rule 100 (valor -> THIS .)
    MODULO          reduce using rule 100 (valor -> THIS .)
    RPAREN          reduce using rule 100 (valor -> THIS .)
    EQ              reduce using rule 100 (valor -> THIS .)
    NEQ             reduce using rule 100 (valor -> THIS .)
    STRICTEQ        reduce using rule 100 (valor -> THIS .)
    STRICTNEQ       reduce using rule 100 (valor -> THIS .)
    LT              reduce using rule 100 (valor -> THIS .)
    GT              reduce using rule 100 (valor -> THIS .)
    LEQ             reduce using rule 100 (valor -> THIS .)
    GEQ             reduce using rule 100 (valor -> THIS .)
    ARROWMAP        reduce using rule 100 (valor -> THIS .)
    RBRACKET        reduce using rule 100 (valor -> THIS .)
    COLON           reduce using rule 100 (valor -> THIS .)
    AND             reduce using rule 100 (valor -> THIS .)
    OR              reduce using rule 100 (valor -> THIS .)
    NOT             reduce using rule 100 (valor -> THIS .)
    QUESTION        reduce using rule 100 (valor -> THIS .)


state 43

    (101) valor -> funcionParen .

    COMMA           reduce using rule 101 (valor -> funcionParen .)
    SEMICOLON       reduce using rule 101 (valor -> funcionParen .)
    DOT             reduce using rule 101 (valor -> funcionParen .)
    PLUS            reduce using rule 101 (valor -> funcionParen .)
    MINUS           reduce using rule 101 (valor -> funcionParen .)
    TIMES           reduce using rule 101 (valor -> funcionParen .)
    DIVIDE          reduce using rule 101 (valor -> funcionParen .)
    MODULO          reduce using rule 101 (valor -> funcionParen .)
    RPAREN          reduce using rule 101 (valor -> funcionParen .)
    EQ              reduce using rule 101 (valor -> funcionParen .)
    NEQ             reduce using rule 101 (valor -> funcionParen .)
    STRICTEQ        reduce using rule 101 (valor -> funcionParen .)
    STRICTNEQ       reduce using rule 101 (valor -> funcionParen .)
    LT              reduce using rule 101 (valor -> funcionParen .)
    GT              reduce using rule 101 (valor -> funcionParen .)
    LEQ             reduce using rule 101 (valor -> funcionParen .)
    GEQ             reduce using rule 101 (valor -> funcionParen .)
    ARROWMAP        reduce using rule 101 (valor -> funcionParen .)
    RBRACKET        reduce using rule 101 (valor -> funcionParen .)
    COLON           reduce using rule 101 (valor -> funcionParen .)
    AND             reduce using rule 101 (valor -> funcionParen .)
    OR              reduce using rule 101 (valor -> funcionParen .)
    NOT             reduce using rule 101 (valor -> funcionParen .)
    QUESTION        reduce using rule 101 (valor -> funcionParen .)


state 44

    (72) funcionParen -> ID . LPAREN parametros RPAREN

    LPAREN          shift and go to state 69


state 45

    (12) impresion -> PRINT imprimir . SEMICOLON

    SEMICOLON       shift and go to state 70


state 46

    (107) comparacion -> INT operador . INT
    (109) comparacion -> INT operador . FLOAT

    INT             shift and go to state 71
    FLOAT           shift and go to state 72


state 47

    (121) operador -> PLUS .

    INT             reduce using rule 121 (operador -> PLUS .)
    FLOAT           reduce using rule 121 (operador -> PLUS .)
    VARIABLE        reduce using rule 121 (operador -> PLUS .)
    STRING          reduce using rule 121 (operador -> PLUS .)
    TRUE            reduce using rule 121 (operador -> PLUS .)
    FALSE           reduce using rule 121 (operador -> PLUS .)
    THIS            reduce using rule 121 (operador -> PLUS .)
    ID              reduce using rule 121 (operador -> PLUS .)


state 48

    (122) operador -> MINUS .

    INT             reduce using rule 122 (operador -> MINUS .)
    FLOAT           reduce using rule 122 (operador -> MINUS .)
    VARIABLE        reduce using rule 122 (operador -> MINUS .)
    STRING          reduce using rule 122 (operador -> MINUS .)
    TRUE            reduce using rule 122 (operador -> MINUS .)
    FALSE           reduce using rule 122 (operador -> MINUS .)
    THIS            reduce using rule 122 (operador -> MINUS .)
    ID              reduce using rule 122 (operador -> MINUS .)


state 49

    (123) operador -> TIMES .

    INT             reduce using rule 123 (operador -> TIMES .)
    FLOAT           reduce using rule 123 (operador -> TIMES .)
    VARIABLE        reduce using rule 123 (operador -> TIMES .)
    STRING          reduce using rule 123 (operador -> TIMES .)
    TRUE            reduce using rule 123 (operador -> TIMES .)
    FALSE           reduce using rule 123 (operador -> TIMES .)
    THIS            reduce using rule 123 (operador -> TIMES .)
    ID              reduce using rule 123 (operador -> TIMES .)


state 50

    (124) operador -> DIVIDE .

    INT             reduce using rule 124 (operador -> DIVIDE .)
    FLOAT           reduce using rule 124 (operador -> DIVIDE .)
    VARIABLE        reduce using rule 124 (operador -> DIVIDE .)
    STRING          reduce using rule 124 (operador -> DIVIDE .)
    TRUE            reduce using rule 124 (operador -> DIVIDE .)
    FALSE           reduce using rule 124 (operador -> DIVIDE .)
    THIS            reduce using rule 124 (operador -> DIVIDE .)
    ID              reduce using rule 124 (operador -> DIVIDE .)


state 51

    (125) operador -> MODULO .

    INT             reduce using rule 125 (operador -> MODULO .)
    FLOAT           reduce using rule 125 (operador -> MODULO .)
    VARIABLE        reduce using rule 125 (operador -> MODULO .)
    STRING          reduce using rule 125 (operador -> MODULO .)
    TRUE            reduce using rule 125 (operador -> MODULO .)
    FALSE           reduce using rule 125 (operador -> MODULO .)
    THIS            reduce using rule 125 (operador -> MODULO .)
    ID              reduce using rule 125 (operador -> MODULO .)


state 52

    (108) comparacion -> FLOAT operador . FLOAT
    (110) comparacion -> FLOAT operador . INT

    FLOAT           shift and go to state 73
    INT             shift and go to state 74


state 53

    (59) funcionDeclarate -> FUNCTION ID . LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> FUNCTION ID . LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE

    LPAREN          shift and go to state 75


state 54

    (73) classDeclarate -> CLASS ID . LBRACE classBody RBRACE
    (74) classDeclarate -> CLASS ID . EXTENDS ID LBRACE classBody RBRACE

    LBRACE          shift and go to state 76
    EXTENDS         shift and go to state 77


state 55

    (21) if -> statementif ELSE . body
    (22) if -> statementif ELSE . if
    (88) body -> . sentencia
    (89) body -> . sentencia sentencias
    (90) body -> . empty
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (127) empty -> .
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (107) comparacion -> . INT operador INT
    (108) comparacion -> . FLOAT operador FLOAT
    (109) comparacion -> . INT operador FLOAT
    (110) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (73) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (74) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (81) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    $end            reduce using rule 127 (empty -> .)
    RBRACE          reduce using rule 127 (empty -> .)
    BREAK           reduce using rule 127 (empty -> .)
    IF              shift and go to state 28
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    FOR             shift and go to state 29

  ! VARIABLE        [ reduce using rule 127 (empty -> .) ]
  ! ECHO            [ reduce using rule 127 (empty -> .) ]
  ! PRINT           [ reduce using rule 127 (empty -> .) ]
  ! INT             [ reduce using rule 127 (empty -> .) ]
  ! FLOAT           [ reduce using rule 127 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 127 (empty -> .) ]
  ! CLASS           [ reduce using rule 127 (empty -> .) ]
  ! WHILE           [ reduce using rule 127 (empty -> .) ]
  ! SWITCH          [ reduce using rule 127 (empty -> .) ]
  ! IF              [ reduce using rule 127 (empty -> .) ]
  ! FOR             [ reduce using rule 127 (empty -> .) ]

    statementif                    shift and go to state 24
    body                           shift and go to state 78
    if                             shift and go to state 79
    sentencia                      shift and go to state 80
    empty                          shift and go to state 81
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    forStatement                   shift and go to state 25

state 56

    (23) if -> statementif ELSEIF . if
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE

    IF              shift and go to state 28

    statementif                    shift and go to state 24
    if                             shift and go to state 82

state 57

    (45) while -> WHILE LPAREN . condition RPAREN LBRACE body RBRACE
    (46) while -> WHILE LPAREN . condition RPAREN LBRACE RBRACE
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    LPAREN          shift and go to state 83
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    condition                      shift and go to state 84
    valor                          shift and go to state 85
    funcionParen                   shift and go to state 43

state 58

    (47) switch -> SWITCH LPAREN . condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> SWITCH LPAREN . condition RPAREN LBRACE RBRACE
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    LPAREN          shift and go to state 83
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    condition                      shift and go to state 86
    valor                          shift and go to state 85
    funcionParen                   shift and go to state 43

state 59

    (25) statementif -> IF LPAREN . conditionProdu RPAREN LBRACE body RBRACE
    (26) conditionProdu -> . condition
    (27) conditionProdu -> . condition opLogic conditionProdu
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    LPAREN          shift and go to state 83
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    conditionProdu                 shift and go to state 87
    condition                      shift and go to state 88
    valor                          shift and go to state 85
    funcionParen                   shift and go to state 43

state 60

    (42) forStatement -> FOR LPAREN . forcondition RPAREN LBRACE body RBRACE
    (43) forcondition -> . VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> . VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    VARIABLE        shift and go to state 90

    forcondition                   shift and go to state 89

state 61

    (10) asignacion -> VARIABLE EQUALS operaArit . SEMICOLON

    SEMICOLON       shift and go to state 91


state 62

    (81) array -> VARIABLE EQUALS LBRACKET . repiteValores RBRACKET SEMICOLON
    (83) map -> VARIABLE EQUALS LBRACKET . mapProduc RBRACKET SEMICOLON
    (111) repiteValores -> . valor COMMA repiteValores
    (112) repiteValores -> . valor
    (85) mapProduc -> . mapArrow
    (86) mapProduc -> . mapArrow COMMA mapProduc
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (87) mapArrow -> . valor ARROWMAP valor
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    repiteValores                  shift and go to state 92
    mapProduc                      shift and go to state 93
    valor                          shift and go to state 94
    mapArrow                       shift and go to state 95
    funcionParen                   shift and go to state 43

state 63

    (82) array -> VARIABLE EQUALS ARRAY . LPAREN repiteValores RPAREN SEMICOLON
    (84) map -> VARIABLE EQUALS ARRAY . LPAREN mapProduc RPAREN SEMICOLON

    LPAREN          shift and go to state 96


state 64

    (113) operaArit -> valor .
    (114) operaArit -> valor . operador operaArit
    (115) operaArit -> valor . DOT valor
    (121) operador -> . PLUS
    (122) operador -> . MINUS
    (123) operador -> . TIMES
    (124) operador -> . DIVIDE
    (125) operador -> . MODULO

    SEMICOLON       reduce using rule 113 (operaArit -> valor .)
    COLON           reduce using rule 113 (operaArit -> valor .)
    DOT             shift and go to state 98
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50
    MODULO          shift and go to state 51

    operador                       shift and go to state 97

state 65

    (11) impresion -> ECHO imprimir SEMICOLON .

    VARIABLE        reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    ECHO            reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    PRINT           reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    INT             reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    FLOAT           reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    FUNCTION        reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    CLASS           reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    WHILE           reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    SWITCH          reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    IF              reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    FOR             reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    $end            reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    RBRACE          reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    BREAK           reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)


state 66

    (91) imprimir -> LPAREN repiteValores . RPAREN

    RPAREN          shift and go to state 99


state 67

    (92) imprimir -> LPAREN RPAREN .

    SEMICOLON       reduce using rule 92 (imprimir -> LPAREN RPAREN .)


state 68

    (111) repiteValores -> valor COMMA . repiteValores
    (111) repiteValores -> . valor COMMA repiteValores
    (112) repiteValores -> . valor
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    valor                          shift and go to state 35
    repiteValores                  shift and go to state 100
    funcionParen                   shift and go to state 43

state 69

    (72) funcionParen -> ID LPAREN . parametros RPAREN
    (63) parametros -> . parametro
    (64) parametros -> . parametro COMMA parametros
    (65) parametros -> . empty
    (66) parametro -> . ID
    (67) parametro -> . dataType ID
    (68) parametro -> . ID EQUALS valor
    (69) parametro -> . dataType ID EQUALS valor
    (127) empty -> .
    (102) dataType -> . INTEGER
    (103) dataType -> . FLOATING
    (104) dataType -> . STRINGS
    (105) dataType -> . BOOLEAN
    (106) dataType -> . VOID

    ID              shift and go to state 101
    RPAREN          reduce using rule 127 (empty -> .)
    INTEGER         shift and go to state 106
    FLOATING        shift and go to state 107
    STRINGS         shift and go to state 108
    BOOLEAN         shift and go to state 109
    VOID            shift and go to state 110

    parametros                     shift and go to state 102
    parametro                      shift and go to state 103
    empty                          shift and go to state 104
    dataType                       shift and go to state 105

state 70

    (12) impresion -> PRINT imprimir SEMICOLON .

    VARIABLE        reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    ECHO            reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    PRINT           reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    INT             reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    FLOAT           reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    FUNCTION        reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    CLASS           reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    WHILE           reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    SWITCH          reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    IF              reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    FOR             reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    $end            reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    RBRACE          reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    BREAK           reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)


state 71

    (107) comparacion -> INT operador INT .

    VARIABLE        reduce using rule 107 (comparacion -> INT operador INT .)
    ECHO            reduce using rule 107 (comparacion -> INT operador INT .)
    PRINT           reduce using rule 107 (comparacion -> INT operador INT .)
    INT             reduce using rule 107 (comparacion -> INT operador INT .)
    FLOAT           reduce using rule 107 (comparacion -> INT operador INT .)
    FUNCTION        reduce using rule 107 (comparacion -> INT operador INT .)
    CLASS           reduce using rule 107 (comparacion -> INT operador INT .)
    WHILE           reduce using rule 107 (comparacion -> INT operador INT .)
    SWITCH          reduce using rule 107 (comparacion -> INT operador INT .)
    IF              reduce using rule 107 (comparacion -> INT operador INT .)
    FOR             reduce using rule 107 (comparacion -> INT operador INT .)
    $end            reduce using rule 107 (comparacion -> INT operador INT .)
    RBRACE          reduce using rule 107 (comparacion -> INT operador INT .)
    BREAK           reduce using rule 107 (comparacion -> INT operador INT .)


state 72

    (109) comparacion -> INT operador FLOAT .

    VARIABLE        reduce using rule 109 (comparacion -> INT operador FLOAT .)
    ECHO            reduce using rule 109 (comparacion -> INT operador FLOAT .)
    PRINT           reduce using rule 109 (comparacion -> INT operador FLOAT .)
    INT             reduce using rule 109 (comparacion -> INT operador FLOAT .)
    FLOAT           reduce using rule 109 (comparacion -> INT operador FLOAT .)
    FUNCTION        reduce using rule 109 (comparacion -> INT operador FLOAT .)
    CLASS           reduce using rule 109 (comparacion -> INT operador FLOAT .)
    WHILE           reduce using rule 109 (comparacion -> INT operador FLOAT .)
    SWITCH          reduce using rule 109 (comparacion -> INT operador FLOAT .)
    IF              reduce using rule 109 (comparacion -> INT operador FLOAT .)
    FOR             reduce using rule 109 (comparacion -> INT operador FLOAT .)
    $end            reduce using rule 109 (comparacion -> INT operador FLOAT .)
    RBRACE          reduce using rule 109 (comparacion -> INT operador FLOAT .)
    BREAK           reduce using rule 109 (comparacion -> INT operador FLOAT .)


state 73

    (108) comparacion -> FLOAT operador FLOAT .

    VARIABLE        reduce using rule 108 (comparacion -> FLOAT operador FLOAT .)
    ECHO            reduce using rule 108 (comparacion -> FLOAT operador FLOAT .)
    PRINT           reduce using rule 108 (comparacion -> FLOAT operador FLOAT .)
    INT             reduce using rule 108 (comparacion -> FLOAT operador FLOAT .)
    FLOAT           reduce using rule 108 (comparacion -> FLOAT operador FLOAT .)
    FUNCTION        reduce using rule 108 (comparacion -> FLOAT operador FLOAT .)
    CLASS           reduce using rule 108 (comparacion -> FLOAT operador FLOAT .)
    WHILE           reduce using rule 108 (comparacion -> FLOAT operador FLOAT .)
    SWITCH          reduce using rule 108 (comparacion -> FLOAT operador FLOAT .)
    IF              reduce using rule 108 (comparacion -> FLOAT operador FLOAT .)
    FOR             reduce using rule 108 (comparacion -> FLOAT operador FLOAT .)
    $end            reduce using rule 108 (comparacion -> FLOAT operador FLOAT .)
    RBRACE          reduce using rule 108 (comparacion -> FLOAT operador FLOAT .)
    BREAK           reduce using rule 108 (comparacion -> FLOAT operador FLOAT .)


state 74

    (110) comparacion -> FLOAT operador INT .

    VARIABLE        reduce using rule 110 (comparacion -> FLOAT operador INT .)
    ECHO            reduce using rule 110 (comparacion -> FLOAT operador INT .)
    PRINT           reduce using rule 110 (comparacion -> FLOAT operador INT .)
    INT             reduce using rule 110 (comparacion -> FLOAT operador INT .)
    FLOAT           reduce using rule 110 (comparacion -> FLOAT operador INT .)
    FUNCTION        reduce using rule 110 (comparacion -> FLOAT operador INT .)
    CLASS           reduce using rule 110 (comparacion -> FLOAT operador INT .)
    WHILE           reduce using rule 110 (comparacion -> FLOAT operador INT .)
    SWITCH          reduce using rule 110 (comparacion -> FLOAT operador INT .)
    IF              reduce using rule 110 (comparacion -> FLOAT operador INT .)
    FOR             reduce using rule 110 (comparacion -> FLOAT operador INT .)
    $end            reduce using rule 110 (comparacion -> FLOAT operador INT .)
    RBRACE          reduce using rule 110 (comparacion -> FLOAT operador INT .)
    BREAK           reduce using rule 110 (comparacion -> FLOAT operador INT .)


state 75

    (59) funcionDeclarate -> FUNCTION ID LPAREN . parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> FUNCTION ID LPAREN . parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (63) parametros -> . parametro
    (64) parametros -> . parametro COMMA parametros
    (65) parametros -> . empty
    (66) parametro -> . ID
    (67) parametro -> . dataType ID
    (68) parametro -> . ID EQUALS valor
    (69) parametro -> . dataType ID EQUALS valor
    (127) empty -> .
    (102) dataType -> . INTEGER
    (103) dataType -> . FLOATING
    (104) dataType -> . STRINGS
    (105) dataType -> . BOOLEAN
    (106) dataType -> . VOID

    ID              shift and go to state 101
    RPAREN          reduce using rule 127 (empty -> .)
    INTEGER         shift and go to state 106
    FLOATING        shift and go to state 107
    STRINGS         shift and go to state 108
    BOOLEAN         shift and go to state 109
    VOID            shift and go to state 110

    parametros                     shift and go to state 111
    dataType                       shift and go to state 105
    parametro                      shift and go to state 103
    empty                          shift and go to state 104

state 76

    (73) classDeclarate -> CLASS ID LBRACE . classBody RBRACE
    (75) classBody -> . classMember classBody
    (76) classBody -> . empty
    (77) classMember -> . dataType VARIABLE SEMICOLON
    (78) classMember -> . dataType FUNCTION ID LPAREN parametros RPAREN brace
    (127) empty -> .
    (102) dataType -> . INTEGER
    (103) dataType -> . FLOATING
    (104) dataType -> . STRINGS
    (105) dataType -> . BOOLEAN
    (106) dataType -> . VOID

    RBRACE          reduce using rule 127 (empty -> .)
    INTEGER         shift and go to state 106
    FLOATING        shift and go to state 107
    STRINGS         shift and go to state 108
    BOOLEAN         shift and go to state 109
    VOID            shift and go to state 110

    classBody                      shift and go to state 112
    classMember                    shift and go to state 113
    empty                          shift and go to state 114
    dataType                       shift and go to state 115

state 77

    (74) classDeclarate -> CLASS ID EXTENDS . ID LBRACE classBody RBRACE

    ID              shift and go to state 116


state 78

    (21) if -> statementif ELSE body .

    VARIABLE        reduce using rule 21 (if -> statementif ELSE body .)
    ECHO            reduce using rule 21 (if -> statementif ELSE body .)
    PRINT           reduce using rule 21 (if -> statementif ELSE body .)
    INT             reduce using rule 21 (if -> statementif ELSE body .)
    FLOAT           reduce using rule 21 (if -> statementif ELSE body .)
    FUNCTION        reduce using rule 21 (if -> statementif ELSE body .)
    CLASS           reduce using rule 21 (if -> statementif ELSE body .)
    WHILE           reduce using rule 21 (if -> statementif ELSE body .)
    SWITCH          reduce using rule 21 (if -> statementif ELSE body .)
    IF              reduce using rule 21 (if -> statementif ELSE body .)
    FOR             reduce using rule 21 (if -> statementif ELSE body .)
    $end            reduce using rule 21 (if -> statementif ELSE body .)
    RBRACE          reduce using rule 21 (if -> statementif ELSE body .)
    BREAK           reduce using rule 21 (if -> statementif ELSE body .)


state 79

    (22) if -> statementif ELSE if .
    (17) controlStructure -> if .

  ! reduce/reduce conflict for VARIABLE resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for ECHO resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for PRINT resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for INT resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for FLOAT resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for CLASS resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for WHILE resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for SWITCH resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for IF resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for FOR resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for $end resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for RBRACE resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for BREAK resolved using rule 17 (controlStructure -> if .)
    VARIABLE        reduce using rule 17 (controlStructure -> if .)
    ECHO            reduce using rule 17 (controlStructure -> if .)
    PRINT           reduce using rule 17 (controlStructure -> if .)
    INT             reduce using rule 17 (controlStructure -> if .)
    FLOAT           reduce using rule 17 (controlStructure -> if .)
    FUNCTION        reduce using rule 17 (controlStructure -> if .)
    CLASS           reduce using rule 17 (controlStructure -> if .)
    WHILE           reduce using rule 17 (controlStructure -> if .)
    SWITCH          reduce using rule 17 (controlStructure -> if .)
    IF              reduce using rule 17 (controlStructure -> if .)
    FOR             reduce using rule 17 (controlStructure -> if .)
    $end            reduce using rule 17 (controlStructure -> if .)
    RBRACE          reduce using rule 17 (controlStructure -> if .)
    BREAK           reduce using rule 17 (controlStructure -> if .)

  ! VARIABLE        [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! ECHO            [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! PRINT           [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! INT             [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! FLOAT           [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! FUNCTION        [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! CLASS           [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! WHILE           [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! SWITCH          [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! IF              [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! FOR             [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! $end            [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! RBRACE          [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! BREAK           [ reduce using rule 22 (if -> statementif ELSE if .) ]


state 80

    (88) body -> sentencia .
    (89) body -> sentencia . sentencias
    (7) sentencias -> . sentencia
    (8) sentencias -> . sentencia sentencias
    (9) sentencias -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (127) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (107) comparacion -> . INT operador INT
    (108) comparacion -> . FLOAT operador FLOAT
    (109) comparacion -> . INT operador FLOAT
    (110) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (73) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (74) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (81) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

  ! reduce/reduce conflict for VARIABLE resolved using rule 88 (body -> sentencia .)
  ! reduce/reduce conflict for ECHO resolved using rule 88 (body -> sentencia .)
  ! reduce/reduce conflict for PRINT resolved using rule 88 (body -> sentencia .)
  ! reduce/reduce conflict for INT resolved using rule 88 (body -> sentencia .)
  ! reduce/reduce conflict for FLOAT resolved using rule 88 (body -> sentencia .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 88 (body -> sentencia .)
  ! reduce/reduce conflict for CLASS resolved using rule 88 (body -> sentencia .)
  ! reduce/reduce conflict for WHILE resolved using rule 88 (body -> sentencia .)
  ! reduce/reduce conflict for SWITCH resolved using rule 88 (body -> sentencia .)
  ! reduce/reduce conflict for IF resolved using rule 88 (body -> sentencia .)
  ! reduce/reduce conflict for FOR resolved using rule 88 (body -> sentencia .)
  ! reduce/reduce conflict for $end resolved using rule 88 (body -> sentencia .)
  ! reduce/reduce conflict for RBRACE resolved using rule 88 (body -> sentencia .)
  ! reduce/reduce conflict for BREAK resolved using rule 88 (body -> sentencia .)
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    $end            reduce using rule 88 (body -> sentencia .)
    RBRACE          reduce using rule 88 (body -> sentencia .)
    BREAK           reduce using rule 88 (body -> sentencia .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

  ! VARIABLE        [ reduce using rule 88 (body -> sentencia .) ]
  ! ECHO            [ reduce using rule 88 (body -> sentencia .) ]
  ! PRINT           [ reduce using rule 88 (body -> sentencia .) ]
  ! INT             [ reduce using rule 88 (body -> sentencia .) ]
  ! FLOAT           [ reduce using rule 88 (body -> sentencia .) ]
  ! FUNCTION        [ reduce using rule 88 (body -> sentencia .) ]
  ! CLASS           [ reduce using rule 88 (body -> sentencia .) ]
  ! WHILE           [ reduce using rule 88 (body -> sentencia .) ]
  ! SWITCH          [ reduce using rule 88 (body -> sentencia .) ]
  ! IF              [ reduce using rule 88 (body -> sentencia .) ]
  ! FOR             [ reduce using rule 88 (body -> sentencia .) ]
  ! VARIABLE        [ reduce using rule 127 (empty -> .) ]
  ! ECHO            [ reduce using rule 127 (empty -> .) ]
  ! PRINT           [ reduce using rule 127 (empty -> .) ]
  ! INT             [ reduce using rule 127 (empty -> .) ]
  ! FLOAT           [ reduce using rule 127 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 127 (empty -> .) ]
  ! CLASS           [ reduce using rule 127 (empty -> .) ]
  ! WHILE           [ reduce using rule 127 (empty -> .) ]
  ! SWITCH          [ reduce using rule 127 (empty -> .) ]
  ! IF              [ reduce using rule 127 (empty -> .) ]
  ! FOR             [ reduce using rule 127 (empty -> .) ]
  ! $end            [ reduce using rule 127 (empty -> .) ]
  ! RBRACE          [ reduce using rule 127 (empty -> .) ]
  ! BREAK           [ reduce using rule 127 (empty -> .) ]

    sentencia                      shift and go to state 117
    sentencias                     shift and go to state 118
    empty                          shift and go to state 119
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 81

    (90) body -> empty .

    VARIABLE        reduce using rule 90 (body -> empty .)
    ECHO            reduce using rule 90 (body -> empty .)
    PRINT           reduce using rule 90 (body -> empty .)
    INT             reduce using rule 90 (body -> empty .)
    FLOAT           reduce using rule 90 (body -> empty .)
    FUNCTION        reduce using rule 90 (body -> empty .)
    CLASS           reduce using rule 90 (body -> empty .)
    WHILE           reduce using rule 90 (body -> empty .)
    SWITCH          reduce using rule 90 (body -> empty .)
    IF              reduce using rule 90 (body -> empty .)
    FOR             reduce using rule 90 (body -> empty .)
    $end            reduce using rule 90 (body -> empty .)
    RBRACE          reduce using rule 90 (body -> empty .)
    BREAK           reduce using rule 90 (body -> empty .)


state 82

    (23) if -> statementif ELSEIF if .

    VARIABLE        reduce using rule 23 (if -> statementif ELSEIF if .)
    ECHO            reduce using rule 23 (if -> statementif ELSEIF if .)
    PRINT           reduce using rule 23 (if -> statementif ELSEIF if .)
    INT             reduce using rule 23 (if -> statementif ELSEIF if .)
    FLOAT           reduce using rule 23 (if -> statementif ELSEIF if .)
    FUNCTION        reduce using rule 23 (if -> statementif ELSEIF if .)
    CLASS           reduce using rule 23 (if -> statementif ELSEIF if .)
    WHILE           reduce using rule 23 (if -> statementif ELSEIF if .)
    SWITCH          reduce using rule 23 (if -> statementif ELSEIF if .)
    IF              reduce using rule 23 (if -> statementif ELSEIF if .)
    FOR             reduce using rule 23 (if -> statementif ELSEIF if .)
    $end            reduce using rule 23 (if -> statementif ELSEIF if .)
    RBRACE          reduce using rule 23 (if -> statementif ELSEIF if .)
    BREAK           reduce using rule 23 (if -> statementif ELSEIF if .)


state 83

    (29) condition -> LPAREN . conditionProdu RPAREN
    (26) conditionProdu -> . condition
    (27) conditionProdu -> . condition opLogic conditionProdu
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    LPAREN          shift and go to state 83
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    conditionProdu                 shift and go to state 120
    condition                      shift and go to state 88
    valor                          shift and go to state 85
    funcionParen                   shift and go to state 43

state 84

    (45) while -> WHILE LPAREN condition . RPAREN LBRACE body RBRACE
    (46) while -> WHILE LPAREN condition . RPAREN LBRACE RBRACE

    RPAREN          shift and go to state 121


state 85

    (28) condition -> valor . opSymbol valor
    (30) opSymbol -> . EQ
    (31) opSymbol -> . NEQ
    (32) opSymbol -> . STRICTEQ
    (33) opSymbol -> . STRICTNEQ
    (34) opSymbol -> . LT
    (35) opSymbol -> . GT
    (36) opSymbol -> . LEQ
    (37) opSymbol -> . GEQ

    EQ              shift and go to state 123
    NEQ             shift and go to state 124
    STRICTEQ        shift and go to state 125
    STRICTNEQ       shift and go to state 126
    LT              shift and go to state 127
    GT              shift and go to state 128
    LEQ             shift and go to state 129
    GEQ             shift and go to state 130

    opSymbol                       shift and go to state 122

state 86

    (47) switch -> SWITCH LPAREN condition . RPAREN LBRACE caseLists RBRACE
    (48) switch -> SWITCH LPAREN condition . RPAREN LBRACE RBRACE

    RPAREN          shift and go to state 131


state 87

    (25) statementif -> IF LPAREN conditionProdu . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 132


state 88

    (26) conditionProdu -> condition .
    (27) conditionProdu -> condition . opLogic conditionProdu
    (38) opLogic -> . AND
    (39) opLogic -> . OR
    (40) opLogic -> . NOT

    RPAREN          reduce using rule 26 (conditionProdu -> condition .)
    QUESTION        reduce using rule 26 (conditionProdu -> condition .)
    SEMICOLON       reduce using rule 26 (conditionProdu -> condition .)
    COLON           reduce using rule 26 (conditionProdu -> condition .)
    AND             shift and go to state 134
    OR              shift and go to state 135
    NOT             shift and go to state 136

    opLogic                        shift and go to state 133

state 89

    (42) forStatement -> FOR LPAREN forcondition . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 137


state 90

    (43) forcondition -> VARIABLE . EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE . EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    EQUALS          shift and go to state 138


state 91

    (10) asignacion -> VARIABLE EQUALS operaArit SEMICOLON .

    VARIABLE        reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    ECHO            reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    PRINT           reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    INT             reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    FLOAT           reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    FUNCTION        reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    CLASS           reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    WHILE           reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    SWITCH          reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    IF              reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    FOR             reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    $end            reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    RBRACE          reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    BREAK           reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)


state 92

    (81) array -> VARIABLE EQUALS LBRACKET repiteValores . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 139


state 93

    (83) map -> VARIABLE EQUALS LBRACKET mapProduc . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 140


state 94

    (111) repiteValores -> valor . COMMA repiteValores
    (112) repiteValores -> valor .
    (87) mapArrow -> valor . ARROWMAP valor

    COMMA           shift and go to state 68
    RBRACKET        reduce using rule 112 (repiteValores -> valor .)
    RPAREN          reduce using rule 112 (repiteValores -> valor .)
    ARROWMAP        shift and go to state 141


state 95

    (85) mapProduc -> mapArrow .
    (86) mapProduc -> mapArrow . COMMA mapProduc

    RBRACKET        reduce using rule 85 (mapProduc -> mapArrow .)
    RPAREN          reduce using rule 85 (mapProduc -> mapArrow .)
    COMMA           shift and go to state 142


state 96

    (82) array -> VARIABLE EQUALS ARRAY LPAREN . repiteValores RPAREN SEMICOLON
    (84) map -> VARIABLE EQUALS ARRAY LPAREN . mapProduc RPAREN SEMICOLON
    (111) repiteValores -> . valor COMMA repiteValores
    (112) repiteValores -> . valor
    (85) mapProduc -> . mapArrow
    (86) mapProduc -> . mapArrow COMMA mapProduc
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (87) mapArrow -> . valor ARROWMAP valor
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    repiteValores                  shift and go to state 143
    mapProduc                      shift and go to state 144
    valor                          shift and go to state 94
    mapArrow                       shift and go to state 95
    funcionParen                   shift and go to state 43

state 97

    (114) operaArit -> valor operador . operaArit
    (113) operaArit -> . valor
    (114) operaArit -> . valor operador operaArit
    (115) operaArit -> . valor DOT valor
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    valor                          shift and go to state 64
    operaArit                      shift and go to state 145
    funcionParen                   shift and go to state 43

state 98

    (115) operaArit -> valor DOT . valor
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    valor                          shift and go to state 146
    funcionParen                   shift and go to state 43

state 99

    (91) imprimir -> LPAREN repiteValores RPAREN .

    SEMICOLON       reduce using rule 91 (imprimir -> LPAREN repiteValores RPAREN .)


state 100

    (111) repiteValores -> valor COMMA repiteValores .

    SEMICOLON       reduce using rule 111 (repiteValores -> valor COMMA repiteValores .)
    RPAREN          reduce using rule 111 (repiteValores -> valor COMMA repiteValores .)
    RBRACKET        reduce using rule 111 (repiteValores -> valor COMMA repiteValores .)


state 101

    (66) parametro -> ID .
    (68) parametro -> ID . EQUALS valor

    COMMA           reduce using rule 66 (parametro -> ID .)
    RPAREN          reduce using rule 66 (parametro -> ID .)
    EQUALS          shift and go to state 147


state 102

    (72) funcionParen -> ID LPAREN parametros . RPAREN

    RPAREN          shift and go to state 148


state 103

    (63) parametros -> parametro .
    (64) parametros -> parametro . COMMA parametros

    RPAREN          reduce using rule 63 (parametros -> parametro .)
    COMMA           shift and go to state 149


state 104

    (65) parametros -> empty .

    RPAREN          reduce using rule 65 (parametros -> empty .)


state 105

    (67) parametro -> dataType . ID
    (69) parametro -> dataType . ID EQUALS valor

    ID              shift and go to state 150


state 106

    (102) dataType -> INTEGER .

    ID              reduce using rule 102 (dataType -> INTEGER .)
    VARIABLE        reduce using rule 102 (dataType -> INTEGER .)
    FUNCTION        reduce using rule 102 (dataType -> INTEGER .)
    LBRACE          reduce using rule 102 (dataType -> INTEGER .)


state 107

    (103) dataType -> FLOATING .

    ID              reduce using rule 103 (dataType -> FLOATING .)
    VARIABLE        reduce using rule 103 (dataType -> FLOATING .)
    FUNCTION        reduce using rule 103 (dataType -> FLOATING .)
    LBRACE          reduce using rule 103 (dataType -> FLOATING .)


state 108

    (104) dataType -> STRINGS .

    ID              reduce using rule 104 (dataType -> STRINGS .)
    VARIABLE        reduce using rule 104 (dataType -> STRINGS .)
    FUNCTION        reduce using rule 104 (dataType -> STRINGS .)
    LBRACE          reduce using rule 104 (dataType -> STRINGS .)


state 109

    (105) dataType -> BOOLEAN .

    ID              reduce using rule 105 (dataType -> BOOLEAN .)
    VARIABLE        reduce using rule 105 (dataType -> BOOLEAN .)
    FUNCTION        reduce using rule 105 (dataType -> BOOLEAN .)
    LBRACE          reduce using rule 105 (dataType -> BOOLEAN .)


state 110

    (106) dataType -> VOID .

    ID              reduce using rule 106 (dataType -> VOID .)
    VARIABLE        reduce using rule 106 (dataType -> VOID .)
    FUNCTION        reduce using rule 106 (dataType -> VOID .)
    LBRACE          reduce using rule 106 (dataType -> VOID .)


state 111

    (59) funcionDeclarate -> FUNCTION ID LPAREN parametros . RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> FUNCTION ID LPAREN parametros . RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE

    RPAREN          shift and go to state 151


state 112

    (73) classDeclarate -> CLASS ID LBRACE classBody . RBRACE

    RBRACE          shift and go to state 152


state 113

    (75) classBody -> classMember . classBody
    (75) classBody -> . classMember classBody
    (76) classBody -> . empty
    (77) classMember -> . dataType VARIABLE SEMICOLON
    (78) classMember -> . dataType FUNCTION ID LPAREN parametros RPAREN brace
    (127) empty -> .
    (102) dataType -> . INTEGER
    (103) dataType -> . FLOATING
    (104) dataType -> . STRINGS
    (105) dataType -> . BOOLEAN
    (106) dataType -> . VOID

    RBRACE          reduce using rule 127 (empty -> .)
    INTEGER         shift and go to state 106
    FLOATING        shift and go to state 107
    STRINGS         shift and go to state 108
    BOOLEAN         shift and go to state 109
    VOID            shift and go to state 110

    classMember                    shift and go to state 113
    classBody                      shift and go to state 153
    empty                          shift and go to state 114
    dataType                       shift and go to state 115

state 114

    (76) classBody -> empty .

    RBRACE          reduce using rule 76 (classBody -> empty .)


state 115

    (77) classMember -> dataType . VARIABLE SEMICOLON
    (78) classMember -> dataType . FUNCTION ID LPAREN parametros RPAREN brace

    VARIABLE        shift and go to state 154
    FUNCTION        shift and go to state 155


state 116

    (74) classDeclarate -> CLASS ID EXTENDS ID . LBRACE classBody RBRACE

    LBRACE          shift and go to state 156


state 117

    (7) sentencias -> sentencia .
    (8) sentencias -> sentencia . sentencias
    (7) sentencias -> . sentencia
    (8) sentencias -> . sentencia sentencias
    (9) sentencias -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (127) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (107) comparacion -> . INT operador INT
    (108) comparacion -> . FLOAT operador FLOAT
    (109) comparacion -> . INT operador FLOAT
    (110) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (73) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (74) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (81) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

  ! reduce/reduce conflict for VARIABLE resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for ECHO resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for PRINT resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for INT resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for FLOAT resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for CLASS resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for WHILE resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for SWITCH resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for IF resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for FOR resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for $end resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for RBRACE resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for BREAK resolved using rule 7 (sentencias -> sentencia .)
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    $end            reduce using rule 7 (sentencias -> sentencia .)
    RBRACE          reduce using rule 7 (sentencias -> sentencia .)
    BREAK           reduce using rule 7 (sentencias -> sentencia .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

  ! VARIABLE        [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! ECHO            [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! PRINT           [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! INT             [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! FLOAT           [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! FUNCTION        [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! CLASS           [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! WHILE           [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! SWITCH          [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! IF              [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! FOR             [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! VARIABLE        [ reduce using rule 127 (empty -> .) ]
  ! ECHO            [ reduce using rule 127 (empty -> .) ]
  ! PRINT           [ reduce using rule 127 (empty -> .) ]
  ! INT             [ reduce using rule 127 (empty -> .) ]
  ! FLOAT           [ reduce using rule 127 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 127 (empty -> .) ]
  ! CLASS           [ reduce using rule 127 (empty -> .) ]
  ! WHILE           [ reduce using rule 127 (empty -> .) ]
  ! SWITCH          [ reduce using rule 127 (empty -> .) ]
  ! IF              [ reduce using rule 127 (empty -> .) ]
  ! FOR             [ reduce using rule 127 (empty -> .) ]
  ! $end            [ reduce using rule 127 (empty -> .) ]
  ! RBRACE          [ reduce using rule 127 (empty -> .) ]
  ! BREAK           [ reduce using rule 127 (empty -> .) ]

    sentencia                      shift and go to state 117
    sentencias                     shift and go to state 157
    empty                          shift and go to state 119
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 118

    (89) body -> sentencia sentencias .

    VARIABLE        reduce using rule 89 (body -> sentencia sentencias .)
    ECHO            reduce using rule 89 (body -> sentencia sentencias .)
    PRINT           reduce using rule 89 (body -> sentencia sentencias .)
    INT             reduce using rule 89 (body -> sentencia sentencias .)
    FLOAT           reduce using rule 89 (body -> sentencia sentencias .)
    FUNCTION        reduce using rule 89 (body -> sentencia sentencias .)
    CLASS           reduce using rule 89 (body -> sentencia sentencias .)
    WHILE           reduce using rule 89 (body -> sentencia sentencias .)
    SWITCH          reduce using rule 89 (body -> sentencia sentencias .)
    IF              reduce using rule 89 (body -> sentencia sentencias .)
    FOR             reduce using rule 89 (body -> sentencia sentencias .)
    $end            reduce using rule 89 (body -> sentencia sentencias .)
    RBRACE          reduce using rule 89 (body -> sentencia sentencias .)
    BREAK           reduce using rule 89 (body -> sentencia sentencias .)


state 119

    (9) sentencias -> empty .

    VARIABLE        reduce using rule 9 (sentencias -> empty .)
    ECHO            reduce using rule 9 (sentencias -> empty .)
    PRINT           reduce using rule 9 (sentencias -> empty .)
    INT             reduce using rule 9 (sentencias -> empty .)
    FLOAT           reduce using rule 9 (sentencias -> empty .)
    FUNCTION        reduce using rule 9 (sentencias -> empty .)
    CLASS           reduce using rule 9 (sentencias -> empty .)
    WHILE           reduce using rule 9 (sentencias -> empty .)
    SWITCH          reduce using rule 9 (sentencias -> empty .)
    IF              reduce using rule 9 (sentencias -> empty .)
    FOR             reduce using rule 9 (sentencias -> empty .)
    $end            reduce using rule 9 (sentencias -> empty .)
    RBRACE          reduce using rule 9 (sentencias -> empty .)
    BREAK           reduce using rule 9 (sentencias -> empty .)


state 120

    (29) condition -> LPAREN conditionProdu . RPAREN

    RPAREN          shift and go to state 158


state 121

    (45) while -> WHILE LPAREN condition RPAREN . LBRACE body RBRACE
    (46) while -> WHILE LPAREN condition RPAREN . LBRACE RBRACE

    LBRACE          shift and go to state 159


state 122

    (28) condition -> valor opSymbol . valor
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    valor                          shift and go to state 160
    funcionParen                   shift and go to state 43

state 123

    (30) opSymbol -> EQ .

    INT             reduce using rule 30 (opSymbol -> EQ .)
    FLOAT           reduce using rule 30 (opSymbol -> EQ .)
    VARIABLE        reduce using rule 30 (opSymbol -> EQ .)
    STRING          reduce using rule 30 (opSymbol -> EQ .)
    TRUE            reduce using rule 30 (opSymbol -> EQ .)
    FALSE           reduce using rule 30 (opSymbol -> EQ .)
    THIS            reduce using rule 30 (opSymbol -> EQ .)
    ID              reduce using rule 30 (opSymbol -> EQ .)


state 124

    (31) opSymbol -> NEQ .

    INT             reduce using rule 31 (opSymbol -> NEQ .)
    FLOAT           reduce using rule 31 (opSymbol -> NEQ .)
    VARIABLE        reduce using rule 31 (opSymbol -> NEQ .)
    STRING          reduce using rule 31 (opSymbol -> NEQ .)
    TRUE            reduce using rule 31 (opSymbol -> NEQ .)
    FALSE           reduce using rule 31 (opSymbol -> NEQ .)
    THIS            reduce using rule 31 (opSymbol -> NEQ .)
    ID              reduce using rule 31 (opSymbol -> NEQ .)


state 125

    (32) opSymbol -> STRICTEQ .

    INT             reduce using rule 32 (opSymbol -> STRICTEQ .)
    FLOAT           reduce using rule 32 (opSymbol -> STRICTEQ .)
    VARIABLE        reduce using rule 32 (opSymbol -> STRICTEQ .)
    STRING          reduce using rule 32 (opSymbol -> STRICTEQ .)
    TRUE            reduce using rule 32 (opSymbol -> STRICTEQ .)
    FALSE           reduce using rule 32 (opSymbol -> STRICTEQ .)
    THIS            reduce using rule 32 (opSymbol -> STRICTEQ .)
    ID              reduce using rule 32 (opSymbol -> STRICTEQ .)


state 126

    (33) opSymbol -> STRICTNEQ .

    INT             reduce using rule 33 (opSymbol -> STRICTNEQ .)
    FLOAT           reduce using rule 33 (opSymbol -> STRICTNEQ .)
    VARIABLE        reduce using rule 33 (opSymbol -> STRICTNEQ .)
    STRING          reduce using rule 33 (opSymbol -> STRICTNEQ .)
    TRUE            reduce using rule 33 (opSymbol -> STRICTNEQ .)
    FALSE           reduce using rule 33 (opSymbol -> STRICTNEQ .)
    THIS            reduce using rule 33 (opSymbol -> STRICTNEQ .)
    ID              reduce using rule 33 (opSymbol -> STRICTNEQ .)


state 127

    (34) opSymbol -> LT .

    INT             reduce using rule 34 (opSymbol -> LT .)
    FLOAT           reduce using rule 34 (opSymbol -> LT .)
    VARIABLE        reduce using rule 34 (opSymbol -> LT .)
    STRING          reduce using rule 34 (opSymbol -> LT .)
    TRUE            reduce using rule 34 (opSymbol -> LT .)
    FALSE           reduce using rule 34 (opSymbol -> LT .)
    THIS            reduce using rule 34 (opSymbol -> LT .)
    ID              reduce using rule 34 (opSymbol -> LT .)


state 128

    (35) opSymbol -> GT .

    INT             reduce using rule 35 (opSymbol -> GT .)
    FLOAT           reduce using rule 35 (opSymbol -> GT .)
    VARIABLE        reduce using rule 35 (opSymbol -> GT .)
    STRING          reduce using rule 35 (opSymbol -> GT .)
    TRUE            reduce using rule 35 (opSymbol -> GT .)
    FALSE           reduce using rule 35 (opSymbol -> GT .)
    THIS            reduce using rule 35 (opSymbol -> GT .)
    ID              reduce using rule 35 (opSymbol -> GT .)


state 129

    (36) opSymbol -> LEQ .

    INT             reduce using rule 36 (opSymbol -> LEQ .)
    FLOAT           reduce using rule 36 (opSymbol -> LEQ .)
    VARIABLE        reduce using rule 36 (opSymbol -> LEQ .)
    STRING          reduce using rule 36 (opSymbol -> LEQ .)
    TRUE            reduce using rule 36 (opSymbol -> LEQ .)
    FALSE           reduce using rule 36 (opSymbol -> LEQ .)
    THIS            reduce using rule 36 (opSymbol -> LEQ .)
    ID              reduce using rule 36 (opSymbol -> LEQ .)


state 130

    (37) opSymbol -> GEQ .

    INT             reduce using rule 37 (opSymbol -> GEQ .)
    FLOAT           reduce using rule 37 (opSymbol -> GEQ .)
    VARIABLE        reduce using rule 37 (opSymbol -> GEQ .)
    STRING          reduce using rule 37 (opSymbol -> GEQ .)
    TRUE            reduce using rule 37 (opSymbol -> GEQ .)
    FALSE           reduce using rule 37 (opSymbol -> GEQ .)
    THIS            reduce using rule 37 (opSymbol -> GEQ .)
    ID              reduce using rule 37 (opSymbol -> GEQ .)


state 131

    (47) switch -> SWITCH LPAREN condition RPAREN . LBRACE caseLists RBRACE
    (48) switch -> SWITCH LPAREN condition RPAREN . LBRACE RBRACE

    LBRACE          shift and go to state 161


state 132

    (25) statementif -> IF LPAREN conditionProdu RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 162


state 133

    (27) conditionProdu -> condition opLogic . conditionProdu
    (26) conditionProdu -> . condition
    (27) conditionProdu -> . condition opLogic conditionProdu
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    LPAREN          shift and go to state 83
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    condition                      shift and go to state 88
    conditionProdu                 shift and go to state 163
    valor                          shift and go to state 85
    funcionParen                   shift and go to state 43

state 134

    (38) opLogic -> AND .

    LPAREN          reduce using rule 38 (opLogic -> AND .)
    INT             reduce using rule 38 (opLogic -> AND .)
    FLOAT           reduce using rule 38 (opLogic -> AND .)
    VARIABLE        reduce using rule 38 (opLogic -> AND .)
    STRING          reduce using rule 38 (opLogic -> AND .)
    TRUE            reduce using rule 38 (opLogic -> AND .)
    FALSE           reduce using rule 38 (opLogic -> AND .)
    THIS            reduce using rule 38 (opLogic -> AND .)
    ID              reduce using rule 38 (opLogic -> AND .)


state 135

    (39) opLogic -> OR .

    LPAREN          reduce using rule 39 (opLogic -> OR .)
    INT             reduce using rule 39 (opLogic -> OR .)
    FLOAT           reduce using rule 39 (opLogic -> OR .)
    VARIABLE        reduce using rule 39 (opLogic -> OR .)
    STRING          reduce using rule 39 (opLogic -> OR .)
    TRUE            reduce using rule 39 (opLogic -> OR .)
    FALSE           reduce using rule 39 (opLogic -> OR .)
    THIS            reduce using rule 39 (opLogic -> OR .)
    ID              reduce using rule 39 (opLogic -> OR .)


state 136

    (40) opLogic -> NOT .

    LPAREN          reduce using rule 40 (opLogic -> NOT .)
    INT             reduce using rule 40 (opLogic -> NOT .)
    FLOAT           reduce using rule 40 (opLogic -> NOT .)
    VARIABLE        reduce using rule 40 (opLogic -> NOT .)
    STRING          reduce using rule 40 (opLogic -> NOT .)
    TRUE            reduce using rule 40 (opLogic -> NOT .)
    FALSE           reduce using rule 40 (opLogic -> NOT .)
    THIS            reduce using rule 40 (opLogic -> NOT .)
    ID              reduce using rule 40 (opLogic -> NOT .)


state 137

    (42) forStatement -> FOR LPAREN forcondition RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 164


state 138

    (43) forcondition -> VARIABLE EQUALS . INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS . INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    INT             shift and go to state 165


state 139

    (81) array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 166


state 140

    (83) map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 167


state 141

    (87) mapArrow -> valor ARROWMAP . valor
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    valor                          shift and go to state 168
    funcionParen                   shift and go to state 43

state 142

    (86) mapProduc -> mapArrow COMMA . mapProduc
    (85) mapProduc -> . mapArrow
    (86) mapProduc -> . mapArrow COMMA mapProduc
    (87) mapArrow -> . valor ARROWMAP valor
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    mapArrow                       shift and go to state 95
    mapProduc                      shift and go to state 169
    valor                          shift and go to state 170
    funcionParen                   shift and go to state 43

state 143

    (82) array -> VARIABLE EQUALS ARRAY LPAREN repiteValores . RPAREN SEMICOLON

    RPAREN          shift and go to state 171


state 144

    (84) map -> VARIABLE EQUALS ARRAY LPAREN mapProduc . RPAREN SEMICOLON

    RPAREN          shift and go to state 172


state 145

    (114) operaArit -> valor operador operaArit .

    SEMICOLON       reduce using rule 114 (operaArit -> valor operador operaArit .)
    COLON           reduce using rule 114 (operaArit -> valor operador operaArit .)


state 146

    (115) operaArit -> valor DOT valor .

    SEMICOLON       reduce using rule 115 (operaArit -> valor DOT valor .)
    COLON           reduce using rule 115 (operaArit -> valor DOT valor .)


state 147

    (68) parametro -> ID EQUALS . valor
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    valor                          shift and go to state 173
    funcionParen                   shift and go to state 43

state 148

    (72) funcionParen -> ID LPAREN parametros RPAREN .

    COMMA           reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    SEMICOLON       reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    DOT             reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    PLUS            reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    MINUS           reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    TIMES           reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    DIVIDE          reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    MODULO          reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    RPAREN          reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    EQ              reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    NEQ             reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    STRICTEQ        reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    STRICTNEQ       reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    LT              reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    GT              reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    LEQ             reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    GEQ             reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    ARROWMAP        reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    RBRACKET        reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    COLON           reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    AND             reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    OR              reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    NOT             reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    QUESTION        reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)


state 149

    (64) parametros -> parametro COMMA . parametros
    (63) parametros -> . parametro
    (64) parametros -> . parametro COMMA parametros
    (65) parametros -> . empty
    (66) parametro -> . ID
    (67) parametro -> . dataType ID
    (68) parametro -> . ID EQUALS valor
    (69) parametro -> . dataType ID EQUALS valor
    (127) empty -> .
    (102) dataType -> . INTEGER
    (103) dataType -> . FLOATING
    (104) dataType -> . STRINGS
    (105) dataType -> . BOOLEAN
    (106) dataType -> . VOID

    ID              shift and go to state 101
    RPAREN          reduce using rule 127 (empty -> .)
    INTEGER         shift and go to state 106
    FLOATING        shift and go to state 107
    STRINGS         shift and go to state 108
    BOOLEAN         shift and go to state 109
    VOID            shift and go to state 110

    parametro                      shift and go to state 103
    parametros                     shift and go to state 174
    empty                          shift and go to state 104
    dataType                       shift and go to state 105

state 150

    (67) parametro -> dataType ID .
    (69) parametro -> dataType ID . EQUALS valor

    COMMA           reduce using rule 67 (parametro -> dataType ID .)
    RPAREN          reduce using rule 67 (parametro -> dataType ID .)
    EQUALS          shift and go to state 175


state 151

    (59) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN . LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN . DOUBLEDOT dataType LBRACE funcionBody RBRACE

    LBRACE          shift and go to state 176
    DOUBLEDOT       shift and go to state 177


state 152

    (73) classDeclarate -> CLASS ID LBRACE classBody RBRACE .

    VARIABLE        reduce using rule 73 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    ECHO            reduce using rule 73 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    PRINT           reduce using rule 73 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    INT             reduce using rule 73 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    FLOAT           reduce using rule 73 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    FUNCTION        reduce using rule 73 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    CLASS           reduce using rule 73 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    WHILE           reduce using rule 73 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    SWITCH          reduce using rule 73 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    IF              reduce using rule 73 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    FOR             reduce using rule 73 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    $end            reduce using rule 73 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    RBRACE          reduce using rule 73 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    BREAK           reduce using rule 73 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)


state 153

    (75) classBody -> classMember classBody .

    RBRACE          reduce using rule 75 (classBody -> classMember classBody .)


state 154

    (77) classMember -> dataType VARIABLE . SEMICOLON

    SEMICOLON       shift and go to state 178


state 155

    (78) classMember -> dataType FUNCTION . ID LPAREN parametros RPAREN brace

    ID              shift and go to state 179


state 156

    (74) classDeclarate -> CLASS ID EXTENDS ID LBRACE . classBody RBRACE
    (75) classBody -> . classMember classBody
    (76) classBody -> . empty
    (77) classMember -> . dataType VARIABLE SEMICOLON
    (78) classMember -> . dataType FUNCTION ID LPAREN parametros RPAREN brace
    (127) empty -> .
    (102) dataType -> . INTEGER
    (103) dataType -> . FLOATING
    (104) dataType -> . STRINGS
    (105) dataType -> . BOOLEAN
    (106) dataType -> . VOID

    RBRACE          reduce using rule 127 (empty -> .)
    INTEGER         shift and go to state 106
    FLOATING        shift and go to state 107
    STRINGS         shift and go to state 108
    BOOLEAN         shift and go to state 109
    VOID            shift and go to state 110

    classBody                      shift and go to state 180
    classMember                    shift and go to state 113
    empty                          shift and go to state 114
    dataType                       shift and go to state 115

state 157

    (8) sentencias -> sentencia sentencias .

    VARIABLE        reduce using rule 8 (sentencias -> sentencia sentencias .)
    ECHO            reduce using rule 8 (sentencias -> sentencia sentencias .)
    PRINT           reduce using rule 8 (sentencias -> sentencia sentencias .)
    INT             reduce using rule 8 (sentencias -> sentencia sentencias .)
    FLOAT           reduce using rule 8 (sentencias -> sentencia sentencias .)
    FUNCTION        reduce using rule 8 (sentencias -> sentencia sentencias .)
    CLASS           reduce using rule 8 (sentencias -> sentencia sentencias .)
    WHILE           reduce using rule 8 (sentencias -> sentencia sentencias .)
    SWITCH          reduce using rule 8 (sentencias -> sentencia sentencias .)
    IF              reduce using rule 8 (sentencias -> sentencia sentencias .)
    FOR             reduce using rule 8 (sentencias -> sentencia sentencias .)
    $end            reduce using rule 8 (sentencias -> sentencia sentencias .)
    RBRACE          reduce using rule 8 (sentencias -> sentencia sentencias .)
    BREAK           reduce using rule 8 (sentencias -> sentencia sentencias .)


state 158

    (29) condition -> LPAREN conditionProdu RPAREN .

    RPAREN          reduce using rule 29 (condition -> LPAREN conditionProdu RPAREN .)
    AND             reduce using rule 29 (condition -> LPAREN conditionProdu RPAREN .)
    OR              reduce using rule 29 (condition -> LPAREN conditionProdu RPAREN .)
    NOT             reduce using rule 29 (condition -> LPAREN conditionProdu RPAREN .)
    QUESTION        reduce using rule 29 (condition -> LPAREN conditionProdu RPAREN .)
    SEMICOLON       reduce using rule 29 (condition -> LPAREN conditionProdu RPAREN .)
    COLON           reduce using rule 29 (condition -> LPAREN conditionProdu RPAREN .)


state 159

    (45) while -> WHILE LPAREN condition RPAREN LBRACE . body RBRACE
    (46) while -> WHILE LPAREN condition RPAREN LBRACE . RBRACE
    (88) body -> . sentencia
    (89) body -> . sentencia sentencias
    (90) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (127) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (107) comparacion -> . INT operador INT
    (108) comparacion -> . FLOAT operador FLOAT
    (109) comparacion -> . INT operador FLOAT
    (110) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (73) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (74) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (81) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
    RBRACE          shift and go to state 182
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

  ! RBRACE          [ reduce using rule 127 (empty -> .) ]

    body                           shift and go to state 181
    sentencia                      shift and go to state 80
    empty                          shift and go to state 81
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 160

    (28) condition -> valor opSymbol valor .

    RPAREN          reduce using rule 28 (condition -> valor opSymbol valor .)
    AND             reduce using rule 28 (condition -> valor opSymbol valor .)
    OR              reduce using rule 28 (condition -> valor opSymbol valor .)
    NOT             reduce using rule 28 (condition -> valor opSymbol valor .)
    QUESTION        reduce using rule 28 (condition -> valor opSymbol valor .)
    SEMICOLON       reduce using rule 28 (condition -> valor opSymbol valor .)
    COLON           reduce using rule 28 (condition -> valor opSymbol valor .)


state 161

    (47) switch -> SWITCH LPAREN condition RPAREN LBRACE . caseLists RBRACE
    (48) switch -> SWITCH LPAREN condition RPAREN LBRACE . RBRACE
    (49) caseLists -> . cases default
    (50) caseLists -> . cases
    (51) caseLists -> . default
    (52) caseLists -> . empty
    (53) cases -> . case cases
    (54) cases -> . case
    (56) default -> . DEFAULT COLON body BREAK SEMICOLON
    (127) empty -> .
    (55) case -> . CASE valor COLON body BREAK SEMICOLON

  ! shift/reduce conflict for RBRACE resolved as shift
    RBRACE          shift and go to state 184
    DEFAULT         shift and go to state 189
    CASE            shift and go to state 190

  ! RBRACE          [ reduce using rule 127 (empty -> .) ]

    caseLists                      shift and go to state 183
    cases                          shift and go to state 185
    default                        shift and go to state 186
    empty                          shift and go to state 187
    case                           shift and go to state 188

state 162

    (25) statementif -> IF LPAREN conditionProdu RPAREN LBRACE . body RBRACE
    (88) body -> . sentencia
    (89) body -> . sentencia sentencias
    (90) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (127) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (107) comparacion -> . INT operador INT
    (108) comparacion -> . FLOAT operador FLOAT
    (109) comparacion -> . INT operador FLOAT
    (110) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (73) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (74) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (81) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    RBRACE          reduce using rule 127 (empty -> .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    body                           shift and go to state 191
    sentencia                      shift and go to state 80
    empty                          shift and go to state 81
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 163

    (27) conditionProdu -> condition opLogic conditionProdu .

    RPAREN          reduce using rule 27 (conditionProdu -> condition opLogic conditionProdu .)
    QUESTION        reduce using rule 27 (conditionProdu -> condition opLogic conditionProdu .)
    SEMICOLON       reduce using rule 27 (conditionProdu -> condition opLogic conditionProdu .)
    COLON           reduce using rule 27 (conditionProdu -> condition opLogic conditionProdu .)


state 164

    (42) forStatement -> FOR LPAREN forcondition RPAREN LBRACE . body RBRACE
    (88) body -> . sentencia
    (89) body -> . sentencia sentencias
    (90) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (127) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (107) comparacion -> . INT operador INT
    (108) comparacion -> . FLOAT operador FLOAT
    (109) comparacion -> . INT operador FLOAT
    (110) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (73) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (74) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (81) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    RBRACE          reduce using rule 127 (empty -> .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    body                           shift and go to state 192
    sentencia                      shift and go to state 80
    empty                          shift and go to state 81
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 165

    (43) forcondition -> VARIABLE EQUALS INT . SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS INT . SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    SEMICOLON       shift and go to state 193


state 166

    (81) array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .

    VARIABLE        reduce using rule 81 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    ECHO            reduce using rule 81 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    PRINT           reduce using rule 81 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    INT             reduce using rule 81 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 81 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    FUNCTION        reduce using rule 81 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    CLASS           reduce using rule 81 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    WHILE           reduce using rule 81 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    SWITCH          reduce using rule 81 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    IF              reduce using rule 81 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    FOR             reduce using rule 81 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    $end            reduce using rule 81 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 81 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    BREAK           reduce using rule 81 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)


state 167

    (83) map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .

    VARIABLE        reduce using rule 83 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    ECHO            reduce using rule 83 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    PRINT           reduce using rule 83 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    INT             reduce using rule 83 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 83 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    FUNCTION        reduce using rule 83 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    CLASS           reduce using rule 83 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    WHILE           reduce using rule 83 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    SWITCH          reduce using rule 83 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    IF              reduce using rule 83 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    FOR             reduce using rule 83 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    $end            reduce using rule 83 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 83 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    BREAK           reduce using rule 83 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)


state 168

    (87) mapArrow -> valor ARROWMAP valor .

    COMMA           reduce using rule 87 (mapArrow -> valor ARROWMAP valor .)
    RBRACKET        reduce using rule 87 (mapArrow -> valor ARROWMAP valor .)
    RPAREN          reduce using rule 87 (mapArrow -> valor ARROWMAP valor .)


state 169

    (86) mapProduc -> mapArrow COMMA mapProduc .

    RBRACKET        reduce using rule 86 (mapProduc -> mapArrow COMMA mapProduc .)
    RPAREN          reduce using rule 86 (mapProduc -> mapArrow COMMA mapProduc .)


state 170

    (87) mapArrow -> valor . ARROWMAP valor

    ARROWMAP        shift and go to state 141


state 171

    (82) array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 194


state 172

    (84) map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 195


state 173

    (68) parametro -> ID EQUALS valor .

    COMMA           reduce using rule 68 (parametro -> ID EQUALS valor .)
    RPAREN          reduce using rule 68 (parametro -> ID EQUALS valor .)


state 174

    (64) parametros -> parametro COMMA parametros .

    RPAREN          reduce using rule 64 (parametros -> parametro COMMA parametros .)


state 175

    (69) parametro -> dataType ID EQUALS . valor
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    valor                          shift and go to state 196
    funcionParen                   shift and go to state 43

state 176

    (59) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE . funcionBody RBRACE
    (61) funcionBody -> . body
    (62) funcionBody -> . RETURN expresion SEMICOLON
    (88) body -> . sentencia
    (89) body -> . sentencia sentencias
    (90) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (127) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (107) comparacion -> . INT operador INT
    (108) comparacion -> . FLOAT operador FLOAT
    (109) comparacion -> . INT operador FLOAT
    (110) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (73) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (74) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (81) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    RETURN          shift and go to state 199
    RBRACE          reduce using rule 127 (empty -> .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    funcionBody                    shift and go to state 197
    body                           shift and go to state 198
    sentencia                      shift and go to state 80
    empty                          shift and go to state 81
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 177

    (60) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT . dataType LBRACE funcionBody RBRACE
    (102) dataType -> . INTEGER
    (103) dataType -> . FLOATING
    (104) dataType -> . STRINGS
    (105) dataType -> . BOOLEAN
    (106) dataType -> . VOID

    INTEGER         shift and go to state 106
    FLOATING        shift and go to state 107
    STRINGS         shift and go to state 108
    BOOLEAN         shift and go to state 109
    VOID            shift and go to state 110

    dataType                       shift and go to state 200

state 178

    (77) classMember -> dataType VARIABLE SEMICOLON .

    INTEGER         reduce using rule 77 (classMember -> dataType VARIABLE SEMICOLON .)
    FLOATING        reduce using rule 77 (classMember -> dataType VARIABLE SEMICOLON .)
    STRINGS         reduce using rule 77 (classMember -> dataType VARIABLE SEMICOLON .)
    BOOLEAN         reduce using rule 77 (classMember -> dataType VARIABLE SEMICOLON .)
    VOID            reduce using rule 77 (classMember -> dataType VARIABLE SEMICOLON .)
    RBRACE          reduce using rule 77 (classMember -> dataType VARIABLE SEMICOLON .)


state 179

    (78) classMember -> dataType FUNCTION ID . LPAREN parametros RPAREN brace

    LPAREN          shift and go to state 201


state 180

    (74) classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody . RBRACE

    RBRACE          shift and go to state 202


state 181

    (45) while -> WHILE LPAREN condition RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 203


state 182

    (46) while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .

    VARIABLE        reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    ECHO            reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    PRINT           reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    INT             reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    FLOAT           reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    FUNCTION        reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    CLASS           reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    WHILE           reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    SWITCH          reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    IF              reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    FOR             reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    $end            reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    RBRACE          reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    BREAK           reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)


state 183

    (47) switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists . RBRACE

    RBRACE          shift and go to state 204


state 184

    (48) switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .

    VARIABLE        reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    ECHO            reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    PRINT           reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    INT             reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    FLOAT           reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    FUNCTION        reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    CLASS           reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    WHILE           reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    SWITCH          reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    IF              reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    FOR             reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    $end            reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    RBRACE          reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    BREAK           reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)


state 185

    (49) caseLists -> cases . default
    (50) caseLists -> cases .
    (56) default -> . DEFAULT COLON body BREAK SEMICOLON

    RBRACE          reduce using rule 50 (caseLists -> cases .)
    DEFAULT         shift and go to state 189

    default                        shift and go to state 205

state 186

    (51) caseLists -> default .

    RBRACE          reduce using rule 51 (caseLists -> default .)


state 187

    (52) caseLists -> empty .

    RBRACE          reduce using rule 52 (caseLists -> empty .)


state 188

    (53) cases -> case . cases
    (54) cases -> case .
    (53) cases -> . case cases
    (54) cases -> . case
    (55) case -> . CASE valor COLON body BREAK SEMICOLON

    DEFAULT         reduce using rule 54 (cases -> case .)
    RBRACE          reduce using rule 54 (cases -> case .)
    CASE            shift and go to state 190

    case                           shift and go to state 188
    cases                          shift and go to state 206

state 189

    (56) default -> DEFAULT . COLON body BREAK SEMICOLON

    COLON           shift and go to state 207


state 190

    (55) case -> CASE . valor COLON body BREAK SEMICOLON
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44

    valor                          shift and go to state 208
    funcionParen                   shift and go to state 43

state 191

    (25) statementif -> IF LPAREN conditionProdu RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 209


state 192

    (42) forStatement -> FOR LPAREN forcondition RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 210


state 193

    (43) forcondition -> VARIABLE EQUALS INT SEMICOLON . VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS INT SEMICOLON . VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    VARIABLE        shift and go to state 211


state 194

    (82) array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .

    VARIABLE        reduce using rule 82 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    ECHO            reduce using rule 82 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    PRINT           reduce using rule 82 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    INT             reduce using rule 82 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    FLOAT           reduce using rule 82 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 82 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    CLASS           reduce using rule 82 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    WHILE           reduce using rule 82 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    SWITCH          reduce using rule 82 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    IF              reduce using rule 82 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    FOR             reduce using rule 82 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    $end            reduce using rule 82 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    RBRACE          reduce using rule 82 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    BREAK           reduce using rule 82 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)


state 195

    (84) map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .

    VARIABLE        reduce using rule 84 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    ECHO            reduce using rule 84 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    PRINT           reduce using rule 84 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    INT             reduce using rule 84 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    FLOAT           reduce using rule 84 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 84 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    CLASS           reduce using rule 84 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    WHILE           reduce using rule 84 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    SWITCH          reduce using rule 84 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    IF              reduce using rule 84 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    FOR             reduce using rule 84 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    $end            reduce using rule 84 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    RBRACE          reduce using rule 84 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    BREAK           reduce using rule 84 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)


state 196

    (69) parametro -> dataType ID EQUALS valor .

    COMMA           reduce using rule 69 (parametro -> dataType ID EQUALS valor .)
    RPAREN          reduce using rule 69 (parametro -> dataType ID EQUALS valor .)


state 197

    (59) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody . RBRACE

    RBRACE          shift and go to state 212


state 198

    (61) funcionBody -> body .

    RBRACE          reduce using rule 61 (funcionBody -> body .)


state 199

    (62) funcionBody -> RETURN . expresion SEMICOLON
    (116) expresion -> . valor
    (117) expresion -> . operaArit
    (118) expresion -> . conditionProdu
    (119) expresion -> . ternario
    (120) expresion -> . accessMember
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (113) operaArit -> . valor
    (114) operaArit -> . valor operador operaArit
    (115) operaArit -> . valor DOT valor
    (26) conditionProdu -> . condition
    (27) conditionProdu -> . condition opLogic conditionProdu
    (126) ternario -> . conditionProdu QUESTION expresion COLON expresion
    (79) accessMember -> . VARIABLE ARROW ID
    (80) accessMember -> . VARIABLE ARROW funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 219
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44
    LPAREN          shift and go to state 83

    expresion                      shift and go to state 213
    valor                          shift and go to state 214
    operaArit                      shift and go to state 215
    conditionProdu                 shift and go to state 216
    ternario                       shift and go to state 217
    accessMember                   shift and go to state 218
    funcionParen                   shift and go to state 43
    condition                      shift and go to state 88

state 200

    (60) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType . LBRACE funcionBody RBRACE

    LBRACE          shift and go to state 220


state 201

    (78) classMember -> dataType FUNCTION ID LPAREN . parametros RPAREN brace
    (63) parametros -> . parametro
    (64) parametros -> . parametro COMMA parametros
    (65) parametros -> . empty
    (66) parametro -> . ID
    (67) parametro -> . dataType ID
    (68) parametro -> . ID EQUALS valor
    (69) parametro -> . dataType ID EQUALS valor
    (127) empty -> .
    (102) dataType -> . INTEGER
    (103) dataType -> . FLOATING
    (104) dataType -> . STRINGS
    (105) dataType -> . BOOLEAN
    (106) dataType -> . VOID

    ID              shift and go to state 101
    RPAREN          reduce using rule 127 (empty -> .)
    INTEGER         shift and go to state 106
    FLOATING        shift and go to state 107
    STRINGS         shift and go to state 108
    BOOLEAN         shift and go to state 109
    VOID            shift and go to state 110

    dataType                       shift and go to state 105
    parametros                     shift and go to state 221
    parametro                      shift and go to state 103
    empty                          shift and go to state 104

state 202

    (74) classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .

    VARIABLE        reduce using rule 74 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    ECHO            reduce using rule 74 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    PRINT           reduce using rule 74 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    INT             reduce using rule 74 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    FLOAT           reduce using rule 74 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    FUNCTION        reduce using rule 74 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    CLASS           reduce using rule 74 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    WHILE           reduce using rule 74 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    SWITCH          reduce using rule 74 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    IF              reduce using rule 74 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    FOR             reduce using rule 74 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    $end            reduce using rule 74 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    RBRACE          reduce using rule 74 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    BREAK           reduce using rule 74 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)


state 203

    (45) while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .

    VARIABLE        reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    ECHO            reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    FLOAT           reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    FUNCTION        reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    CLASS           reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    SWITCH          reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    BREAK           reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)


state 204

    (47) switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .

    VARIABLE        reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    ECHO            reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    PRINT           reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    INT             reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    FLOAT           reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    FUNCTION        reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    CLASS           reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    WHILE           reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    SWITCH          reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    IF              reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    FOR             reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    $end            reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    RBRACE          reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    BREAK           reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)


state 205

    (49) caseLists -> cases default .

    RBRACE          reduce using rule 49 (caseLists -> cases default .)


state 206

    (53) cases -> case cases .

    DEFAULT         reduce using rule 53 (cases -> case cases .)
    RBRACE          reduce using rule 53 (cases -> case cases .)


state 207

    (56) default -> DEFAULT COLON . body BREAK SEMICOLON
    (88) body -> . sentencia
    (89) body -> . sentencia sentencias
    (90) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (127) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (107) comparacion -> . INT operador INT
    (108) comparacion -> . FLOAT operador FLOAT
    (109) comparacion -> . INT operador FLOAT
    (110) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (73) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (74) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (81) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    BREAK           reduce using rule 127 (empty -> .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    body                           shift and go to state 222
    sentencia                      shift and go to state 80
    empty                          shift and go to state 81
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 208

    (55) case -> CASE valor . COLON body BREAK SEMICOLON

    COLON           shift and go to state 223


state 209

    (25) statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .

    ELSE            reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    ELSEIF          reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    VARIABLE        reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    ECHO            reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    FLOAT           reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    FUNCTION        reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    CLASS           reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    SWITCH          reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    BREAK           reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)


state 210

    (42) forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .

    VARIABLE        reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    ECHO            reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    FLOAT           reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    FUNCTION        reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    CLASS           reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    SWITCH          reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    BREAK           reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)


state 211

    (43) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE . opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE . opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS
    (30) opSymbol -> . EQ
    (31) opSymbol -> . NEQ
    (32) opSymbol -> . STRICTEQ
    (33) opSymbol -> . STRICTNEQ
    (34) opSymbol -> . LT
    (35) opSymbol -> . GT
    (36) opSymbol -> . LEQ
    (37) opSymbol -> . GEQ

    EQ              shift and go to state 123
    NEQ             shift and go to state 124
    STRICTEQ        shift and go to state 125
    STRICTNEQ       shift and go to state 126
    LT              shift and go to state 127
    GT              shift and go to state 128
    LEQ             shift and go to state 129
    GEQ             shift and go to state 130

    opSymbol                       shift and go to state 224

state 212

    (59) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .

    VARIABLE        reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    ECHO            reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    PRINT           reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    INT             reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    FLOAT           reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    FUNCTION        reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    CLASS           reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    WHILE           reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    SWITCH          reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    IF              reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    FOR             reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    $end            reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    RBRACE          reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    BREAK           reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)


state 213

    (62) funcionBody -> RETURN expresion . SEMICOLON

    SEMICOLON       shift and go to state 225


state 214

    (116) expresion -> valor .
    (113) operaArit -> valor .
    (114) operaArit -> valor . operador operaArit
    (115) operaArit -> valor . DOT valor
    (28) condition -> valor . opSymbol valor
    (121) operador -> . PLUS
    (122) operador -> . MINUS
    (123) operador -> . TIMES
    (124) operador -> . DIVIDE
    (125) operador -> . MODULO
    (30) opSymbol -> . EQ
    (31) opSymbol -> . NEQ
    (32) opSymbol -> . STRICTEQ
    (33) opSymbol -> . STRICTNEQ
    (34) opSymbol -> . LT
    (35) opSymbol -> . GT
    (36) opSymbol -> . LEQ
    (37) opSymbol -> . GEQ

  ! reduce/reduce conflict for SEMICOLON resolved using rule 113 (operaArit -> valor .)
  ! reduce/reduce conflict for COLON resolved using rule 113 (operaArit -> valor .)
    SEMICOLON       reduce using rule 113 (operaArit -> valor .)
    COLON           reduce using rule 113 (operaArit -> valor .)
    DOT             shift and go to state 98
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50
    MODULO          shift and go to state 51
    EQ              shift and go to state 123
    NEQ             shift and go to state 124
    STRICTEQ        shift and go to state 125
    STRICTNEQ       shift and go to state 126
    LT              shift and go to state 127
    GT              shift and go to state 128
    LEQ             shift and go to state 129
    GEQ             shift and go to state 130

  ! SEMICOLON       [ reduce using rule 116 (expresion -> valor .) ]
  ! COLON           [ reduce using rule 116 (expresion -> valor .) ]

    operador                       shift and go to state 97
    opSymbol                       shift and go to state 122

state 215

    (117) expresion -> operaArit .

    SEMICOLON       reduce using rule 117 (expresion -> operaArit .)
    COLON           reduce using rule 117 (expresion -> operaArit .)


state 216

    (118) expresion -> conditionProdu .
    (126) ternario -> conditionProdu . QUESTION expresion COLON expresion

    SEMICOLON       reduce using rule 118 (expresion -> conditionProdu .)
    COLON           reduce using rule 118 (expresion -> conditionProdu .)
    QUESTION        shift and go to state 226


state 217

    (119) expresion -> ternario .

    SEMICOLON       reduce using rule 119 (expresion -> ternario .)
    COLON           reduce using rule 119 (expresion -> ternario .)


state 218

    (120) expresion -> accessMember .

    SEMICOLON       reduce using rule 120 (expresion -> accessMember .)
    COLON           reduce using rule 120 (expresion -> accessMember .)


state 219

    (96) valor -> VARIABLE .
    (79) accessMember -> VARIABLE . ARROW ID
    (80) accessMember -> VARIABLE . ARROW funcionParen

    DOT             reduce using rule 96 (valor -> VARIABLE .)
    PLUS            reduce using rule 96 (valor -> VARIABLE .)
    MINUS           reduce using rule 96 (valor -> VARIABLE .)
    TIMES           reduce using rule 96 (valor -> VARIABLE .)
    DIVIDE          reduce using rule 96 (valor -> VARIABLE .)
    MODULO          reduce using rule 96 (valor -> VARIABLE .)
    EQ              reduce using rule 96 (valor -> VARIABLE .)
    NEQ             reduce using rule 96 (valor -> VARIABLE .)
    STRICTEQ        reduce using rule 96 (valor -> VARIABLE .)
    STRICTNEQ       reduce using rule 96 (valor -> VARIABLE .)
    LT              reduce using rule 96 (valor -> VARIABLE .)
    GT              reduce using rule 96 (valor -> VARIABLE .)
    LEQ             reduce using rule 96 (valor -> VARIABLE .)
    GEQ             reduce using rule 96 (valor -> VARIABLE .)
    SEMICOLON       reduce using rule 96 (valor -> VARIABLE .)
    COLON           reduce using rule 96 (valor -> VARIABLE .)
    ARROW           shift and go to state 227


state 220

    (60) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE . funcionBody RBRACE
    (61) funcionBody -> . body
    (62) funcionBody -> . RETURN expresion SEMICOLON
    (88) body -> . sentencia
    (89) body -> . sentencia sentencias
    (90) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (127) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (107) comparacion -> . INT operador INT
    (108) comparacion -> . FLOAT operador FLOAT
    (109) comparacion -> . INT operador FLOAT
    (110) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (73) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (74) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (81) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    RETURN          shift and go to state 199
    RBRACE          reduce using rule 127 (empty -> .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    funcionBody                    shift and go to state 228
    body                           shift and go to state 198
    sentencia                      shift and go to state 80
    empty                          shift and go to state 81
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 221

    (78) classMember -> dataType FUNCTION ID LPAREN parametros . RPAREN brace

    RPAREN          shift and go to state 229


state 222

    (56) default -> DEFAULT COLON body . BREAK SEMICOLON

    BREAK           shift and go to state 230


state 223

    (55) case -> CASE valor COLON . body BREAK SEMICOLON
    (88) body -> . sentencia
    (89) body -> . sentencia sentencias
    (90) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (127) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (107) comparacion -> . INT operador INT
    (108) comparacion -> . FLOAT operador FLOAT
    (109) comparacion -> . INT operador FLOAT
    (110) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (73) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (74) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (81) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    BREAK           reduce using rule 127 (empty -> .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    body                           shift and go to state 231
    sentencia                      shift and go to state 80
    empty                          shift and go to state 81
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 224

    (43) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol . INT SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol . INT SEMICOLON VARIABLE DOUBLEMINUS

    INT             shift and go to state 232


state 225

    (62) funcionBody -> RETURN expresion SEMICOLON .

    RBRACE          reduce using rule 62 (funcionBody -> RETURN expresion SEMICOLON .)


state 226

    (126) ternario -> conditionProdu QUESTION . expresion COLON expresion
    (116) expresion -> . valor
    (117) expresion -> . operaArit
    (118) expresion -> . conditionProdu
    (119) expresion -> . ternario
    (120) expresion -> . accessMember
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (113) operaArit -> . valor
    (114) operaArit -> . valor operador operaArit
    (115) operaArit -> . valor DOT valor
    (26) conditionProdu -> . condition
    (27) conditionProdu -> . condition opLogic conditionProdu
    (126) ternario -> . conditionProdu QUESTION expresion COLON expresion
    (79) accessMember -> . VARIABLE ARROW ID
    (80) accessMember -> . VARIABLE ARROW funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 219
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44
    LPAREN          shift and go to state 83

    conditionProdu                 shift and go to state 216
    expresion                      shift and go to state 233
    valor                          shift and go to state 214
    operaArit                      shift and go to state 215
    ternario                       shift and go to state 217
    accessMember                   shift and go to state 218
    funcionParen                   shift and go to state 43
    condition                      shift and go to state 88

state 227

    (79) accessMember -> VARIABLE ARROW . ID
    (80) accessMember -> VARIABLE ARROW . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    ID              shift and go to state 234

    funcionParen                   shift and go to state 235

state 228

    (60) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody . RBRACE

    RBRACE          shift and go to state 236


state 229

    (78) classMember -> dataType FUNCTION ID LPAREN parametros RPAREN . brace
    (71) brace -> . LBRACE body RBRACE

    LBRACE          shift and go to state 238

    brace                          shift and go to state 237

state 230

    (56) default -> DEFAULT COLON body BREAK . SEMICOLON

    SEMICOLON       shift and go to state 239


state 231

    (55) case -> CASE valor COLON body . BREAK SEMICOLON

    BREAK           shift and go to state 240


state 232

    (43) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT . SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT . SEMICOLON VARIABLE DOUBLEMINUS

    SEMICOLON       shift and go to state 241


state 233

    (126) ternario -> conditionProdu QUESTION expresion . COLON expresion

    COLON           shift and go to state 242


state 234

    (79) accessMember -> VARIABLE ARROW ID .
    (72) funcionParen -> ID . LPAREN parametros RPAREN

    SEMICOLON       reduce using rule 79 (accessMember -> VARIABLE ARROW ID .)
    COLON           reduce using rule 79 (accessMember -> VARIABLE ARROW ID .)
    LPAREN          shift and go to state 69


state 235

    (80) accessMember -> VARIABLE ARROW funcionParen .

    SEMICOLON       reduce using rule 80 (accessMember -> VARIABLE ARROW funcionParen .)
    COLON           reduce using rule 80 (accessMember -> VARIABLE ARROW funcionParen .)


state 236

    (60) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .

    VARIABLE        reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    ECHO            reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    PRINT           reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    INT             reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    FLOAT           reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    FUNCTION        reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    CLASS           reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    WHILE           reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    SWITCH          reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    IF              reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    FOR             reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    $end            reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    RBRACE          reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    BREAK           reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)


state 237

    (78) classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .

    INTEGER         reduce using rule 78 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    FLOATING        reduce using rule 78 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    STRINGS         reduce using rule 78 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    BOOLEAN         reduce using rule 78 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    VOID            reduce using rule 78 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    RBRACE          reduce using rule 78 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)


state 238

    (71) brace -> LBRACE . body RBRACE
    (88) body -> . sentencia
    (89) body -> . sentencia sentencias
    (90) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (127) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (107) comparacion -> . INT operador INT
    (108) comparacion -> . FLOAT operador FLOAT
    (109) comparacion -> . INT operador FLOAT
    (110) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (73) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (74) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (81) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (82) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (83) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (84) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    RBRACE          reduce using rule 127 (empty -> .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    body                           shift and go to state 243
    sentencia                      shift and go to state 80
    empty                          shift and go to state 81
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 239

    (56) default -> DEFAULT COLON body BREAK SEMICOLON .

    RBRACE          reduce using rule 56 (default -> DEFAULT COLON body BREAK SEMICOLON .)


state 240

    (55) case -> CASE valor COLON body BREAK . SEMICOLON

    SEMICOLON       shift and go to state 244


state 241

    (43) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON . VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON . VARIABLE DOUBLEMINUS

    VARIABLE        shift and go to state 245


state 242

    (126) ternario -> conditionProdu QUESTION expresion COLON . expresion
    (116) expresion -> . valor
    (117) expresion -> . operaArit
    (118) expresion -> . conditionProdu
    (119) expresion -> . ternario
    (120) expresion -> . accessMember
    (94) valor -> . INT
    (95) valor -> . FLOAT
    (96) valor -> . VARIABLE
    (97) valor -> . STRING
    (98) valor -> . TRUE
    (99) valor -> . FALSE
    (100) valor -> . THIS
    (101) valor -> . funcionParen
    (113) operaArit -> . valor
    (114) operaArit -> . valor operador operaArit
    (115) operaArit -> . valor DOT valor
    (26) conditionProdu -> . condition
    (27) conditionProdu -> . condition opLogic conditionProdu
    (126) ternario -> . conditionProdu QUESTION expresion COLON expresion
    (79) accessMember -> . VARIABLE ARROW ID
    (80) accessMember -> . VARIABLE ARROW funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 219
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 44
    LPAREN          shift and go to state 83

    conditionProdu                 shift and go to state 216
    expresion                      shift and go to state 246
    valor                          shift and go to state 214
    operaArit                      shift and go to state 215
    ternario                       shift and go to state 217
    accessMember                   shift and go to state 218
    funcionParen                   shift and go to state 43
    condition                      shift and go to state 88

state 243

    (71) brace -> LBRACE body . RBRACE

    RBRACE          shift and go to state 247


state 244

    (55) case -> CASE valor COLON body BREAK SEMICOLON .

    CASE            reduce using rule 55 (case -> CASE valor COLON body BREAK SEMICOLON .)
    DEFAULT         reduce using rule 55 (case -> CASE valor COLON body BREAK SEMICOLON .)
    RBRACE          reduce using rule 55 (case -> CASE valor COLON body BREAK SEMICOLON .)


state 245

    (43) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE . DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE . DOUBLEMINUS

    DOUBLEPLUS      shift and go to state 248
    DOUBLEMINUS     shift and go to state 249


state 246

    (126) ternario -> conditionProdu QUESTION expresion COLON expresion .

    SEMICOLON       reduce using rule 126 (ternario -> conditionProdu QUESTION expresion COLON expresion .)
    COLON           reduce using rule 126 (ternario -> conditionProdu QUESTION expresion COLON expresion .)


state 247

    (71) brace -> LBRACE body RBRACE .

    INTEGER         reduce using rule 71 (brace -> LBRACE body RBRACE .)
    FLOATING        reduce using rule 71 (brace -> LBRACE body RBRACE .)
    STRINGS         reduce using rule 71 (brace -> LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 71 (brace -> LBRACE body RBRACE .)
    VOID            reduce using rule 71 (brace -> LBRACE body RBRACE .)
    RBRACE          reduce using rule 71 (brace -> LBRACE body RBRACE .)


state 248

    (43) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS .

    RPAREN          reduce using rule 43 (forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS .)


state 249

    (44) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS .

    RPAREN          reduce using rule 44 (forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 55 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 55 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 55 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 55 resolved as shift
WARNING: shift/reduce conflict for INT in state 55 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 55 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 55 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 55 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 55 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 55 resolved as shift
WARNING: shift/reduce conflict for FOR in state 55 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 80 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 80 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 80 resolved as shift
WARNING: shift/reduce conflict for INT in state 80 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 80 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 80 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 80 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 80 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 80 resolved as shift
WARNING: shift/reduce conflict for IF in state 80 resolved as shift
WARNING: shift/reduce conflict for FOR in state 80 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 117 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 117 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 117 resolved as shift
WARNING: shift/reduce conflict for INT in state 117 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 117 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 117 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 117 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 117 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 117 resolved as shift
WARNING: shift/reduce conflict for IF in state 117 resolved as shift
WARNING: shift/reduce conflict for FOR in state 117 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 159 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 161 resolved as shift
WARNING: reduce/reduce conflict in state 79 resolved using rule (controlStructure -> if)
WARNING: rejected rule (if -> statementif ELSE if) in state 79
WARNING: reduce/reduce conflict in state 80 resolved using rule (body -> sentencia)
WARNING: rejected rule (empty -> <empty>) in state 80
WARNING: reduce/reduce conflict in state 117 resolved using rule (sentencias -> sentencia)
WARNING: rejected rule (empty -> <empty>) in state 117
WARNING: reduce/reduce conflict in state 214 resolved using rule (operaArit -> valor)
WARNING: rejected rule (expresion -> valor) in state 214
WARNING: Rule (if -> statementif ELSE if) is never reduced
WARNING: Rule (expresion -> valor) is never reduced
