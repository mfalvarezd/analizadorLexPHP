Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    BOOL
    CATCH
    CLONE
    CLOSETAG
    CONCATENATEEQUAL
    CONST
    CONTINUE
    DECLARE
    DO
    EMPTY
    ENDSWITCH
    EXCEPTION
    FGETS
    FINAL
    FINALLY
    FOREACH
    GLOBAL
    IMPLEMENTS
    INCLUDE
    INSTANCEOF
    INTERFACE
    ISSET
    LIST
    MINUSEQUAL
    NAMESPACE
    NEW
    OPENTAG
    PLUSEQUAL
    POTENCIA
    PRIVATE
    PROTECTED
    PUBLIC
    STATIC
    STDIN
    THROW
    TRY

Grammar

Rule 0     S' -> programa
Rule 1     programa -> sentencia
Rule 2     programa -> sentencia programa
Rule 3     sentencia -> asignacion
Rule 4     sentencia -> impresion
Rule 5     sentencia -> comparacion
Rule 6     sentencia -> estructurasProgram
Rule 7     sentencias -> sentencia
Rule 8     sentencias -> sentencia sentencias
Rule 9     sentencias -> empty
Rule 10    asignacion -> VARIABLE EQUALS operaArit SEMICOLON
Rule 11    impresion -> ECHO imprimir SEMICOLON
Rule 12    impresion -> PRINT imprimir SEMICOLON
Rule 13    estructurasProgram -> controlStructure
Rule 14    estructurasProgram -> dataStructure
Rule 15    estructurasProgram -> funcionDeclarate
Rule 16    estructurasProgram -> classDeclarate
Rule 17    controlStructure -> if
Rule 18    controlStructure -> for
Rule 19    controlStructure -> while
Rule 20    controlStructure -> switch
Rule 21    if -> statementif ELSE body
Rule 22    if -> statementif ELSE if
Rule 23    if -> statementif ELSEIF if
Rule 24    if -> statementif
Rule 25    statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
Rule 26    conditionProdu -> condition
Rule 27    conditionProdu -> condition opLogic conditionProdu
Rule 28    condition -> valor opSymbol valor
Rule 29    condition -> LPAREN conditionProdu RPAREN
Rule 30    opSymbol -> EQ
Rule 31    opSymbol -> NEQ
Rule 32    opSymbol -> STRICTEQ
Rule 33    opSymbol -> STRICTNEQ
Rule 34    opSymbol -> LT
Rule 35    opSymbol -> GT
Rule 36    opSymbol -> LEQ
Rule 37    opSymbol -> GEQ
Rule 38    opLogic -> AND
Rule 39    opLogic -> OR
Rule 40    opLogic -> NOT
Rule 41    for -> forStatement
Rule 42    forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE
Rule 43    forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
Rule 44    forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS
Rule 45    while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE
Rule 46    while -> WHILE LPAREN condition RPAREN LBRACE RBRACE
Rule 47    switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
Rule 48    switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE
Rule 49    caseLists -> cases default
Rule 50    caseLists -> cases
Rule 51    caseLists -> default
Rule 52    caseLists -> empty
Rule 53    cases -> case cases
Rule 54    cases -> case
Rule 55    case -> CASE valor COLON body BREAK SEMICOLON
Rule 56    default -> DEFAULT COLON body BREAK SEMICOLON
Rule 57    dataStructure -> array
Rule 58    dataStructure -> map
Rule 59    funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
Rule 60    funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
Rule 61    funcionBody -> body
Rule 62    funcionBody -> RETURN expresion SEMICOLON
Rule 63    parametros -> parametro
Rule 64    parametros -> parametro COMMA parametros
Rule 65    parametros -> empty
Rule 66    parametro -> ID
Rule 67    parametro -> dataType ID
Rule 68    parametro -> ID EQUALS valor
Rule 69    parametro -> dataType ID EQUALS valor
Rule 70    arrowfunction -> FN LPAREN parametros RPAREN ARROWMAP expresion SEMICOLON
Rule 71    brace -> LBRACE body RBRACE
Rule 72    funcionParen -> ID LPAREN parametros RPAREN
Rule 73    funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON
Rule 74    classDeclarate -> CLASS ID LBRACE classBody RBRACE
Rule 75    classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE
Rule 76    classBody -> classMember classBody
Rule 77    classBody -> empty
Rule 78    classMember -> dataType VARIABLE SEMICOLON
Rule 79    classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace
Rule 80    accessMember -> VARIABLE ARROW ID
Rule 81    accessMember -> VARIABLE ARROW funcionParen
Rule 82    array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
Rule 83    array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
Rule 84    array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
Rule 85    array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
Rule 86    map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
Rule 87    map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
Rule 88    mapProduc -> mapArrow
Rule 89    mapProduc -> mapArrow COMMA mapProduc
Rule 90    mapArrow -> valor ARROWMAP valor
Rule 91    body -> sentencia
Rule 92    body -> sentencia sentencias
Rule 93    body -> empty
Rule 94    imprimir -> LPAREN repiteValores RPAREN
Rule 95    imprimir -> LPAREN RPAREN
Rule 96    imprimir -> repiteValores
Rule 97    valor -> INT
Rule 98    valor -> FLOAT
Rule 99    valor -> VARIABLE
Rule 100   valor -> STRING
Rule 101   valor -> TRUE
Rule 102   valor -> FALSE
Rule 103   valor -> THIS
Rule 104   valor -> funcionParen
Rule 105   valor -> funcionAnonima
Rule 106   dataType -> INTEGER
Rule 107   dataType -> FLOATING
Rule 108   dataType -> STRINGS
Rule 109   dataType -> BOOLEAN
Rule 110   dataType -> VOID
Rule 111   comparacion -> INT operador INT
Rule 112   comparacion -> FLOAT operador FLOAT
Rule 113   comparacion -> INT operador FLOAT
Rule 114   comparacion -> FLOAT operador INT
Rule 115   repiteValores -> valor COMMA repiteValores
Rule 116   repiteValores -> valor
Rule 117   operaArit -> valor
Rule 118   operaArit -> valor operador operaArit
Rule 119   operaArit -> valor DOT valor
Rule 120   expresion -> valor
Rule 121   expresion -> operaArit
Rule 122   expresion -> conditionProdu
Rule 123   expresion -> ternario
Rule 124   expresion -> accessMember
Rule 125   operador -> PLUS
Rule 126   operador -> MINUS
Rule 127   operador -> TIMES
Rule 128   operador -> DIVIDE
Rule 129   operador -> MODULO
Rule 130   ternario -> conditionProdu QUESTION expresion COLON expresion
Rule 131   empty -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 38
ARRAY                : 83 84 87
ARROW                : 80 81
ARROWMAP             : 70 90
AS                   : 
BOOL                 : 
BOOLEAN              : 109
BREAK                : 55 56
CASE                 : 55
CATCH                : 
CLASS                : 74 75
CLONE                : 
CLOSETAG             : 
COLON                : 55 56 130
COMMA                : 64 89 115
CONCATENATEEQUAL     : 
CONST                : 
CONTINUE             : 
DECLARE              : 
DEFAULT              : 56
DIVIDE               : 128
DO                   : 
DOT                  : 119
DOUBLEDOT            : 60
DOUBLEMINUS          : 44
DOUBLEPLUS           : 43
ECHO                 : 11
ELSE                 : 21 22
ELSEIF               : 23
EMPTY                : 
ENDSWITCH            : 
EQ                   : 30
EQUALS               : 10 43 44 68 69 73 82 83 84 85 86 87
EXCEPTION            : 
EXTENDS              : 75
FALSE                : 102
FGETS                : 
FINAL                : 
FINALLY              : 
FLOAT                : 98 112 112 113 114
FLOATING             : 107
FN                   : 70
FOR                  : 42
FOREACH              : 
FUNCTION             : 59 60 73 79
GEQ                  : 37
GLOBAL               : 
GT                   : 35
ID                   : 59 60 66 67 68 69 72 74 75 75 79 80
IF                   : 25
IMPLEMENTS           : 
INCLUDE              : 
INSTANCEOF           : 
INT                  : 43 43 44 44 97 111 111 113 114
INTEGER              : 106
INTERFACE            : 
ISSET                : 
LBRACE               : 25 42 45 46 47 48 59 60 71 73 74 75
LBRACKET             : 82 85 86
LEQ                  : 36
LIST                 : 
LPAREN               : 25 29 42 45 46 47 48 59 60 70 72 73 79 83 84 87 94 95
LT                   : 34
MINUS                : 126
MINUSEQUAL           : 
MODULO               : 129
NAMESPACE            : 
NEQ                  : 31
NEW                  : 
NOT                  : 40
OPENTAG              : 
OR                   : 39
PLUS                 : 125
PLUSEQUAL            : 
POTENCIA             : 
PRINT                : 12
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
QUESTION             : 130
RBRACE               : 25 42 45 46 47 48 59 60 71 73 74 75
RBRACKET             : 82 85 86
RETURN               : 62 73
RPAREN               : 25 29 42 45 46 47 48 59 60 70 72 73 79 83 84 87 94 95
SEMICOLON            : 10 11 12 43 43 44 44 55 56 62 70 73 73 78 82 83 84 85 86 87
STATIC               : 
STDIN                : 
STRICTEQ             : 32
STRICTNEQ            : 33
STRING               : 100
STRINGS              : 108
SWITCH               : 47 48
THIS                 : 103
THROW                : 
TIMES                : 127
TRUE                 : 101
TRY                  : 
VARIABLE             : 10 43 43 43 44 44 44 73 78 80 81 82 83 84 85 86 87 99
VOID                 : 110
WHILE                : 45 46
error                : 

Nonterminals, with rules where they appear

accessMember         : 124
array                : 57
arrowfunction        : 
asignacion           : 3
body                 : 21 25 42 45 55 56 61 71
brace                : 79
case                 : 53 54
caseLists            : 47
cases                : 49 50 53
classBody            : 74 75 76
classDeclarate       : 16
classMember          : 76
comparacion          : 5
condition            : 26 27 45 46 47 48
conditionProdu       : 25 27 29 122 130
controlStructure     : 13
dataStructure        : 14
dataType             : 60 67 69 78 79
default              : 49 51
empty                : 9 52 65 77 93
estructurasProgram   : 6
expresion            : 62 70 73 130 130
for                  : 18
forStatement         : 41
forcondition         : 42
funcionAnonima       : 105
funcionBody          : 59 60
funcionDeclarate     : 15
funcionParen         : 81 104
if                   : 17 22 23
impresion            : 4
imprimir             : 11 12
map                  : 58
mapArrow             : 88 89
mapProduc            : 84 85 86 87 89
opLogic              : 27
opSymbol             : 28 43 44
operaArit            : 10 118 121
operador             : 111 112 113 114 118
parametro            : 63 64
parametros           : 59 60 64 70 72 73 79
programa             : 2 0
repiteValores        : 82 83 94 96 115
sentencia            : 1 2 7 8 91 92
sentencias           : 8 92
statementif          : 21 22 23 24
switch               : 20
ternario             : 123
valor                : 28 28 55 68 69 90 90 115 116 117 118 119 119 120
while                : 19

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . sentencia
    (2) programa -> . sentencia programa
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (111) comparacion -> . INT operador INT
    (112) comparacion -> . FLOAT operador FLOAT
    (113) comparacion -> . INT operador FLOAT
    (114) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (74) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (75) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (82) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    programa                       shift and go to state 1
    sentencia                      shift and go to state 2
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 1

    (0) S' -> programa .



state 2

    (1) programa -> sentencia .
    (2) programa -> sentencia . programa
    (1) programa -> . sentencia
    (2) programa -> . sentencia programa
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (111) comparacion -> . INT operador INT
    (112) comparacion -> . FLOAT operador FLOAT
    (113) comparacion -> . INT operador FLOAT
    (114) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (74) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (75) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (82) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    $end            reduce using rule 1 (programa -> sentencia .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    sentencia                      shift and go to state 2
    programa                       shift and go to state 30
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 3

    (3) sentencia -> asignacion .

    VARIABLE        reduce using rule 3 (sentencia -> asignacion .)
    ECHO            reduce using rule 3 (sentencia -> asignacion .)
    PRINT           reduce using rule 3 (sentencia -> asignacion .)
    INT             reduce using rule 3 (sentencia -> asignacion .)
    FLOAT           reduce using rule 3 (sentencia -> asignacion .)
    FUNCTION        reduce using rule 3 (sentencia -> asignacion .)
    CLASS           reduce using rule 3 (sentencia -> asignacion .)
    WHILE           reduce using rule 3 (sentencia -> asignacion .)
    SWITCH          reduce using rule 3 (sentencia -> asignacion .)
    IF              reduce using rule 3 (sentencia -> asignacion .)
    FOR             reduce using rule 3 (sentencia -> asignacion .)
    $end            reduce using rule 3 (sentencia -> asignacion .)
    RBRACE          reduce using rule 3 (sentencia -> asignacion .)
    BREAK           reduce using rule 3 (sentencia -> asignacion .)


state 4

    (4) sentencia -> impresion .

    VARIABLE        reduce using rule 4 (sentencia -> impresion .)
    ECHO            reduce using rule 4 (sentencia -> impresion .)
    PRINT           reduce using rule 4 (sentencia -> impresion .)
    INT             reduce using rule 4 (sentencia -> impresion .)
    FLOAT           reduce using rule 4 (sentencia -> impresion .)
    FUNCTION        reduce using rule 4 (sentencia -> impresion .)
    CLASS           reduce using rule 4 (sentencia -> impresion .)
    WHILE           reduce using rule 4 (sentencia -> impresion .)
    SWITCH          reduce using rule 4 (sentencia -> impresion .)
    IF              reduce using rule 4 (sentencia -> impresion .)
    FOR             reduce using rule 4 (sentencia -> impresion .)
    $end            reduce using rule 4 (sentencia -> impresion .)
    RBRACE          reduce using rule 4 (sentencia -> impresion .)
    BREAK           reduce using rule 4 (sentencia -> impresion .)


state 5

    (5) sentencia -> comparacion .

    VARIABLE        reduce using rule 5 (sentencia -> comparacion .)
    ECHO            reduce using rule 5 (sentencia -> comparacion .)
    PRINT           reduce using rule 5 (sentencia -> comparacion .)
    INT             reduce using rule 5 (sentencia -> comparacion .)
    FLOAT           reduce using rule 5 (sentencia -> comparacion .)
    FUNCTION        reduce using rule 5 (sentencia -> comparacion .)
    CLASS           reduce using rule 5 (sentencia -> comparacion .)
    WHILE           reduce using rule 5 (sentencia -> comparacion .)
    SWITCH          reduce using rule 5 (sentencia -> comparacion .)
    IF              reduce using rule 5 (sentencia -> comparacion .)
    FOR             reduce using rule 5 (sentencia -> comparacion .)
    $end            reduce using rule 5 (sentencia -> comparacion .)
    RBRACE          reduce using rule 5 (sentencia -> comparacion .)
    BREAK           reduce using rule 5 (sentencia -> comparacion .)


state 6

    (6) sentencia -> estructurasProgram .

    VARIABLE        reduce using rule 6 (sentencia -> estructurasProgram .)
    ECHO            reduce using rule 6 (sentencia -> estructurasProgram .)
    PRINT           reduce using rule 6 (sentencia -> estructurasProgram .)
    INT             reduce using rule 6 (sentencia -> estructurasProgram .)
    FLOAT           reduce using rule 6 (sentencia -> estructurasProgram .)
    FUNCTION        reduce using rule 6 (sentencia -> estructurasProgram .)
    CLASS           reduce using rule 6 (sentencia -> estructurasProgram .)
    WHILE           reduce using rule 6 (sentencia -> estructurasProgram .)
    SWITCH          reduce using rule 6 (sentencia -> estructurasProgram .)
    IF              reduce using rule 6 (sentencia -> estructurasProgram .)
    FOR             reduce using rule 6 (sentencia -> estructurasProgram .)
    $end            reduce using rule 6 (sentencia -> estructurasProgram .)
    RBRACE          reduce using rule 6 (sentencia -> estructurasProgram .)
    BREAK           reduce using rule 6 (sentencia -> estructurasProgram .)


state 7

    (10) asignacion -> VARIABLE . EQUALS operaArit SEMICOLON
    (82) array -> VARIABLE . EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> VARIABLE . EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> VARIABLE . EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> VARIABLE . EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> VARIABLE . EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> VARIABLE . EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON

    EQUALS          shift and go to state 31


state 8

    (11) impresion -> ECHO . imprimir SEMICOLON
    (94) imprimir -> . LPAREN repiteValores RPAREN
    (95) imprimir -> . LPAREN RPAREN
    (96) imprimir -> . repiteValores
    (115) repiteValores -> . valor COMMA repiteValores
    (116) repiteValores -> . valor
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 33
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    imprimir                       shift and go to state 32
    repiteValores                  shift and go to state 34
    valor                          shift and go to state 35
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 9

    (12) impresion -> PRINT . imprimir SEMICOLON
    (94) imprimir -> . LPAREN repiteValores RPAREN
    (95) imprimir -> . LPAREN RPAREN
    (96) imprimir -> . repiteValores
    (115) repiteValores -> . valor COMMA repiteValores
    (116) repiteValores -> . valor
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 33
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    imprimir                       shift and go to state 46
    repiteValores                  shift and go to state 34
    valor                          shift and go to state 35
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 10

    (111) comparacion -> INT . operador INT
    (113) comparacion -> INT . operador FLOAT
    (125) operador -> . PLUS
    (126) operador -> . MINUS
    (127) operador -> . TIMES
    (128) operador -> . DIVIDE
    (129) operador -> . MODULO

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MODULO          shift and go to state 52

    operador                       shift and go to state 47

state 11

    (112) comparacion -> FLOAT . operador FLOAT
    (114) comparacion -> FLOAT . operador INT
    (125) operador -> . PLUS
    (126) operador -> . MINUS
    (127) operador -> . TIMES
    (128) operador -> . DIVIDE
    (129) operador -> . MODULO

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MODULO          shift and go to state 52

    operador                       shift and go to state 53

state 12

    (13) estructurasProgram -> controlStructure .

    VARIABLE        reduce using rule 13 (estructurasProgram -> controlStructure .)
    ECHO            reduce using rule 13 (estructurasProgram -> controlStructure .)
    PRINT           reduce using rule 13 (estructurasProgram -> controlStructure .)
    INT             reduce using rule 13 (estructurasProgram -> controlStructure .)
    FLOAT           reduce using rule 13 (estructurasProgram -> controlStructure .)
    FUNCTION        reduce using rule 13 (estructurasProgram -> controlStructure .)
    CLASS           reduce using rule 13 (estructurasProgram -> controlStructure .)
    WHILE           reduce using rule 13 (estructurasProgram -> controlStructure .)
    SWITCH          reduce using rule 13 (estructurasProgram -> controlStructure .)
    IF              reduce using rule 13 (estructurasProgram -> controlStructure .)
    FOR             reduce using rule 13 (estructurasProgram -> controlStructure .)
    $end            reduce using rule 13 (estructurasProgram -> controlStructure .)
    RBRACE          reduce using rule 13 (estructurasProgram -> controlStructure .)
    BREAK           reduce using rule 13 (estructurasProgram -> controlStructure .)


state 13

    (14) estructurasProgram -> dataStructure .

    VARIABLE        reduce using rule 14 (estructurasProgram -> dataStructure .)
    ECHO            reduce using rule 14 (estructurasProgram -> dataStructure .)
    PRINT           reduce using rule 14 (estructurasProgram -> dataStructure .)
    INT             reduce using rule 14 (estructurasProgram -> dataStructure .)
    FLOAT           reduce using rule 14 (estructurasProgram -> dataStructure .)
    FUNCTION        reduce using rule 14 (estructurasProgram -> dataStructure .)
    CLASS           reduce using rule 14 (estructurasProgram -> dataStructure .)
    WHILE           reduce using rule 14 (estructurasProgram -> dataStructure .)
    SWITCH          reduce using rule 14 (estructurasProgram -> dataStructure .)
    IF              reduce using rule 14 (estructurasProgram -> dataStructure .)
    FOR             reduce using rule 14 (estructurasProgram -> dataStructure .)
    $end            reduce using rule 14 (estructurasProgram -> dataStructure .)
    RBRACE          reduce using rule 14 (estructurasProgram -> dataStructure .)
    BREAK           reduce using rule 14 (estructurasProgram -> dataStructure .)


state 14

    (15) estructurasProgram -> funcionDeclarate .

    VARIABLE        reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    ECHO            reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    PRINT           reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    INT             reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    FLOAT           reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    FUNCTION        reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    CLASS           reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    WHILE           reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    SWITCH          reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    IF              reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    FOR             reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    $end            reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    RBRACE          reduce using rule 15 (estructurasProgram -> funcionDeclarate .)
    BREAK           reduce using rule 15 (estructurasProgram -> funcionDeclarate .)


state 15

    (16) estructurasProgram -> classDeclarate .

    VARIABLE        reduce using rule 16 (estructurasProgram -> classDeclarate .)
    ECHO            reduce using rule 16 (estructurasProgram -> classDeclarate .)
    PRINT           reduce using rule 16 (estructurasProgram -> classDeclarate .)
    INT             reduce using rule 16 (estructurasProgram -> classDeclarate .)
    FLOAT           reduce using rule 16 (estructurasProgram -> classDeclarate .)
    FUNCTION        reduce using rule 16 (estructurasProgram -> classDeclarate .)
    CLASS           reduce using rule 16 (estructurasProgram -> classDeclarate .)
    WHILE           reduce using rule 16 (estructurasProgram -> classDeclarate .)
    SWITCH          reduce using rule 16 (estructurasProgram -> classDeclarate .)
    IF              reduce using rule 16 (estructurasProgram -> classDeclarate .)
    FOR             reduce using rule 16 (estructurasProgram -> classDeclarate .)
    $end            reduce using rule 16 (estructurasProgram -> classDeclarate .)
    RBRACE          reduce using rule 16 (estructurasProgram -> classDeclarate .)
    BREAK           reduce using rule 16 (estructurasProgram -> classDeclarate .)


state 16

    (17) controlStructure -> if .

    VARIABLE        reduce using rule 17 (controlStructure -> if .)
    ECHO            reduce using rule 17 (controlStructure -> if .)
    PRINT           reduce using rule 17 (controlStructure -> if .)
    INT             reduce using rule 17 (controlStructure -> if .)
    FLOAT           reduce using rule 17 (controlStructure -> if .)
    FUNCTION        reduce using rule 17 (controlStructure -> if .)
    CLASS           reduce using rule 17 (controlStructure -> if .)
    WHILE           reduce using rule 17 (controlStructure -> if .)
    SWITCH          reduce using rule 17 (controlStructure -> if .)
    IF              reduce using rule 17 (controlStructure -> if .)
    FOR             reduce using rule 17 (controlStructure -> if .)
    $end            reduce using rule 17 (controlStructure -> if .)
    RBRACE          reduce using rule 17 (controlStructure -> if .)
    BREAK           reduce using rule 17 (controlStructure -> if .)


state 17

    (18) controlStructure -> for .

    VARIABLE        reduce using rule 18 (controlStructure -> for .)
    ECHO            reduce using rule 18 (controlStructure -> for .)
    PRINT           reduce using rule 18 (controlStructure -> for .)
    INT             reduce using rule 18 (controlStructure -> for .)
    FLOAT           reduce using rule 18 (controlStructure -> for .)
    FUNCTION        reduce using rule 18 (controlStructure -> for .)
    CLASS           reduce using rule 18 (controlStructure -> for .)
    WHILE           reduce using rule 18 (controlStructure -> for .)
    SWITCH          reduce using rule 18 (controlStructure -> for .)
    IF              reduce using rule 18 (controlStructure -> for .)
    FOR             reduce using rule 18 (controlStructure -> for .)
    $end            reduce using rule 18 (controlStructure -> for .)
    RBRACE          reduce using rule 18 (controlStructure -> for .)
    BREAK           reduce using rule 18 (controlStructure -> for .)


state 18

    (19) controlStructure -> while .

    VARIABLE        reduce using rule 19 (controlStructure -> while .)
    ECHO            reduce using rule 19 (controlStructure -> while .)
    PRINT           reduce using rule 19 (controlStructure -> while .)
    INT             reduce using rule 19 (controlStructure -> while .)
    FLOAT           reduce using rule 19 (controlStructure -> while .)
    FUNCTION        reduce using rule 19 (controlStructure -> while .)
    CLASS           reduce using rule 19 (controlStructure -> while .)
    WHILE           reduce using rule 19 (controlStructure -> while .)
    SWITCH          reduce using rule 19 (controlStructure -> while .)
    IF              reduce using rule 19 (controlStructure -> while .)
    FOR             reduce using rule 19 (controlStructure -> while .)
    $end            reduce using rule 19 (controlStructure -> while .)
    RBRACE          reduce using rule 19 (controlStructure -> while .)
    BREAK           reduce using rule 19 (controlStructure -> while .)


state 19

    (20) controlStructure -> switch .

    VARIABLE        reduce using rule 20 (controlStructure -> switch .)
    ECHO            reduce using rule 20 (controlStructure -> switch .)
    PRINT           reduce using rule 20 (controlStructure -> switch .)
    INT             reduce using rule 20 (controlStructure -> switch .)
    FLOAT           reduce using rule 20 (controlStructure -> switch .)
    FUNCTION        reduce using rule 20 (controlStructure -> switch .)
    CLASS           reduce using rule 20 (controlStructure -> switch .)
    WHILE           reduce using rule 20 (controlStructure -> switch .)
    SWITCH          reduce using rule 20 (controlStructure -> switch .)
    IF              reduce using rule 20 (controlStructure -> switch .)
    FOR             reduce using rule 20 (controlStructure -> switch .)
    $end            reduce using rule 20 (controlStructure -> switch .)
    RBRACE          reduce using rule 20 (controlStructure -> switch .)
    BREAK           reduce using rule 20 (controlStructure -> switch .)


state 20

    (57) dataStructure -> array .

    VARIABLE        reduce using rule 57 (dataStructure -> array .)
    ECHO            reduce using rule 57 (dataStructure -> array .)
    PRINT           reduce using rule 57 (dataStructure -> array .)
    INT             reduce using rule 57 (dataStructure -> array .)
    FLOAT           reduce using rule 57 (dataStructure -> array .)
    FUNCTION        reduce using rule 57 (dataStructure -> array .)
    CLASS           reduce using rule 57 (dataStructure -> array .)
    WHILE           reduce using rule 57 (dataStructure -> array .)
    SWITCH          reduce using rule 57 (dataStructure -> array .)
    IF              reduce using rule 57 (dataStructure -> array .)
    FOR             reduce using rule 57 (dataStructure -> array .)
    $end            reduce using rule 57 (dataStructure -> array .)
    RBRACE          reduce using rule 57 (dataStructure -> array .)
    BREAK           reduce using rule 57 (dataStructure -> array .)


state 21

    (58) dataStructure -> map .

    VARIABLE        reduce using rule 58 (dataStructure -> map .)
    ECHO            reduce using rule 58 (dataStructure -> map .)
    PRINT           reduce using rule 58 (dataStructure -> map .)
    INT             reduce using rule 58 (dataStructure -> map .)
    FLOAT           reduce using rule 58 (dataStructure -> map .)
    FUNCTION        reduce using rule 58 (dataStructure -> map .)
    CLASS           reduce using rule 58 (dataStructure -> map .)
    WHILE           reduce using rule 58 (dataStructure -> map .)
    SWITCH          reduce using rule 58 (dataStructure -> map .)
    IF              reduce using rule 58 (dataStructure -> map .)
    FOR             reduce using rule 58 (dataStructure -> map .)
    $end            reduce using rule 58 (dataStructure -> map .)
    RBRACE          reduce using rule 58 (dataStructure -> map .)
    BREAK           reduce using rule 58 (dataStructure -> map .)


state 22

    (59) funcionDeclarate -> FUNCTION . ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> FUNCTION . ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE

    ID              shift and go to state 54


state 23

    (74) classDeclarate -> CLASS . ID LBRACE classBody RBRACE
    (75) classDeclarate -> CLASS . ID EXTENDS ID LBRACE classBody RBRACE

    ID              shift and go to state 55


state 24

    (21) if -> statementif . ELSE body
    (22) if -> statementif . ELSE if
    (23) if -> statementif . ELSEIF if
    (24) if -> statementif .

    ELSE            shift and go to state 56
    ELSEIF          shift and go to state 57
    VARIABLE        reduce using rule 24 (if -> statementif .)
    ECHO            reduce using rule 24 (if -> statementif .)
    PRINT           reduce using rule 24 (if -> statementif .)
    INT             reduce using rule 24 (if -> statementif .)
    FLOAT           reduce using rule 24 (if -> statementif .)
    FUNCTION        reduce using rule 24 (if -> statementif .)
    CLASS           reduce using rule 24 (if -> statementif .)
    WHILE           reduce using rule 24 (if -> statementif .)
    SWITCH          reduce using rule 24 (if -> statementif .)
    IF              reduce using rule 24 (if -> statementif .)
    FOR             reduce using rule 24 (if -> statementif .)
    $end            reduce using rule 24 (if -> statementif .)
    RBRACE          reduce using rule 24 (if -> statementif .)
    BREAK           reduce using rule 24 (if -> statementif .)


state 25

    (41) for -> forStatement .

    VARIABLE        reduce using rule 41 (for -> forStatement .)
    ECHO            reduce using rule 41 (for -> forStatement .)
    PRINT           reduce using rule 41 (for -> forStatement .)
    INT             reduce using rule 41 (for -> forStatement .)
    FLOAT           reduce using rule 41 (for -> forStatement .)
    FUNCTION        reduce using rule 41 (for -> forStatement .)
    CLASS           reduce using rule 41 (for -> forStatement .)
    WHILE           reduce using rule 41 (for -> forStatement .)
    SWITCH          reduce using rule 41 (for -> forStatement .)
    IF              reduce using rule 41 (for -> forStatement .)
    FOR             reduce using rule 41 (for -> forStatement .)
    $end            reduce using rule 41 (for -> forStatement .)
    RBRACE          reduce using rule 41 (for -> forStatement .)
    BREAK           reduce using rule 41 (for -> forStatement .)


state 26

    (45) while -> WHILE . LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> WHILE . LPAREN condition RPAREN LBRACE RBRACE

    LPAREN          shift and go to state 58


state 27

    (47) switch -> SWITCH . LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> SWITCH . LPAREN condition RPAREN LBRACE RBRACE

    LPAREN          shift and go to state 59


state 28

    (25) statementif -> IF . LPAREN conditionProdu RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 60


state 29

    (42) forStatement -> FOR . LPAREN forcondition RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 61


state 30

    (2) programa -> sentencia programa .

    $end            reduce using rule 2 (programa -> sentencia programa .)


state 31

    (10) asignacion -> VARIABLE EQUALS . operaArit SEMICOLON
    (82) array -> VARIABLE EQUALS . LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> VARIABLE EQUALS . ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> VARIABLE EQUALS . ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> VARIABLE EQUALS . LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> VARIABLE EQUALS . LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> VARIABLE EQUALS . ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (117) operaArit -> . valor
    (118) operaArit -> . valor operador operaArit
    (119) operaArit -> . valor DOT valor
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LBRACKET        shift and go to state 63
    ARRAY           shift and go to state 64
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    operaArit                      shift and go to state 62
    valor                          shift and go to state 65
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 32

    (11) impresion -> ECHO imprimir . SEMICOLON

    SEMICOLON       shift and go to state 66


state 33

    (94) imprimir -> LPAREN . repiteValores RPAREN
    (95) imprimir -> LPAREN . RPAREN
    (115) repiteValores -> . valor COMMA repiteValores
    (116) repiteValores -> . valor
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    RPAREN          shift and go to state 68
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    repiteValores                  shift and go to state 67
    valor                          shift and go to state 35
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 34

    (96) imprimir -> repiteValores .

    SEMICOLON       reduce using rule 96 (imprimir -> repiteValores .)


state 35

    (115) repiteValores -> valor . COMMA repiteValores
    (116) repiteValores -> valor .

    COMMA           shift and go to state 69
    SEMICOLON       reduce using rule 116 (repiteValores -> valor .)
    RPAREN          reduce using rule 116 (repiteValores -> valor .)
    RBRACKET        reduce using rule 116 (repiteValores -> valor .)


state 36

    (97) valor -> INT .

    COMMA           reduce using rule 97 (valor -> INT .)
    SEMICOLON       reduce using rule 97 (valor -> INT .)
    DOT             reduce using rule 97 (valor -> INT .)
    PLUS            reduce using rule 97 (valor -> INT .)
    MINUS           reduce using rule 97 (valor -> INT .)
    TIMES           reduce using rule 97 (valor -> INT .)
    DIVIDE          reduce using rule 97 (valor -> INT .)
    MODULO          reduce using rule 97 (valor -> INT .)
    RPAREN          reduce using rule 97 (valor -> INT .)
    EQ              reduce using rule 97 (valor -> INT .)
    NEQ             reduce using rule 97 (valor -> INT .)
    STRICTEQ        reduce using rule 97 (valor -> INT .)
    STRICTNEQ       reduce using rule 97 (valor -> INT .)
    LT              reduce using rule 97 (valor -> INT .)
    GT              reduce using rule 97 (valor -> INT .)
    LEQ             reduce using rule 97 (valor -> INT .)
    GEQ             reduce using rule 97 (valor -> INT .)
    ARROWMAP        reduce using rule 97 (valor -> INT .)
    RBRACKET        reduce using rule 97 (valor -> INT .)
    COLON           reduce using rule 97 (valor -> INT .)
    AND             reduce using rule 97 (valor -> INT .)
    OR              reduce using rule 97 (valor -> INT .)
    NOT             reduce using rule 97 (valor -> INT .)
    QUESTION        reduce using rule 97 (valor -> INT .)


state 37

    (98) valor -> FLOAT .

    COMMA           reduce using rule 98 (valor -> FLOAT .)
    SEMICOLON       reduce using rule 98 (valor -> FLOAT .)
    DOT             reduce using rule 98 (valor -> FLOAT .)
    PLUS            reduce using rule 98 (valor -> FLOAT .)
    MINUS           reduce using rule 98 (valor -> FLOAT .)
    TIMES           reduce using rule 98 (valor -> FLOAT .)
    DIVIDE          reduce using rule 98 (valor -> FLOAT .)
    MODULO          reduce using rule 98 (valor -> FLOAT .)
    RPAREN          reduce using rule 98 (valor -> FLOAT .)
    EQ              reduce using rule 98 (valor -> FLOAT .)
    NEQ             reduce using rule 98 (valor -> FLOAT .)
    STRICTEQ        reduce using rule 98 (valor -> FLOAT .)
    STRICTNEQ       reduce using rule 98 (valor -> FLOAT .)
    LT              reduce using rule 98 (valor -> FLOAT .)
    GT              reduce using rule 98 (valor -> FLOAT .)
    LEQ             reduce using rule 98 (valor -> FLOAT .)
    GEQ             reduce using rule 98 (valor -> FLOAT .)
    ARROWMAP        reduce using rule 98 (valor -> FLOAT .)
    RBRACKET        reduce using rule 98 (valor -> FLOAT .)
    COLON           reduce using rule 98 (valor -> FLOAT .)
    AND             reduce using rule 98 (valor -> FLOAT .)
    OR              reduce using rule 98 (valor -> FLOAT .)
    NOT             reduce using rule 98 (valor -> FLOAT .)
    QUESTION        reduce using rule 98 (valor -> FLOAT .)


state 38

    (99) valor -> VARIABLE .
    (73) funcionAnonima -> VARIABLE . EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    COMMA           reduce using rule 99 (valor -> VARIABLE .)
    SEMICOLON       reduce using rule 99 (valor -> VARIABLE .)
    DOT             reduce using rule 99 (valor -> VARIABLE .)
    PLUS            reduce using rule 99 (valor -> VARIABLE .)
    MINUS           reduce using rule 99 (valor -> VARIABLE .)
    TIMES           reduce using rule 99 (valor -> VARIABLE .)
    DIVIDE          reduce using rule 99 (valor -> VARIABLE .)
    MODULO          reduce using rule 99 (valor -> VARIABLE .)
    RPAREN          reduce using rule 99 (valor -> VARIABLE .)
    EQ              reduce using rule 99 (valor -> VARIABLE .)
    NEQ             reduce using rule 99 (valor -> VARIABLE .)
    STRICTEQ        reduce using rule 99 (valor -> VARIABLE .)
    STRICTNEQ       reduce using rule 99 (valor -> VARIABLE .)
    LT              reduce using rule 99 (valor -> VARIABLE .)
    GT              reduce using rule 99 (valor -> VARIABLE .)
    LEQ             reduce using rule 99 (valor -> VARIABLE .)
    GEQ             reduce using rule 99 (valor -> VARIABLE .)
    ARROWMAP        reduce using rule 99 (valor -> VARIABLE .)
    RBRACKET        reduce using rule 99 (valor -> VARIABLE .)
    COLON           reduce using rule 99 (valor -> VARIABLE .)
    AND             reduce using rule 99 (valor -> VARIABLE .)
    OR              reduce using rule 99 (valor -> VARIABLE .)
    NOT             reduce using rule 99 (valor -> VARIABLE .)
    QUESTION        reduce using rule 99 (valor -> VARIABLE .)
    EQUALS          shift and go to state 70


state 39

    (100) valor -> STRING .

    COMMA           reduce using rule 100 (valor -> STRING .)
    SEMICOLON       reduce using rule 100 (valor -> STRING .)
    DOT             reduce using rule 100 (valor -> STRING .)
    PLUS            reduce using rule 100 (valor -> STRING .)
    MINUS           reduce using rule 100 (valor -> STRING .)
    TIMES           reduce using rule 100 (valor -> STRING .)
    DIVIDE          reduce using rule 100 (valor -> STRING .)
    MODULO          reduce using rule 100 (valor -> STRING .)
    RPAREN          reduce using rule 100 (valor -> STRING .)
    EQ              reduce using rule 100 (valor -> STRING .)
    NEQ             reduce using rule 100 (valor -> STRING .)
    STRICTEQ        reduce using rule 100 (valor -> STRING .)
    STRICTNEQ       reduce using rule 100 (valor -> STRING .)
    LT              reduce using rule 100 (valor -> STRING .)
    GT              reduce using rule 100 (valor -> STRING .)
    LEQ             reduce using rule 100 (valor -> STRING .)
    GEQ             reduce using rule 100 (valor -> STRING .)
    ARROWMAP        reduce using rule 100 (valor -> STRING .)
    RBRACKET        reduce using rule 100 (valor -> STRING .)
    COLON           reduce using rule 100 (valor -> STRING .)
    AND             reduce using rule 100 (valor -> STRING .)
    OR              reduce using rule 100 (valor -> STRING .)
    NOT             reduce using rule 100 (valor -> STRING .)
    QUESTION        reduce using rule 100 (valor -> STRING .)


state 40

    (101) valor -> TRUE .

    COMMA           reduce using rule 101 (valor -> TRUE .)
    SEMICOLON       reduce using rule 101 (valor -> TRUE .)
    DOT             reduce using rule 101 (valor -> TRUE .)
    PLUS            reduce using rule 101 (valor -> TRUE .)
    MINUS           reduce using rule 101 (valor -> TRUE .)
    TIMES           reduce using rule 101 (valor -> TRUE .)
    DIVIDE          reduce using rule 101 (valor -> TRUE .)
    MODULO          reduce using rule 101 (valor -> TRUE .)
    RPAREN          reduce using rule 101 (valor -> TRUE .)
    EQ              reduce using rule 101 (valor -> TRUE .)
    NEQ             reduce using rule 101 (valor -> TRUE .)
    STRICTEQ        reduce using rule 101 (valor -> TRUE .)
    STRICTNEQ       reduce using rule 101 (valor -> TRUE .)
    LT              reduce using rule 101 (valor -> TRUE .)
    GT              reduce using rule 101 (valor -> TRUE .)
    LEQ             reduce using rule 101 (valor -> TRUE .)
    GEQ             reduce using rule 101 (valor -> TRUE .)
    ARROWMAP        reduce using rule 101 (valor -> TRUE .)
    RBRACKET        reduce using rule 101 (valor -> TRUE .)
    COLON           reduce using rule 101 (valor -> TRUE .)
    AND             reduce using rule 101 (valor -> TRUE .)
    OR              reduce using rule 101 (valor -> TRUE .)
    NOT             reduce using rule 101 (valor -> TRUE .)
    QUESTION        reduce using rule 101 (valor -> TRUE .)


state 41

    (102) valor -> FALSE .

    COMMA           reduce using rule 102 (valor -> FALSE .)
    SEMICOLON       reduce using rule 102 (valor -> FALSE .)
    DOT             reduce using rule 102 (valor -> FALSE .)
    PLUS            reduce using rule 102 (valor -> FALSE .)
    MINUS           reduce using rule 102 (valor -> FALSE .)
    TIMES           reduce using rule 102 (valor -> FALSE .)
    DIVIDE          reduce using rule 102 (valor -> FALSE .)
    MODULO          reduce using rule 102 (valor -> FALSE .)
    RPAREN          reduce using rule 102 (valor -> FALSE .)
    EQ              reduce using rule 102 (valor -> FALSE .)
    NEQ             reduce using rule 102 (valor -> FALSE .)
    STRICTEQ        reduce using rule 102 (valor -> FALSE .)
    STRICTNEQ       reduce using rule 102 (valor -> FALSE .)
    LT              reduce using rule 102 (valor -> FALSE .)
    GT              reduce using rule 102 (valor -> FALSE .)
    LEQ             reduce using rule 102 (valor -> FALSE .)
    GEQ             reduce using rule 102 (valor -> FALSE .)
    ARROWMAP        reduce using rule 102 (valor -> FALSE .)
    RBRACKET        reduce using rule 102 (valor -> FALSE .)
    COLON           reduce using rule 102 (valor -> FALSE .)
    AND             reduce using rule 102 (valor -> FALSE .)
    OR              reduce using rule 102 (valor -> FALSE .)
    NOT             reduce using rule 102 (valor -> FALSE .)
    QUESTION        reduce using rule 102 (valor -> FALSE .)


state 42

    (103) valor -> THIS .

    COMMA           reduce using rule 103 (valor -> THIS .)
    SEMICOLON       reduce using rule 103 (valor -> THIS .)
    DOT             reduce using rule 103 (valor -> THIS .)
    PLUS            reduce using rule 103 (valor -> THIS .)
    MINUS           reduce using rule 103 (valor -> THIS .)
    TIMES           reduce using rule 103 (valor -> THIS .)
    DIVIDE          reduce using rule 103 (valor -> THIS .)
    MODULO          reduce using rule 103 (valor -> THIS .)
    RPAREN          reduce using rule 103 (valor -> THIS .)
    EQ              reduce using rule 103 (valor -> THIS .)
    NEQ             reduce using rule 103 (valor -> THIS .)
    STRICTEQ        reduce using rule 103 (valor -> THIS .)
    STRICTNEQ       reduce using rule 103 (valor -> THIS .)
    LT              reduce using rule 103 (valor -> THIS .)
    GT              reduce using rule 103 (valor -> THIS .)
    LEQ             reduce using rule 103 (valor -> THIS .)
    GEQ             reduce using rule 103 (valor -> THIS .)
    ARROWMAP        reduce using rule 103 (valor -> THIS .)
    RBRACKET        reduce using rule 103 (valor -> THIS .)
    COLON           reduce using rule 103 (valor -> THIS .)
    AND             reduce using rule 103 (valor -> THIS .)
    OR              reduce using rule 103 (valor -> THIS .)
    NOT             reduce using rule 103 (valor -> THIS .)
    QUESTION        reduce using rule 103 (valor -> THIS .)


state 43

    (104) valor -> funcionParen .

    COMMA           reduce using rule 104 (valor -> funcionParen .)
    SEMICOLON       reduce using rule 104 (valor -> funcionParen .)
    DOT             reduce using rule 104 (valor -> funcionParen .)
    PLUS            reduce using rule 104 (valor -> funcionParen .)
    MINUS           reduce using rule 104 (valor -> funcionParen .)
    TIMES           reduce using rule 104 (valor -> funcionParen .)
    DIVIDE          reduce using rule 104 (valor -> funcionParen .)
    MODULO          reduce using rule 104 (valor -> funcionParen .)
    RPAREN          reduce using rule 104 (valor -> funcionParen .)
    EQ              reduce using rule 104 (valor -> funcionParen .)
    NEQ             reduce using rule 104 (valor -> funcionParen .)
    STRICTEQ        reduce using rule 104 (valor -> funcionParen .)
    STRICTNEQ       reduce using rule 104 (valor -> funcionParen .)
    LT              reduce using rule 104 (valor -> funcionParen .)
    GT              reduce using rule 104 (valor -> funcionParen .)
    LEQ             reduce using rule 104 (valor -> funcionParen .)
    GEQ             reduce using rule 104 (valor -> funcionParen .)
    ARROWMAP        reduce using rule 104 (valor -> funcionParen .)
    RBRACKET        reduce using rule 104 (valor -> funcionParen .)
    COLON           reduce using rule 104 (valor -> funcionParen .)
    AND             reduce using rule 104 (valor -> funcionParen .)
    OR              reduce using rule 104 (valor -> funcionParen .)
    NOT             reduce using rule 104 (valor -> funcionParen .)
    QUESTION        reduce using rule 104 (valor -> funcionParen .)


state 44

    (105) valor -> funcionAnonima .

    COMMA           reduce using rule 105 (valor -> funcionAnonima .)
    SEMICOLON       reduce using rule 105 (valor -> funcionAnonima .)
    DOT             reduce using rule 105 (valor -> funcionAnonima .)
    PLUS            reduce using rule 105 (valor -> funcionAnonima .)
    MINUS           reduce using rule 105 (valor -> funcionAnonima .)
    TIMES           reduce using rule 105 (valor -> funcionAnonima .)
    DIVIDE          reduce using rule 105 (valor -> funcionAnonima .)
    MODULO          reduce using rule 105 (valor -> funcionAnonima .)
    RPAREN          reduce using rule 105 (valor -> funcionAnonima .)
    EQ              reduce using rule 105 (valor -> funcionAnonima .)
    NEQ             reduce using rule 105 (valor -> funcionAnonima .)
    STRICTEQ        reduce using rule 105 (valor -> funcionAnonima .)
    STRICTNEQ       reduce using rule 105 (valor -> funcionAnonima .)
    LT              reduce using rule 105 (valor -> funcionAnonima .)
    GT              reduce using rule 105 (valor -> funcionAnonima .)
    LEQ             reduce using rule 105 (valor -> funcionAnonima .)
    GEQ             reduce using rule 105 (valor -> funcionAnonima .)
    ARROWMAP        reduce using rule 105 (valor -> funcionAnonima .)
    RBRACKET        reduce using rule 105 (valor -> funcionAnonima .)
    COLON           reduce using rule 105 (valor -> funcionAnonima .)
    AND             reduce using rule 105 (valor -> funcionAnonima .)
    OR              reduce using rule 105 (valor -> funcionAnonima .)
    NOT             reduce using rule 105 (valor -> funcionAnonima .)
    QUESTION        reduce using rule 105 (valor -> funcionAnonima .)


state 45

    (72) funcionParen -> ID . LPAREN parametros RPAREN

    LPAREN          shift and go to state 71


state 46

    (12) impresion -> PRINT imprimir . SEMICOLON

    SEMICOLON       shift and go to state 72


state 47

    (111) comparacion -> INT operador . INT
    (113) comparacion -> INT operador . FLOAT

    INT             shift and go to state 73
    FLOAT           shift and go to state 74


state 48

    (125) operador -> PLUS .

    INT             reduce using rule 125 (operador -> PLUS .)
    FLOAT           reduce using rule 125 (operador -> PLUS .)
    VARIABLE        reduce using rule 125 (operador -> PLUS .)
    STRING          reduce using rule 125 (operador -> PLUS .)
    TRUE            reduce using rule 125 (operador -> PLUS .)
    FALSE           reduce using rule 125 (operador -> PLUS .)
    THIS            reduce using rule 125 (operador -> PLUS .)
    ID              reduce using rule 125 (operador -> PLUS .)


state 49

    (126) operador -> MINUS .

    INT             reduce using rule 126 (operador -> MINUS .)
    FLOAT           reduce using rule 126 (operador -> MINUS .)
    VARIABLE        reduce using rule 126 (operador -> MINUS .)
    STRING          reduce using rule 126 (operador -> MINUS .)
    TRUE            reduce using rule 126 (operador -> MINUS .)
    FALSE           reduce using rule 126 (operador -> MINUS .)
    THIS            reduce using rule 126 (operador -> MINUS .)
    ID              reduce using rule 126 (operador -> MINUS .)


state 50

    (127) operador -> TIMES .

    INT             reduce using rule 127 (operador -> TIMES .)
    FLOAT           reduce using rule 127 (operador -> TIMES .)
    VARIABLE        reduce using rule 127 (operador -> TIMES .)
    STRING          reduce using rule 127 (operador -> TIMES .)
    TRUE            reduce using rule 127 (operador -> TIMES .)
    FALSE           reduce using rule 127 (operador -> TIMES .)
    THIS            reduce using rule 127 (operador -> TIMES .)
    ID              reduce using rule 127 (operador -> TIMES .)


state 51

    (128) operador -> DIVIDE .

    INT             reduce using rule 128 (operador -> DIVIDE .)
    FLOAT           reduce using rule 128 (operador -> DIVIDE .)
    VARIABLE        reduce using rule 128 (operador -> DIVIDE .)
    STRING          reduce using rule 128 (operador -> DIVIDE .)
    TRUE            reduce using rule 128 (operador -> DIVIDE .)
    FALSE           reduce using rule 128 (operador -> DIVIDE .)
    THIS            reduce using rule 128 (operador -> DIVIDE .)
    ID              reduce using rule 128 (operador -> DIVIDE .)


state 52

    (129) operador -> MODULO .

    INT             reduce using rule 129 (operador -> MODULO .)
    FLOAT           reduce using rule 129 (operador -> MODULO .)
    VARIABLE        reduce using rule 129 (operador -> MODULO .)
    STRING          reduce using rule 129 (operador -> MODULO .)
    TRUE            reduce using rule 129 (operador -> MODULO .)
    FALSE           reduce using rule 129 (operador -> MODULO .)
    THIS            reduce using rule 129 (operador -> MODULO .)
    ID              reduce using rule 129 (operador -> MODULO .)


state 53

    (112) comparacion -> FLOAT operador . FLOAT
    (114) comparacion -> FLOAT operador . INT

    FLOAT           shift and go to state 75
    INT             shift and go to state 76


state 54

    (59) funcionDeclarate -> FUNCTION ID . LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> FUNCTION ID . LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE

    LPAREN          shift and go to state 77


state 55

    (74) classDeclarate -> CLASS ID . LBRACE classBody RBRACE
    (75) classDeclarate -> CLASS ID . EXTENDS ID LBRACE classBody RBRACE

    LBRACE          shift and go to state 78
    EXTENDS         shift and go to state 79


state 56

    (21) if -> statementif ELSE . body
    (22) if -> statementif ELSE . if
    (91) body -> . sentencia
    (92) body -> . sentencia sentencias
    (93) body -> . empty
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (131) empty -> .
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (111) comparacion -> . INT operador INT
    (112) comparacion -> . FLOAT operador FLOAT
    (113) comparacion -> . INT operador FLOAT
    (114) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (74) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (75) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (82) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    $end            reduce using rule 131 (empty -> .)
    RBRACE          reduce using rule 131 (empty -> .)
    BREAK           reduce using rule 131 (empty -> .)
    IF              shift and go to state 28
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    FOR             shift and go to state 29

  ! VARIABLE        [ reduce using rule 131 (empty -> .) ]
  ! ECHO            [ reduce using rule 131 (empty -> .) ]
  ! PRINT           [ reduce using rule 131 (empty -> .) ]
  ! INT             [ reduce using rule 131 (empty -> .) ]
  ! FLOAT           [ reduce using rule 131 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 131 (empty -> .) ]
  ! CLASS           [ reduce using rule 131 (empty -> .) ]
  ! WHILE           [ reduce using rule 131 (empty -> .) ]
  ! SWITCH          [ reduce using rule 131 (empty -> .) ]
  ! IF              [ reduce using rule 131 (empty -> .) ]
  ! FOR             [ reduce using rule 131 (empty -> .) ]

    statementif                    shift and go to state 24
    body                           shift and go to state 80
    if                             shift and go to state 81
    sentencia                      shift and go to state 82
    empty                          shift and go to state 83
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    forStatement                   shift and go to state 25

state 57

    (23) if -> statementif ELSEIF . if
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE

    IF              shift and go to state 28

    statementif                    shift and go to state 24
    if                             shift and go to state 84

state 58

    (45) while -> WHILE LPAREN . condition RPAREN LBRACE body RBRACE
    (46) while -> WHILE LPAREN . condition RPAREN LBRACE RBRACE
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 85
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    condition                      shift and go to state 86
    valor                          shift and go to state 87
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 59

    (47) switch -> SWITCH LPAREN . condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> SWITCH LPAREN . condition RPAREN LBRACE RBRACE
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 85
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    condition                      shift and go to state 88
    valor                          shift and go to state 87
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 60

    (25) statementif -> IF LPAREN . conditionProdu RPAREN LBRACE body RBRACE
    (26) conditionProdu -> . condition
    (27) conditionProdu -> . condition opLogic conditionProdu
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 85
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    conditionProdu                 shift and go to state 89
    condition                      shift and go to state 90
    valor                          shift and go to state 87
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 61

    (42) forStatement -> FOR LPAREN . forcondition RPAREN LBRACE body RBRACE
    (43) forcondition -> . VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> . VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    VARIABLE        shift and go to state 92

    forcondition                   shift and go to state 91

state 62

    (10) asignacion -> VARIABLE EQUALS operaArit . SEMICOLON

    SEMICOLON       shift and go to state 93


state 63

    (82) array -> VARIABLE EQUALS LBRACKET . repiteValores RBRACKET SEMICOLON
    (85) array -> VARIABLE EQUALS LBRACKET . mapProduc RBRACKET SEMICOLON
    (86) map -> VARIABLE EQUALS LBRACKET . mapProduc RBRACKET SEMICOLON
    (115) repiteValores -> . valor COMMA repiteValores
    (116) repiteValores -> . valor
    (88) mapProduc -> . mapArrow
    (89) mapProduc -> . mapArrow COMMA mapProduc
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (90) mapArrow -> . valor ARROWMAP valor
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    repiteValores                  shift and go to state 94
    mapProduc                      shift and go to state 95
    valor                          shift and go to state 96
    mapArrow                       shift and go to state 97
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 64

    (83) array -> VARIABLE EQUALS ARRAY . LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> VARIABLE EQUALS ARRAY . LPAREN mapProduc RPAREN SEMICOLON
    (87) map -> VARIABLE EQUALS ARRAY . LPAREN mapProduc RPAREN SEMICOLON

    LPAREN          shift and go to state 98


state 65

    (117) operaArit -> valor .
    (118) operaArit -> valor . operador operaArit
    (119) operaArit -> valor . DOT valor
    (125) operador -> . PLUS
    (126) operador -> . MINUS
    (127) operador -> . TIMES
    (128) operador -> . DIVIDE
    (129) operador -> . MODULO

    SEMICOLON       reduce using rule 117 (operaArit -> valor .)
    COLON           reduce using rule 117 (operaArit -> valor .)
    DOT             shift and go to state 100
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MODULO          shift and go to state 52

    operador                       shift and go to state 99

state 66

    (11) impresion -> ECHO imprimir SEMICOLON .

    VARIABLE        reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    ECHO            reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    PRINT           reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    INT             reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    FLOAT           reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    FUNCTION        reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    CLASS           reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    WHILE           reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    SWITCH          reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    IF              reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    FOR             reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    $end            reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    RBRACE          reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)
    BREAK           reduce using rule 11 (impresion -> ECHO imprimir SEMICOLON .)


state 67

    (94) imprimir -> LPAREN repiteValores . RPAREN

    RPAREN          shift and go to state 101


state 68

    (95) imprimir -> LPAREN RPAREN .

    SEMICOLON       reduce using rule 95 (imprimir -> LPAREN RPAREN .)


state 69

    (115) repiteValores -> valor COMMA . repiteValores
    (115) repiteValores -> . valor COMMA repiteValores
    (116) repiteValores -> . valor
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    valor                          shift and go to state 35
    repiteValores                  shift and go to state 102
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 70

    (73) funcionAnonima -> VARIABLE EQUALS . FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    FUNCTION        shift and go to state 103


state 71

    (72) funcionParen -> ID LPAREN . parametros RPAREN
    (63) parametros -> . parametro
    (64) parametros -> . parametro COMMA parametros
    (65) parametros -> . empty
    (66) parametro -> . ID
    (67) parametro -> . dataType ID
    (68) parametro -> . ID EQUALS valor
    (69) parametro -> . dataType ID EQUALS valor
    (131) empty -> .
    (106) dataType -> . INTEGER
    (107) dataType -> . FLOATING
    (108) dataType -> . STRINGS
    (109) dataType -> . BOOLEAN
    (110) dataType -> . VOID

    ID              shift and go to state 104
    RPAREN          reduce using rule 131 (empty -> .)
    INTEGER         shift and go to state 109
    FLOATING        shift and go to state 110
    STRINGS         shift and go to state 111
    BOOLEAN         shift and go to state 112
    VOID            shift and go to state 113

    parametros                     shift and go to state 105
    parametro                      shift and go to state 106
    empty                          shift and go to state 107
    dataType                       shift and go to state 108

state 72

    (12) impresion -> PRINT imprimir SEMICOLON .

    VARIABLE        reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    ECHO            reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    PRINT           reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    INT             reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    FLOAT           reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    FUNCTION        reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    CLASS           reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    WHILE           reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    SWITCH          reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    IF              reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    FOR             reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    $end            reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    RBRACE          reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)
    BREAK           reduce using rule 12 (impresion -> PRINT imprimir SEMICOLON .)


state 73

    (111) comparacion -> INT operador INT .

    VARIABLE        reduce using rule 111 (comparacion -> INT operador INT .)
    ECHO            reduce using rule 111 (comparacion -> INT operador INT .)
    PRINT           reduce using rule 111 (comparacion -> INT operador INT .)
    INT             reduce using rule 111 (comparacion -> INT operador INT .)
    FLOAT           reduce using rule 111 (comparacion -> INT operador INT .)
    FUNCTION        reduce using rule 111 (comparacion -> INT operador INT .)
    CLASS           reduce using rule 111 (comparacion -> INT operador INT .)
    WHILE           reduce using rule 111 (comparacion -> INT operador INT .)
    SWITCH          reduce using rule 111 (comparacion -> INT operador INT .)
    IF              reduce using rule 111 (comparacion -> INT operador INT .)
    FOR             reduce using rule 111 (comparacion -> INT operador INT .)
    $end            reduce using rule 111 (comparacion -> INT operador INT .)
    RBRACE          reduce using rule 111 (comparacion -> INT operador INT .)
    BREAK           reduce using rule 111 (comparacion -> INT operador INT .)


state 74

    (113) comparacion -> INT operador FLOAT .

    VARIABLE        reduce using rule 113 (comparacion -> INT operador FLOAT .)
    ECHO            reduce using rule 113 (comparacion -> INT operador FLOAT .)
    PRINT           reduce using rule 113 (comparacion -> INT operador FLOAT .)
    INT             reduce using rule 113 (comparacion -> INT operador FLOAT .)
    FLOAT           reduce using rule 113 (comparacion -> INT operador FLOAT .)
    FUNCTION        reduce using rule 113 (comparacion -> INT operador FLOAT .)
    CLASS           reduce using rule 113 (comparacion -> INT operador FLOAT .)
    WHILE           reduce using rule 113 (comparacion -> INT operador FLOAT .)
    SWITCH          reduce using rule 113 (comparacion -> INT operador FLOAT .)
    IF              reduce using rule 113 (comparacion -> INT operador FLOAT .)
    FOR             reduce using rule 113 (comparacion -> INT operador FLOAT .)
    $end            reduce using rule 113 (comparacion -> INT operador FLOAT .)
    RBRACE          reduce using rule 113 (comparacion -> INT operador FLOAT .)
    BREAK           reduce using rule 113 (comparacion -> INT operador FLOAT .)


state 75

    (112) comparacion -> FLOAT operador FLOAT .

    VARIABLE        reduce using rule 112 (comparacion -> FLOAT operador FLOAT .)
    ECHO            reduce using rule 112 (comparacion -> FLOAT operador FLOAT .)
    PRINT           reduce using rule 112 (comparacion -> FLOAT operador FLOAT .)
    INT             reduce using rule 112 (comparacion -> FLOAT operador FLOAT .)
    FLOAT           reduce using rule 112 (comparacion -> FLOAT operador FLOAT .)
    FUNCTION        reduce using rule 112 (comparacion -> FLOAT operador FLOAT .)
    CLASS           reduce using rule 112 (comparacion -> FLOAT operador FLOAT .)
    WHILE           reduce using rule 112 (comparacion -> FLOAT operador FLOAT .)
    SWITCH          reduce using rule 112 (comparacion -> FLOAT operador FLOAT .)
    IF              reduce using rule 112 (comparacion -> FLOAT operador FLOAT .)
    FOR             reduce using rule 112 (comparacion -> FLOAT operador FLOAT .)
    $end            reduce using rule 112 (comparacion -> FLOAT operador FLOAT .)
    RBRACE          reduce using rule 112 (comparacion -> FLOAT operador FLOAT .)
    BREAK           reduce using rule 112 (comparacion -> FLOAT operador FLOAT .)


state 76

    (114) comparacion -> FLOAT operador INT .

    VARIABLE        reduce using rule 114 (comparacion -> FLOAT operador INT .)
    ECHO            reduce using rule 114 (comparacion -> FLOAT operador INT .)
    PRINT           reduce using rule 114 (comparacion -> FLOAT operador INT .)
    INT             reduce using rule 114 (comparacion -> FLOAT operador INT .)
    FLOAT           reduce using rule 114 (comparacion -> FLOAT operador INT .)
    FUNCTION        reduce using rule 114 (comparacion -> FLOAT operador INT .)
    CLASS           reduce using rule 114 (comparacion -> FLOAT operador INT .)
    WHILE           reduce using rule 114 (comparacion -> FLOAT operador INT .)
    SWITCH          reduce using rule 114 (comparacion -> FLOAT operador INT .)
    IF              reduce using rule 114 (comparacion -> FLOAT operador INT .)
    FOR             reduce using rule 114 (comparacion -> FLOAT operador INT .)
    $end            reduce using rule 114 (comparacion -> FLOAT operador INT .)
    RBRACE          reduce using rule 114 (comparacion -> FLOAT operador INT .)
    BREAK           reduce using rule 114 (comparacion -> FLOAT operador INT .)


state 77

    (59) funcionDeclarate -> FUNCTION ID LPAREN . parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> FUNCTION ID LPAREN . parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (63) parametros -> . parametro
    (64) parametros -> . parametro COMMA parametros
    (65) parametros -> . empty
    (66) parametro -> . ID
    (67) parametro -> . dataType ID
    (68) parametro -> . ID EQUALS valor
    (69) parametro -> . dataType ID EQUALS valor
    (131) empty -> .
    (106) dataType -> . INTEGER
    (107) dataType -> . FLOATING
    (108) dataType -> . STRINGS
    (109) dataType -> . BOOLEAN
    (110) dataType -> . VOID

    ID              shift and go to state 104
    RPAREN          reduce using rule 131 (empty -> .)
    INTEGER         shift and go to state 109
    FLOATING        shift and go to state 110
    STRINGS         shift and go to state 111
    BOOLEAN         shift and go to state 112
    VOID            shift and go to state 113

    parametros                     shift and go to state 114
    dataType                       shift and go to state 108
    parametro                      shift and go to state 106
    empty                          shift and go to state 107

state 78

    (74) classDeclarate -> CLASS ID LBRACE . classBody RBRACE
    (76) classBody -> . classMember classBody
    (77) classBody -> . empty
    (78) classMember -> . dataType VARIABLE SEMICOLON
    (79) classMember -> . dataType FUNCTION ID LPAREN parametros RPAREN brace
    (131) empty -> .
    (106) dataType -> . INTEGER
    (107) dataType -> . FLOATING
    (108) dataType -> . STRINGS
    (109) dataType -> . BOOLEAN
    (110) dataType -> . VOID

    RBRACE          reduce using rule 131 (empty -> .)
    INTEGER         shift and go to state 109
    FLOATING        shift and go to state 110
    STRINGS         shift and go to state 111
    BOOLEAN         shift and go to state 112
    VOID            shift and go to state 113

    classBody                      shift and go to state 115
    classMember                    shift and go to state 116
    empty                          shift and go to state 117
    dataType                       shift and go to state 118

state 79

    (75) classDeclarate -> CLASS ID EXTENDS . ID LBRACE classBody RBRACE

    ID              shift and go to state 119


state 80

    (21) if -> statementif ELSE body .

    VARIABLE        reduce using rule 21 (if -> statementif ELSE body .)
    ECHO            reduce using rule 21 (if -> statementif ELSE body .)
    PRINT           reduce using rule 21 (if -> statementif ELSE body .)
    INT             reduce using rule 21 (if -> statementif ELSE body .)
    FLOAT           reduce using rule 21 (if -> statementif ELSE body .)
    FUNCTION        reduce using rule 21 (if -> statementif ELSE body .)
    CLASS           reduce using rule 21 (if -> statementif ELSE body .)
    WHILE           reduce using rule 21 (if -> statementif ELSE body .)
    SWITCH          reduce using rule 21 (if -> statementif ELSE body .)
    IF              reduce using rule 21 (if -> statementif ELSE body .)
    FOR             reduce using rule 21 (if -> statementif ELSE body .)
    $end            reduce using rule 21 (if -> statementif ELSE body .)
    RBRACE          reduce using rule 21 (if -> statementif ELSE body .)
    BREAK           reduce using rule 21 (if -> statementif ELSE body .)


state 81

    (22) if -> statementif ELSE if .
    (17) controlStructure -> if .

  ! reduce/reduce conflict for VARIABLE resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for ECHO resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for PRINT resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for INT resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for FLOAT resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for CLASS resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for WHILE resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for SWITCH resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for IF resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for FOR resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for $end resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for RBRACE resolved using rule 17 (controlStructure -> if .)
  ! reduce/reduce conflict for BREAK resolved using rule 17 (controlStructure -> if .)
    VARIABLE        reduce using rule 17 (controlStructure -> if .)
    ECHO            reduce using rule 17 (controlStructure -> if .)
    PRINT           reduce using rule 17 (controlStructure -> if .)
    INT             reduce using rule 17 (controlStructure -> if .)
    FLOAT           reduce using rule 17 (controlStructure -> if .)
    FUNCTION        reduce using rule 17 (controlStructure -> if .)
    CLASS           reduce using rule 17 (controlStructure -> if .)
    WHILE           reduce using rule 17 (controlStructure -> if .)
    SWITCH          reduce using rule 17 (controlStructure -> if .)
    IF              reduce using rule 17 (controlStructure -> if .)
    FOR             reduce using rule 17 (controlStructure -> if .)
    $end            reduce using rule 17 (controlStructure -> if .)
    RBRACE          reduce using rule 17 (controlStructure -> if .)
    BREAK           reduce using rule 17 (controlStructure -> if .)

  ! VARIABLE        [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! ECHO            [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! PRINT           [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! INT             [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! FLOAT           [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! FUNCTION        [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! CLASS           [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! WHILE           [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! SWITCH          [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! IF              [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! FOR             [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! $end            [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! RBRACE          [ reduce using rule 22 (if -> statementif ELSE if .) ]
  ! BREAK           [ reduce using rule 22 (if -> statementif ELSE if .) ]


state 82

    (91) body -> sentencia .
    (92) body -> sentencia . sentencias
    (7) sentencias -> . sentencia
    (8) sentencias -> . sentencia sentencias
    (9) sentencias -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (131) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (111) comparacion -> . INT operador INT
    (112) comparacion -> . FLOAT operador FLOAT
    (113) comparacion -> . INT operador FLOAT
    (114) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (74) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (75) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (82) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

  ! reduce/reduce conflict for VARIABLE resolved using rule 91 (body -> sentencia .)
  ! reduce/reduce conflict for ECHO resolved using rule 91 (body -> sentencia .)
  ! reduce/reduce conflict for PRINT resolved using rule 91 (body -> sentencia .)
  ! reduce/reduce conflict for INT resolved using rule 91 (body -> sentencia .)
  ! reduce/reduce conflict for FLOAT resolved using rule 91 (body -> sentencia .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 91 (body -> sentencia .)
  ! reduce/reduce conflict for CLASS resolved using rule 91 (body -> sentencia .)
  ! reduce/reduce conflict for WHILE resolved using rule 91 (body -> sentencia .)
  ! reduce/reduce conflict for SWITCH resolved using rule 91 (body -> sentencia .)
  ! reduce/reduce conflict for IF resolved using rule 91 (body -> sentencia .)
  ! reduce/reduce conflict for FOR resolved using rule 91 (body -> sentencia .)
  ! reduce/reduce conflict for $end resolved using rule 91 (body -> sentencia .)
  ! reduce/reduce conflict for RBRACE resolved using rule 91 (body -> sentencia .)
  ! reduce/reduce conflict for BREAK resolved using rule 91 (body -> sentencia .)
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    $end            reduce using rule 91 (body -> sentencia .)
    RBRACE          reduce using rule 91 (body -> sentencia .)
    BREAK           reduce using rule 91 (body -> sentencia .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

  ! VARIABLE        [ reduce using rule 91 (body -> sentencia .) ]
  ! ECHO            [ reduce using rule 91 (body -> sentencia .) ]
  ! PRINT           [ reduce using rule 91 (body -> sentencia .) ]
  ! INT             [ reduce using rule 91 (body -> sentencia .) ]
  ! FLOAT           [ reduce using rule 91 (body -> sentencia .) ]
  ! FUNCTION        [ reduce using rule 91 (body -> sentencia .) ]
  ! CLASS           [ reduce using rule 91 (body -> sentencia .) ]
  ! WHILE           [ reduce using rule 91 (body -> sentencia .) ]
  ! SWITCH          [ reduce using rule 91 (body -> sentencia .) ]
  ! IF              [ reduce using rule 91 (body -> sentencia .) ]
  ! FOR             [ reduce using rule 91 (body -> sentencia .) ]
  ! VARIABLE        [ reduce using rule 131 (empty -> .) ]
  ! ECHO            [ reduce using rule 131 (empty -> .) ]
  ! PRINT           [ reduce using rule 131 (empty -> .) ]
  ! INT             [ reduce using rule 131 (empty -> .) ]
  ! FLOAT           [ reduce using rule 131 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 131 (empty -> .) ]
  ! CLASS           [ reduce using rule 131 (empty -> .) ]
  ! WHILE           [ reduce using rule 131 (empty -> .) ]
  ! SWITCH          [ reduce using rule 131 (empty -> .) ]
  ! IF              [ reduce using rule 131 (empty -> .) ]
  ! FOR             [ reduce using rule 131 (empty -> .) ]
  ! $end            [ reduce using rule 131 (empty -> .) ]
  ! RBRACE          [ reduce using rule 131 (empty -> .) ]
  ! BREAK           [ reduce using rule 131 (empty -> .) ]

    sentencia                      shift and go to state 120
    sentencias                     shift and go to state 121
    empty                          shift and go to state 122
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 83

    (93) body -> empty .

    VARIABLE        reduce using rule 93 (body -> empty .)
    ECHO            reduce using rule 93 (body -> empty .)
    PRINT           reduce using rule 93 (body -> empty .)
    INT             reduce using rule 93 (body -> empty .)
    FLOAT           reduce using rule 93 (body -> empty .)
    FUNCTION        reduce using rule 93 (body -> empty .)
    CLASS           reduce using rule 93 (body -> empty .)
    WHILE           reduce using rule 93 (body -> empty .)
    SWITCH          reduce using rule 93 (body -> empty .)
    IF              reduce using rule 93 (body -> empty .)
    FOR             reduce using rule 93 (body -> empty .)
    $end            reduce using rule 93 (body -> empty .)
    RBRACE          reduce using rule 93 (body -> empty .)
    BREAK           reduce using rule 93 (body -> empty .)


state 84

    (23) if -> statementif ELSEIF if .

    VARIABLE        reduce using rule 23 (if -> statementif ELSEIF if .)
    ECHO            reduce using rule 23 (if -> statementif ELSEIF if .)
    PRINT           reduce using rule 23 (if -> statementif ELSEIF if .)
    INT             reduce using rule 23 (if -> statementif ELSEIF if .)
    FLOAT           reduce using rule 23 (if -> statementif ELSEIF if .)
    FUNCTION        reduce using rule 23 (if -> statementif ELSEIF if .)
    CLASS           reduce using rule 23 (if -> statementif ELSEIF if .)
    WHILE           reduce using rule 23 (if -> statementif ELSEIF if .)
    SWITCH          reduce using rule 23 (if -> statementif ELSEIF if .)
    IF              reduce using rule 23 (if -> statementif ELSEIF if .)
    FOR             reduce using rule 23 (if -> statementif ELSEIF if .)
    $end            reduce using rule 23 (if -> statementif ELSEIF if .)
    RBRACE          reduce using rule 23 (if -> statementif ELSEIF if .)
    BREAK           reduce using rule 23 (if -> statementif ELSEIF if .)


state 85

    (29) condition -> LPAREN . conditionProdu RPAREN
    (26) conditionProdu -> . condition
    (27) conditionProdu -> . condition opLogic conditionProdu
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 85
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    conditionProdu                 shift and go to state 123
    condition                      shift and go to state 90
    valor                          shift and go to state 87
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 86

    (45) while -> WHILE LPAREN condition . RPAREN LBRACE body RBRACE
    (46) while -> WHILE LPAREN condition . RPAREN LBRACE RBRACE

    RPAREN          shift and go to state 124


state 87

    (28) condition -> valor . opSymbol valor
    (30) opSymbol -> . EQ
    (31) opSymbol -> . NEQ
    (32) opSymbol -> . STRICTEQ
    (33) opSymbol -> . STRICTNEQ
    (34) opSymbol -> . LT
    (35) opSymbol -> . GT
    (36) opSymbol -> . LEQ
    (37) opSymbol -> . GEQ

    EQ              shift and go to state 126
    NEQ             shift and go to state 127
    STRICTEQ        shift and go to state 128
    STRICTNEQ       shift and go to state 129
    LT              shift and go to state 130
    GT              shift and go to state 131
    LEQ             shift and go to state 132
    GEQ             shift and go to state 133

    opSymbol                       shift and go to state 125

state 88

    (47) switch -> SWITCH LPAREN condition . RPAREN LBRACE caseLists RBRACE
    (48) switch -> SWITCH LPAREN condition . RPAREN LBRACE RBRACE

    RPAREN          shift and go to state 134


state 89

    (25) statementif -> IF LPAREN conditionProdu . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 135


state 90

    (26) conditionProdu -> condition .
    (27) conditionProdu -> condition . opLogic conditionProdu
    (38) opLogic -> . AND
    (39) opLogic -> . OR
    (40) opLogic -> . NOT

    RPAREN          reduce using rule 26 (conditionProdu -> condition .)
    QUESTION        reduce using rule 26 (conditionProdu -> condition .)
    SEMICOLON       reduce using rule 26 (conditionProdu -> condition .)
    COLON           reduce using rule 26 (conditionProdu -> condition .)
    AND             shift and go to state 137
    OR              shift and go to state 138
    NOT             shift and go to state 139

    opLogic                        shift and go to state 136

state 91

    (42) forStatement -> FOR LPAREN forcondition . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 140


state 92

    (43) forcondition -> VARIABLE . EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE . EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    EQUALS          shift and go to state 141


state 93

    (10) asignacion -> VARIABLE EQUALS operaArit SEMICOLON .

    VARIABLE        reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    ECHO            reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    PRINT           reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    INT             reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    FLOAT           reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    FUNCTION        reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    CLASS           reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    WHILE           reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    SWITCH          reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    IF              reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    FOR             reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    $end            reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    RBRACE          reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)
    BREAK           reduce using rule 10 (asignacion -> VARIABLE EQUALS operaArit SEMICOLON .)


state 94

    (82) array -> VARIABLE EQUALS LBRACKET repiteValores . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 142


state 95

    (85) array -> VARIABLE EQUALS LBRACKET mapProduc . RBRACKET SEMICOLON
    (86) map -> VARIABLE EQUALS LBRACKET mapProduc . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 143


state 96

    (115) repiteValores -> valor . COMMA repiteValores
    (116) repiteValores -> valor .
    (90) mapArrow -> valor . ARROWMAP valor

    COMMA           shift and go to state 69
    RBRACKET        reduce using rule 116 (repiteValores -> valor .)
    RPAREN          reduce using rule 116 (repiteValores -> valor .)
    ARROWMAP        shift and go to state 144


state 97

    (88) mapProduc -> mapArrow .
    (89) mapProduc -> mapArrow . COMMA mapProduc

    RBRACKET        reduce using rule 88 (mapProduc -> mapArrow .)
    RPAREN          reduce using rule 88 (mapProduc -> mapArrow .)
    COMMA           shift and go to state 145


state 98

    (83) array -> VARIABLE EQUALS ARRAY LPAREN . repiteValores RPAREN SEMICOLON
    (84) array -> VARIABLE EQUALS ARRAY LPAREN . mapProduc RPAREN SEMICOLON
    (87) map -> VARIABLE EQUALS ARRAY LPAREN . mapProduc RPAREN SEMICOLON
    (115) repiteValores -> . valor COMMA repiteValores
    (116) repiteValores -> . valor
    (88) mapProduc -> . mapArrow
    (89) mapProduc -> . mapArrow COMMA mapProduc
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (90) mapArrow -> . valor ARROWMAP valor
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    repiteValores                  shift and go to state 146
    mapProduc                      shift and go to state 147
    valor                          shift and go to state 96
    mapArrow                       shift and go to state 97
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 99

    (118) operaArit -> valor operador . operaArit
    (117) operaArit -> . valor
    (118) operaArit -> . valor operador operaArit
    (119) operaArit -> . valor DOT valor
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    valor                          shift and go to state 65
    operaArit                      shift and go to state 148
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 100

    (119) operaArit -> valor DOT . valor
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    valor                          shift and go to state 149
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 101

    (94) imprimir -> LPAREN repiteValores RPAREN .

    SEMICOLON       reduce using rule 94 (imprimir -> LPAREN repiteValores RPAREN .)


state 102

    (115) repiteValores -> valor COMMA repiteValores .

    SEMICOLON       reduce using rule 115 (repiteValores -> valor COMMA repiteValores .)
    RPAREN          reduce using rule 115 (repiteValores -> valor COMMA repiteValores .)
    RBRACKET        reduce using rule 115 (repiteValores -> valor COMMA repiteValores .)


state 103

    (73) funcionAnonima -> VARIABLE EQUALS FUNCTION . LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 150


state 104

    (66) parametro -> ID .
    (68) parametro -> ID . EQUALS valor

    COMMA           reduce using rule 66 (parametro -> ID .)
    RPAREN          reduce using rule 66 (parametro -> ID .)
    EQUALS          shift and go to state 151


state 105

    (72) funcionParen -> ID LPAREN parametros . RPAREN

    RPAREN          shift and go to state 152


state 106

    (63) parametros -> parametro .
    (64) parametros -> parametro . COMMA parametros

    RPAREN          reduce using rule 63 (parametros -> parametro .)
    COMMA           shift and go to state 153


state 107

    (65) parametros -> empty .

    RPAREN          reduce using rule 65 (parametros -> empty .)


state 108

    (67) parametro -> dataType . ID
    (69) parametro -> dataType . ID EQUALS valor

    ID              shift and go to state 154


state 109

    (106) dataType -> INTEGER .

    ID              reduce using rule 106 (dataType -> INTEGER .)
    VARIABLE        reduce using rule 106 (dataType -> INTEGER .)
    FUNCTION        reduce using rule 106 (dataType -> INTEGER .)
    LBRACE          reduce using rule 106 (dataType -> INTEGER .)


state 110

    (107) dataType -> FLOATING .

    ID              reduce using rule 107 (dataType -> FLOATING .)
    VARIABLE        reduce using rule 107 (dataType -> FLOATING .)
    FUNCTION        reduce using rule 107 (dataType -> FLOATING .)
    LBRACE          reduce using rule 107 (dataType -> FLOATING .)


state 111

    (108) dataType -> STRINGS .

    ID              reduce using rule 108 (dataType -> STRINGS .)
    VARIABLE        reduce using rule 108 (dataType -> STRINGS .)
    FUNCTION        reduce using rule 108 (dataType -> STRINGS .)
    LBRACE          reduce using rule 108 (dataType -> STRINGS .)


state 112

    (109) dataType -> BOOLEAN .

    ID              reduce using rule 109 (dataType -> BOOLEAN .)
    VARIABLE        reduce using rule 109 (dataType -> BOOLEAN .)
    FUNCTION        reduce using rule 109 (dataType -> BOOLEAN .)
    LBRACE          reduce using rule 109 (dataType -> BOOLEAN .)


state 113

    (110) dataType -> VOID .

    ID              reduce using rule 110 (dataType -> VOID .)
    VARIABLE        reduce using rule 110 (dataType -> VOID .)
    FUNCTION        reduce using rule 110 (dataType -> VOID .)
    LBRACE          reduce using rule 110 (dataType -> VOID .)


state 114

    (59) funcionDeclarate -> FUNCTION ID LPAREN parametros . RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> FUNCTION ID LPAREN parametros . RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE

    RPAREN          shift and go to state 155


state 115

    (74) classDeclarate -> CLASS ID LBRACE classBody . RBRACE

    RBRACE          shift and go to state 156


state 116

    (76) classBody -> classMember . classBody
    (76) classBody -> . classMember classBody
    (77) classBody -> . empty
    (78) classMember -> . dataType VARIABLE SEMICOLON
    (79) classMember -> . dataType FUNCTION ID LPAREN parametros RPAREN brace
    (131) empty -> .
    (106) dataType -> . INTEGER
    (107) dataType -> . FLOATING
    (108) dataType -> . STRINGS
    (109) dataType -> . BOOLEAN
    (110) dataType -> . VOID

    RBRACE          reduce using rule 131 (empty -> .)
    INTEGER         shift and go to state 109
    FLOATING        shift and go to state 110
    STRINGS         shift and go to state 111
    BOOLEAN         shift and go to state 112
    VOID            shift and go to state 113

    classMember                    shift and go to state 116
    classBody                      shift and go to state 157
    empty                          shift and go to state 117
    dataType                       shift and go to state 118

state 117

    (77) classBody -> empty .

    RBRACE          reduce using rule 77 (classBody -> empty .)


state 118

    (78) classMember -> dataType . VARIABLE SEMICOLON
    (79) classMember -> dataType . FUNCTION ID LPAREN parametros RPAREN brace

    VARIABLE        shift and go to state 158
    FUNCTION        shift and go to state 159


state 119

    (75) classDeclarate -> CLASS ID EXTENDS ID . LBRACE classBody RBRACE

    LBRACE          shift and go to state 160


state 120

    (7) sentencias -> sentencia .
    (8) sentencias -> sentencia . sentencias
    (7) sentencias -> . sentencia
    (8) sentencias -> . sentencia sentencias
    (9) sentencias -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (131) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (111) comparacion -> . INT operador INT
    (112) comparacion -> . FLOAT operador FLOAT
    (113) comparacion -> . INT operador FLOAT
    (114) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (74) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (75) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (82) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

  ! reduce/reduce conflict for VARIABLE resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for ECHO resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for PRINT resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for INT resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for FLOAT resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for CLASS resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for WHILE resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for SWITCH resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for IF resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for FOR resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for $end resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for RBRACE resolved using rule 7 (sentencias -> sentencia .)
  ! reduce/reduce conflict for BREAK resolved using rule 7 (sentencias -> sentencia .)
  ! shift/reduce conflict for VARIABLE resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    $end            reduce using rule 7 (sentencias -> sentencia .)
    RBRACE          reduce using rule 7 (sentencias -> sentencia .)
    BREAK           reduce using rule 7 (sentencias -> sentencia .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

  ! VARIABLE        [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! ECHO            [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! PRINT           [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! INT             [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! FLOAT           [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! FUNCTION        [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! CLASS           [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! WHILE           [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! SWITCH          [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! IF              [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! FOR             [ reduce using rule 7 (sentencias -> sentencia .) ]
  ! VARIABLE        [ reduce using rule 131 (empty -> .) ]
  ! ECHO            [ reduce using rule 131 (empty -> .) ]
  ! PRINT           [ reduce using rule 131 (empty -> .) ]
  ! INT             [ reduce using rule 131 (empty -> .) ]
  ! FLOAT           [ reduce using rule 131 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 131 (empty -> .) ]
  ! CLASS           [ reduce using rule 131 (empty -> .) ]
  ! WHILE           [ reduce using rule 131 (empty -> .) ]
  ! SWITCH          [ reduce using rule 131 (empty -> .) ]
  ! IF              [ reduce using rule 131 (empty -> .) ]
  ! FOR             [ reduce using rule 131 (empty -> .) ]
  ! $end            [ reduce using rule 131 (empty -> .) ]
  ! RBRACE          [ reduce using rule 131 (empty -> .) ]
  ! BREAK           [ reduce using rule 131 (empty -> .) ]

    sentencia                      shift and go to state 120
    sentencias                     shift and go to state 161
    empty                          shift and go to state 122
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 121

    (92) body -> sentencia sentencias .

    VARIABLE        reduce using rule 92 (body -> sentencia sentencias .)
    ECHO            reduce using rule 92 (body -> sentencia sentencias .)
    PRINT           reduce using rule 92 (body -> sentencia sentencias .)
    INT             reduce using rule 92 (body -> sentencia sentencias .)
    FLOAT           reduce using rule 92 (body -> sentencia sentencias .)
    FUNCTION        reduce using rule 92 (body -> sentencia sentencias .)
    CLASS           reduce using rule 92 (body -> sentencia sentencias .)
    WHILE           reduce using rule 92 (body -> sentencia sentencias .)
    SWITCH          reduce using rule 92 (body -> sentencia sentencias .)
    IF              reduce using rule 92 (body -> sentencia sentencias .)
    FOR             reduce using rule 92 (body -> sentencia sentencias .)
    $end            reduce using rule 92 (body -> sentencia sentencias .)
    RBRACE          reduce using rule 92 (body -> sentencia sentencias .)
    BREAK           reduce using rule 92 (body -> sentencia sentencias .)


state 122

    (9) sentencias -> empty .

    VARIABLE        reduce using rule 9 (sentencias -> empty .)
    ECHO            reduce using rule 9 (sentencias -> empty .)
    PRINT           reduce using rule 9 (sentencias -> empty .)
    INT             reduce using rule 9 (sentencias -> empty .)
    FLOAT           reduce using rule 9 (sentencias -> empty .)
    FUNCTION        reduce using rule 9 (sentencias -> empty .)
    CLASS           reduce using rule 9 (sentencias -> empty .)
    WHILE           reduce using rule 9 (sentencias -> empty .)
    SWITCH          reduce using rule 9 (sentencias -> empty .)
    IF              reduce using rule 9 (sentencias -> empty .)
    FOR             reduce using rule 9 (sentencias -> empty .)
    $end            reduce using rule 9 (sentencias -> empty .)
    RBRACE          reduce using rule 9 (sentencias -> empty .)
    BREAK           reduce using rule 9 (sentencias -> empty .)


state 123

    (29) condition -> LPAREN conditionProdu . RPAREN

    RPAREN          shift and go to state 162


state 124

    (45) while -> WHILE LPAREN condition RPAREN . LBRACE body RBRACE
    (46) while -> WHILE LPAREN condition RPAREN . LBRACE RBRACE

    LBRACE          shift and go to state 163


state 125

    (28) condition -> valor opSymbol . valor
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    valor                          shift and go to state 164
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 126

    (30) opSymbol -> EQ .

    INT             reduce using rule 30 (opSymbol -> EQ .)
    FLOAT           reduce using rule 30 (opSymbol -> EQ .)
    VARIABLE        reduce using rule 30 (opSymbol -> EQ .)
    STRING          reduce using rule 30 (opSymbol -> EQ .)
    TRUE            reduce using rule 30 (opSymbol -> EQ .)
    FALSE           reduce using rule 30 (opSymbol -> EQ .)
    THIS            reduce using rule 30 (opSymbol -> EQ .)
    ID              reduce using rule 30 (opSymbol -> EQ .)


state 127

    (31) opSymbol -> NEQ .

    INT             reduce using rule 31 (opSymbol -> NEQ .)
    FLOAT           reduce using rule 31 (opSymbol -> NEQ .)
    VARIABLE        reduce using rule 31 (opSymbol -> NEQ .)
    STRING          reduce using rule 31 (opSymbol -> NEQ .)
    TRUE            reduce using rule 31 (opSymbol -> NEQ .)
    FALSE           reduce using rule 31 (opSymbol -> NEQ .)
    THIS            reduce using rule 31 (opSymbol -> NEQ .)
    ID              reduce using rule 31 (opSymbol -> NEQ .)


state 128

    (32) opSymbol -> STRICTEQ .

    INT             reduce using rule 32 (opSymbol -> STRICTEQ .)
    FLOAT           reduce using rule 32 (opSymbol -> STRICTEQ .)
    VARIABLE        reduce using rule 32 (opSymbol -> STRICTEQ .)
    STRING          reduce using rule 32 (opSymbol -> STRICTEQ .)
    TRUE            reduce using rule 32 (opSymbol -> STRICTEQ .)
    FALSE           reduce using rule 32 (opSymbol -> STRICTEQ .)
    THIS            reduce using rule 32 (opSymbol -> STRICTEQ .)
    ID              reduce using rule 32 (opSymbol -> STRICTEQ .)


state 129

    (33) opSymbol -> STRICTNEQ .

    INT             reduce using rule 33 (opSymbol -> STRICTNEQ .)
    FLOAT           reduce using rule 33 (opSymbol -> STRICTNEQ .)
    VARIABLE        reduce using rule 33 (opSymbol -> STRICTNEQ .)
    STRING          reduce using rule 33 (opSymbol -> STRICTNEQ .)
    TRUE            reduce using rule 33 (opSymbol -> STRICTNEQ .)
    FALSE           reduce using rule 33 (opSymbol -> STRICTNEQ .)
    THIS            reduce using rule 33 (opSymbol -> STRICTNEQ .)
    ID              reduce using rule 33 (opSymbol -> STRICTNEQ .)


state 130

    (34) opSymbol -> LT .

    INT             reduce using rule 34 (opSymbol -> LT .)
    FLOAT           reduce using rule 34 (opSymbol -> LT .)
    VARIABLE        reduce using rule 34 (opSymbol -> LT .)
    STRING          reduce using rule 34 (opSymbol -> LT .)
    TRUE            reduce using rule 34 (opSymbol -> LT .)
    FALSE           reduce using rule 34 (opSymbol -> LT .)
    THIS            reduce using rule 34 (opSymbol -> LT .)
    ID              reduce using rule 34 (opSymbol -> LT .)


state 131

    (35) opSymbol -> GT .

    INT             reduce using rule 35 (opSymbol -> GT .)
    FLOAT           reduce using rule 35 (opSymbol -> GT .)
    VARIABLE        reduce using rule 35 (opSymbol -> GT .)
    STRING          reduce using rule 35 (opSymbol -> GT .)
    TRUE            reduce using rule 35 (opSymbol -> GT .)
    FALSE           reduce using rule 35 (opSymbol -> GT .)
    THIS            reduce using rule 35 (opSymbol -> GT .)
    ID              reduce using rule 35 (opSymbol -> GT .)


state 132

    (36) opSymbol -> LEQ .

    INT             reduce using rule 36 (opSymbol -> LEQ .)
    FLOAT           reduce using rule 36 (opSymbol -> LEQ .)
    VARIABLE        reduce using rule 36 (opSymbol -> LEQ .)
    STRING          reduce using rule 36 (opSymbol -> LEQ .)
    TRUE            reduce using rule 36 (opSymbol -> LEQ .)
    FALSE           reduce using rule 36 (opSymbol -> LEQ .)
    THIS            reduce using rule 36 (opSymbol -> LEQ .)
    ID              reduce using rule 36 (opSymbol -> LEQ .)


state 133

    (37) opSymbol -> GEQ .

    INT             reduce using rule 37 (opSymbol -> GEQ .)
    FLOAT           reduce using rule 37 (opSymbol -> GEQ .)
    VARIABLE        reduce using rule 37 (opSymbol -> GEQ .)
    STRING          reduce using rule 37 (opSymbol -> GEQ .)
    TRUE            reduce using rule 37 (opSymbol -> GEQ .)
    FALSE           reduce using rule 37 (opSymbol -> GEQ .)
    THIS            reduce using rule 37 (opSymbol -> GEQ .)
    ID              reduce using rule 37 (opSymbol -> GEQ .)


state 134

    (47) switch -> SWITCH LPAREN condition RPAREN . LBRACE caseLists RBRACE
    (48) switch -> SWITCH LPAREN condition RPAREN . LBRACE RBRACE

    LBRACE          shift and go to state 165


state 135

    (25) statementif -> IF LPAREN conditionProdu RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 166


state 136

    (27) conditionProdu -> condition opLogic . conditionProdu
    (26) conditionProdu -> . condition
    (27) conditionProdu -> . condition opLogic conditionProdu
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LPAREN          shift and go to state 85
    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    condition                      shift and go to state 90
    conditionProdu                 shift and go to state 167
    valor                          shift and go to state 87
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 137

    (38) opLogic -> AND .

    LPAREN          reduce using rule 38 (opLogic -> AND .)
    INT             reduce using rule 38 (opLogic -> AND .)
    FLOAT           reduce using rule 38 (opLogic -> AND .)
    VARIABLE        reduce using rule 38 (opLogic -> AND .)
    STRING          reduce using rule 38 (opLogic -> AND .)
    TRUE            reduce using rule 38 (opLogic -> AND .)
    FALSE           reduce using rule 38 (opLogic -> AND .)
    THIS            reduce using rule 38 (opLogic -> AND .)
    ID              reduce using rule 38 (opLogic -> AND .)


state 138

    (39) opLogic -> OR .

    LPAREN          reduce using rule 39 (opLogic -> OR .)
    INT             reduce using rule 39 (opLogic -> OR .)
    FLOAT           reduce using rule 39 (opLogic -> OR .)
    VARIABLE        reduce using rule 39 (opLogic -> OR .)
    STRING          reduce using rule 39 (opLogic -> OR .)
    TRUE            reduce using rule 39 (opLogic -> OR .)
    FALSE           reduce using rule 39 (opLogic -> OR .)
    THIS            reduce using rule 39 (opLogic -> OR .)
    ID              reduce using rule 39 (opLogic -> OR .)


state 139

    (40) opLogic -> NOT .

    LPAREN          reduce using rule 40 (opLogic -> NOT .)
    INT             reduce using rule 40 (opLogic -> NOT .)
    FLOAT           reduce using rule 40 (opLogic -> NOT .)
    VARIABLE        reduce using rule 40 (opLogic -> NOT .)
    STRING          reduce using rule 40 (opLogic -> NOT .)
    TRUE            reduce using rule 40 (opLogic -> NOT .)
    FALSE           reduce using rule 40 (opLogic -> NOT .)
    THIS            reduce using rule 40 (opLogic -> NOT .)
    ID              reduce using rule 40 (opLogic -> NOT .)


state 140

    (42) forStatement -> FOR LPAREN forcondition RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 168


state 141

    (43) forcondition -> VARIABLE EQUALS . INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS . INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    INT             shift and go to state 169


state 142

    (82) array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 170


state 143

    (85) array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET . SEMICOLON
    (86) map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 171


state 144

    (90) mapArrow -> valor ARROWMAP . valor
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    valor                          shift and go to state 172
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 145

    (89) mapProduc -> mapArrow COMMA . mapProduc
    (88) mapProduc -> . mapArrow
    (89) mapProduc -> . mapArrow COMMA mapProduc
    (90) mapArrow -> . valor ARROWMAP valor
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    mapArrow                       shift and go to state 97
    mapProduc                      shift and go to state 173
    valor                          shift and go to state 174
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 146

    (83) array -> VARIABLE EQUALS ARRAY LPAREN repiteValores . RPAREN SEMICOLON

    RPAREN          shift and go to state 175


state 147

    (84) array -> VARIABLE EQUALS ARRAY LPAREN mapProduc . RPAREN SEMICOLON
    (87) map -> VARIABLE EQUALS ARRAY LPAREN mapProduc . RPAREN SEMICOLON

    RPAREN          shift and go to state 176


state 148

    (118) operaArit -> valor operador operaArit .

    SEMICOLON       reduce using rule 118 (operaArit -> valor operador operaArit .)
    COLON           reduce using rule 118 (operaArit -> valor operador operaArit .)


state 149

    (119) operaArit -> valor DOT valor .

    SEMICOLON       reduce using rule 119 (operaArit -> valor DOT valor .)
    COLON           reduce using rule 119 (operaArit -> valor DOT valor .)


state 150

    (73) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN . parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON
    (63) parametros -> . parametro
    (64) parametros -> . parametro COMMA parametros
    (65) parametros -> . empty
    (66) parametro -> . ID
    (67) parametro -> . dataType ID
    (68) parametro -> . ID EQUALS valor
    (69) parametro -> . dataType ID EQUALS valor
    (131) empty -> .
    (106) dataType -> . INTEGER
    (107) dataType -> . FLOATING
    (108) dataType -> . STRINGS
    (109) dataType -> . BOOLEAN
    (110) dataType -> . VOID

    ID              shift and go to state 104
    RPAREN          reduce using rule 131 (empty -> .)
    INTEGER         shift and go to state 109
    FLOATING        shift and go to state 110
    STRINGS         shift and go to state 111
    BOOLEAN         shift and go to state 112
    VOID            shift and go to state 113

    parametros                     shift and go to state 177
    parametro                      shift and go to state 106
    empty                          shift and go to state 107
    dataType                       shift and go to state 108

state 151

    (68) parametro -> ID EQUALS . valor
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    valor                          shift and go to state 178
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 152

    (72) funcionParen -> ID LPAREN parametros RPAREN .

    COMMA           reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    SEMICOLON       reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    DOT             reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    PLUS            reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    MINUS           reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    TIMES           reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    DIVIDE          reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    MODULO          reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    RPAREN          reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    EQ              reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    NEQ             reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    STRICTEQ        reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    STRICTNEQ       reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    LT              reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    GT              reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    LEQ             reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    GEQ             reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    ARROWMAP        reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    RBRACKET        reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    COLON           reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    AND             reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    OR              reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    NOT             reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)
    QUESTION        reduce using rule 72 (funcionParen -> ID LPAREN parametros RPAREN .)


state 153

    (64) parametros -> parametro COMMA . parametros
    (63) parametros -> . parametro
    (64) parametros -> . parametro COMMA parametros
    (65) parametros -> . empty
    (66) parametro -> . ID
    (67) parametro -> . dataType ID
    (68) parametro -> . ID EQUALS valor
    (69) parametro -> . dataType ID EQUALS valor
    (131) empty -> .
    (106) dataType -> . INTEGER
    (107) dataType -> . FLOATING
    (108) dataType -> . STRINGS
    (109) dataType -> . BOOLEAN
    (110) dataType -> . VOID

    ID              shift and go to state 104
    RPAREN          reduce using rule 131 (empty -> .)
    INTEGER         shift and go to state 109
    FLOATING        shift and go to state 110
    STRINGS         shift and go to state 111
    BOOLEAN         shift and go to state 112
    VOID            shift and go to state 113

    parametro                      shift and go to state 106
    parametros                     shift and go to state 179
    empty                          shift and go to state 107
    dataType                       shift and go to state 108

state 154

    (67) parametro -> dataType ID .
    (69) parametro -> dataType ID . EQUALS valor

    COMMA           reduce using rule 67 (parametro -> dataType ID .)
    RPAREN          reduce using rule 67 (parametro -> dataType ID .)
    EQUALS          shift and go to state 180


state 155

    (59) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN . LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN . DOUBLEDOT dataType LBRACE funcionBody RBRACE

    LBRACE          shift and go to state 181
    DOUBLEDOT       shift and go to state 182


state 156

    (74) classDeclarate -> CLASS ID LBRACE classBody RBRACE .

    VARIABLE        reduce using rule 74 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    ECHO            reduce using rule 74 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    PRINT           reduce using rule 74 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    INT             reduce using rule 74 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    FLOAT           reduce using rule 74 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    FUNCTION        reduce using rule 74 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    CLASS           reduce using rule 74 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    WHILE           reduce using rule 74 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    SWITCH          reduce using rule 74 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    IF              reduce using rule 74 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    FOR             reduce using rule 74 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    $end            reduce using rule 74 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    RBRACE          reduce using rule 74 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)
    BREAK           reduce using rule 74 (classDeclarate -> CLASS ID LBRACE classBody RBRACE .)


state 157

    (76) classBody -> classMember classBody .

    RBRACE          reduce using rule 76 (classBody -> classMember classBody .)


state 158

    (78) classMember -> dataType VARIABLE . SEMICOLON

    SEMICOLON       shift and go to state 183


state 159

    (79) classMember -> dataType FUNCTION . ID LPAREN parametros RPAREN brace

    ID              shift and go to state 184


state 160

    (75) classDeclarate -> CLASS ID EXTENDS ID LBRACE . classBody RBRACE
    (76) classBody -> . classMember classBody
    (77) classBody -> . empty
    (78) classMember -> . dataType VARIABLE SEMICOLON
    (79) classMember -> . dataType FUNCTION ID LPAREN parametros RPAREN brace
    (131) empty -> .
    (106) dataType -> . INTEGER
    (107) dataType -> . FLOATING
    (108) dataType -> . STRINGS
    (109) dataType -> . BOOLEAN
    (110) dataType -> . VOID

    RBRACE          reduce using rule 131 (empty -> .)
    INTEGER         shift and go to state 109
    FLOATING        shift and go to state 110
    STRINGS         shift and go to state 111
    BOOLEAN         shift and go to state 112
    VOID            shift and go to state 113

    classBody                      shift and go to state 185
    classMember                    shift and go to state 116
    empty                          shift and go to state 117
    dataType                       shift and go to state 118

state 161

    (8) sentencias -> sentencia sentencias .

    VARIABLE        reduce using rule 8 (sentencias -> sentencia sentencias .)
    ECHO            reduce using rule 8 (sentencias -> sentencia sentencias .)
    PRINT           reduce using rule 8 (sentencias -> sentencia sentencias .)
    INT             reduce using rule 8 (sentencias -> sentencia sentencias .)
    FLOAT           reduce using rule 8 (sentencias -> sentencia sentencias .)
    FUNCTION        reduce using rule 8 (sentencias -> sentencia sentencias .)
    CLASS           reduce using rule 8 (sentencias -> sentencia sentencias .)
    WHILE           reduce using rule 8 (sentencias -> sentencia sentencias .)
    SWITCH          reduce using rule 8 (sentencias -> sentencia sentencias .)
    IF              reduce using rule 8 (sentencias -> sentencia sentencias .)
    FOR             reduce using rule 8 (sentencias -> sentencia sentencias .)
    $end            reduce using rule 8 (sentencias -> sentencia sentencias .)
    RBRACE          reduce using rule 8 (sentencias -> sentencia sentencias .)
    BREAK           reduce using rule 8 (sentencias -> sentencia sentencias .)


state 162

    (29) condition -> LPAREN conditionProdu RPAREN .

    RPAREN          reduce using rule 29 (condition -> LPAREN conditionProdu RPAREN .)
    AND             reduce using rule 29 (condition -> LPAREN conditionProdu RPAREN .)
    OR              reduce using rule 29 (condition -> LPAREN conditionProdu RPAREN .)
    NOT             reduce using rule 29 (condition -> LPAREN conditionProdu RPAREN .)
    QUESTION        reduce using rule 29 (condition -> LPAREN conditionProdu RPAREN .)
    SEMICOLON       reduce using rule 29 (condition -> LPAREN conditionProdu RPAREN .)
    COLON           reduce using rule 29 (condition -> LPAREN conditionProdu RPAREN .)


state 163

    (45) while -> WHILE LPAREN condition RPAREN LBRACE . body RBRACE
    (46) while -> WHILE LPAREN condition RPAREN LBRACE . RBRACE
    (91) body -> . sentencia
    (92) body -> . sentencia sentencias
    (93) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (131) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (111) comparacion -> . INT operador INT
    (112) comparacion -> . FLOAT operador FLOAT
    (113) comparacion -> . INT operador FLOAT
    (114) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (74) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (75) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (82) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

  ! shift/reduce conflict for RBRACE resolved as shift
    RBRACE          shift and go to state 187
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

  ! RBRACE          [ reduce using rule 131 (empty -> .) ]

    body                           shift and go to state 186
    sentencia                      shift and go to state 82
    empty                          shift and go to state 83
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 164

    (28) condition -> valor opSymbol valor .

    RPAREN          reduce using rule 28 (condition -> valor opSymbol valor .)
    AND             reduce using rule 28 (condition -> valor opSymbol valor .)
    OR              reduce using rule 28 (condition -> valor opSymbol valor .)
    NOT             reduce using rule 28 (condition -> valor opSymbol valor .)
    QUESTION        reduce using rule 28 (condition -> valor opSymbol valor .)
    SEMICOLON       reduce using rule 28 (condition -> valor opSymbol valor .)
    COLON           reduce using rule 28 (condition -> valor opSymbol valor .)


state 165

    (47) switch -> SWITCH LPAREN condition RPAREN LBRACE . caseLists RBRACE
    (48) switch -> SWITCH LPAREN condition RPAREN LBRACE . RBRACE
    (49) caseLists -> . cases default
    (50) caseLists -> . cases
    (51) caseLists -> . default
    (52) caseLists -> . empty
    (53) cases -> . case cases
    (54) cases -> . case
    (56) default -> . DEFAULT COLON body BREAK SEMICOLON
    (131) empty -> .
    (55) case -> . CASE valor COLON body BREAK SEMICOLON

  ! shift/reduce conflict for RBRACE resolved as shift
    RBRACE          shift and go to state 189
    DEFAULT         shift and go to state 194
    CASE            shift and go to state 195

  ! RBRACE          [ reduce using rule 131 (empty -> .) ]

    caseLists                      shift and go to state 188
    cases                          shift and go to state 190
    default                        shift and go to state 191
    empty                          shift and go to state 192
    case                           shift and go to state 193

state 166

    (25) statementif -> IF LPAREN conditionProdu RPAREN LBRACE . body RBRACE
    (91) body -> . sentencia
    (92) body -> . sentencia sentencias
    (93) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (131) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (111) comparacion -> . INT operador INT
    (112) comparacion -> . FLOAT operador FLOAT
    (113) comparacion -> . INT operador FLOAT
    (114) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (74) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (75) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (82) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    RBRACE          reduce using rule 131 (empty -> .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    body                           shift and go to state 196
    sentencia                      shift and go to state 82
    empty                          shift and go to state 83
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 167

    (27) conditionProdu -> condition opLogic conditionProdu .

    RPAREN          reduce using rule 27 (conditionProdu -> condition opLogic conditionProdu .)
    QUESTION        reduce using rule 27 (conditionProdu -> condition opLogic conditionProdu .)
    SEMICOLON       reduce using rule 27 (conditionProdu -> condition opLogic conditionProdu .)
    COLON           reduce using rule 27 (conditionProdu -> condition opLogic conditionProdu .)


state 168

    (42) forStatement -> FOR LPAREN forcondition RPAREN LBRACE . body RBRACE
    (91) body -> . sentencia
    (92) body -> . sentencia sentencias
    (93) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (131) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (111) comparacion -> . INT operador INT
    (112) comparacion -> . FLOAT operador FLOAT
    (113) comparacion -> . INT operador FLOAT
    (114) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (74) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (75) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (82) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    RBRACE          reduce using rule 131 (empty -> .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    body                           shift and go to state 197
    sentencia                      shift and go to state 82
    empty                          shift and go to state 83
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 169

    (43) forcondition -> VARIABLE EQUALS INT . SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS INT . SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    SEMICOLON       shift and go to state 198


state 170

    (82) array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .

    VARIABLE        reduce using rule 82 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    ECHO            reduce using rule 82 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    PRINT           reduce using rule 82 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    INT             reduce using rule 82 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 82 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    FUNCTION        reduce using rule 82 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    CLASS           reduce using rule 82 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    WHILE           reduce using rule 82 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    SWITCH          reduce using rule 82 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    IF              reduce using rule 82 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    FOR             reduce using rule 82 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    $end            reduce using rule 82 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 82 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)
    BREAK           reduce using rule 82 (array -> VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON .)


state 171

    (85) array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .
    (86) map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .

  ! reduce/reduce conflict for VARIABLE resolved using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for ECHO resolved using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for PRINT resolved using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for INT resolved using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for FLOAT resolved using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for CLASS resolved using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for WHILE resolved using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for SWITCH resolved using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for IF resolved using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for FOR resolved using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for $end resolved using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for RBRACE resolved using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
  ! reduce/reduce conflict for BREAK resolved using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    VARIABLE        reduce using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    ECHO            reduce using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    PRINT           reduce using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    INT             reduce using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    FUNCTION        reduce using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    CLASS           reduce using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    WHILE           reduce using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    SWITCH          reduce using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    IF              reduce using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    FOR             reduce using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    $end            reduce using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)
    BREAK           reduce using rule 85 (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .)

  ! VARIABLE        [ reduce using rule 86 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! ECHO            [ reduce using rule 86 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! PRINT           [ reduce using rule 86 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! INT             [ reduce using rule 86 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 86 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! FUNCTION        [ reduce using rule 86 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! CLASS           [ reduce using rule 86 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! WHILE           [ reduce using rule 86 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! SWITCH          [ reduce using rule 86 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! IF              [ reduce using rule 86 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! FOR             [ reduce using rule 86 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! $end            [ reduce using rule 86 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! RBRACE          [ reduce using rule 86 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]
  ! BREAK           [ reduce using rule 86 (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON .) ]


state 172

    (90) mapArrow -> valor ARROWMAP valor .

    COMMA           reduce using rule 90 (mapArrow -> valor ARROWMAP valor .)
    RBRACKET        reduce using rule 90 (mapArrow -> valor ARROWMAP valor .)
    RPAREN          reduce using rule 90 (mapArrow -> valor ARROWMAP valor .)


state 173

    (89) mapProduc -> mapArrow COMMA mapProduc .

    RBRACKET        reduce using rule 89 (mapProduc -> mapArrow COMMA mapProduc .)
    RPAREN          reduce using rule 89 (mapProduc -> mapArrow COMMA mapProduc .)


state 174

    (90) mapArrow -> valor . ARROWMAP valor

    ARROWMAP        shift and go to state 144


state 175

    (83) array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 199


state 176

    (84) array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN . SEMICOLON
    (87) map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 200


state 177

    (73) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros . RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    RPAREN          shift and go to state 201


state 178

    (68) parametro -> ID EQUALS valor .

    COMMA           reduce using rule 68 (parametro -> ID EQUALS valor .)
    RPAREN          reduce using rule 68 (parametro -> ID EQUALS valor .)


state 179

    (64) parametros -> parametro COMMA parametros .

    RPAREN          reduce using rule 64 (parametros -> parametro COMMA parametros .)


state 180

    (69) parametro -> dataType ID EQUALS . valor
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    valor                          shift and go to state 202
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 181

    (59) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE . funcionBody RBRACE
    (61) funcionBody -> . body
    (62) funcionBody -> . RETURN expresion SEMICOLON
    (91) body -> . sentencia
    (92) body -> . sentencia sentencias
    (93) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (131) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (111) comparacion -> . INT operador INT
    (112) comparacion -> . FLOAT operador FLOAT
    (113) comparacion -> . INT operador FLOAT
    (114) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (74) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (75) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (82) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    RETURN          shift and go to state 205
    RBRACE          reduce using rule 131 (empty -> .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    funcionBody                    shift and go to state 203
    body                           shift and go to state 204
    sentencia                      shift and go to state 82
    empty                          shift and go to state 83
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 182

    (60) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT . dataType LBRACE funcionBody RBRACE
    (106) dataType -> . INTEGER
    (107) dataType -> . FLOATING
    (108) dataType -> . STRINGS
    (109) dataType -> . BOOLEAN
    (110) dataType -> . VOID

    INTEGER         shift and go to state 109
    FLOATING        shift and go to state 110
    STRINGS         shift and go to state 111
    BOOLEAN         shift and go to state 112
    VOID            shift and go to state 113

    dataType                       shift and go to state 206

state 183

    (78) classMember -> dataType VARIABLE SEMICOLON .

    INTEGER         reduce using rule 78 (classMember -> dataType VARIABLE SEMICOLON .)
    FLOATING        reduce using rule 78 (classMember -> dataType VARIABLE SEMICOLON .)
    STRINGS         reduce using rule 78 (classMember -> dataType VARIABLE SEMICOLON .)
    BOOLEAN         reduce using rule 78 (classMember -> dataType VARIABLE SEMICOLON .)
    VOID            reduce using rule 78 (classMember -> dataType VARIABLE SEMICOLON .)
    RBRACE          reduce using rule 78 (classMember -> dataType VARIABLE SEMICOLON .)


state 184

    (79) classMember -> dataType FUNCTION ID . LPAREN parametros RPAREN brace

    LPAREN          shift and go to state 207


state 185

    (75) classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody . RBRACE

    RBRACE          shift and go to state 208


state 186

    (45) while -> WHILE LPAREN condition RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 209


state 187

    (46) while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .

    VARIABLE        reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    ECHO            reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    PRINT           reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    INT             reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    FLOAT           reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    FUNCTION        reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    CLASS           reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    WHILE           reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    SWITCH          reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    IF              reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    FOR             reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    $end            reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    RBRACE          reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)
    BREAK           reduce using rule 46 (while -> WHILE LPAREN condition RPAREN LBRACE RBRACE .)


state 188

    (47) switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists . RBRACE

    RBRACE          shift and go to state 210


state 189

    (48) switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .

    VARIABLE        reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    ECHO            reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    PRINT           reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    INT             reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    FLOAT           reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    FUNCTION        reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    CLASS           reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    WHILE           reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    SWITCH          reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    IF              reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    FOR             reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    $end            reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    RBRACE          reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)
    BREAK           reduce using rule 48 (switch -> SWITCH LPAREN condition RPAREN LBRACE RBRACE .)


state 190

    (49) caseLists -> cases . default
    (50) caseLists -> cases .
    (56) default -> . DEFAULT COLON body BREAK SEMICOLON

    RBRACE          reduce using rule 50 (caseLists -> cases .)
    DEFAULT         shift and go to state 194

    default                        shift and go to state 211

state 191

    (51) caseLists -> default .

    RBRACE          reduce using rule 51 (caseLists -> default .)


state 192

    (52) caseLists -> empty .

    RBRACE          reduce using rule 52 (caseLists -> empty .)


state 193

    (53) cases -> case . cases
    (54) cases -> case .
    (53) cases -> . case cases
    (54) cases -> . case
    (55) case -> . CASE valor COLON body BREAK SEMICOLON

    DEFAULT         reduce using rule 54 (cases -> case .)
    RBRACE          reduce using rule 54 (cases -> case .)
    CASE            shift and go to state 195

    case                           shift and go to state 193
    cases                          shift and go to state 212

state 194

    (56) default -> DEFAULT . COLON body BREAK SEMICOLON

    COLON           shift and go to state 213


state 195

    (55) case -> CASE . valor COLON body BREAK SEMICOLON
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 38
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45

    valor                          shift and go to state 214
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44

state 196

    (25) statementif -> IF LPAREN conditionProdu RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 215


state 197

    (42) forStatement -> FOR LPAREN forcondition RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 216


state 198

    (43) forcondition -> VARIABLE EQUALS INT SEMICOLON . VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS INT SEMICOLON . VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS

    VARIABLE        shift and go to state 217


state 199

    (83) array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .

    VARIABLE        reduce using rule 83 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    ECHO            reduce using rule 83 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    PRINT           reduce using rule 83 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    INT             reduce using rule 83 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    FLOAT           reduce using rule 83 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 83 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    CLASS           reduce using rule 83 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    WHILE           reduce using rule 83 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    SWITCH          reduce using rule 83 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    IF              reduce using rule 83 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    FOR             reduce using rule 83 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    $end            reduce using rule 83 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    RBRACE          reduce using rule 83 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)
    BREAK           reduce using rule 83 (array -> VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON .)


state 200

    (84) array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .
    (87) map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .

  ! reduce/reduce conflict for VARIABLE resolved using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for ECHO resolved using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for PRINT resolved using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for INT resolved using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FLOAT resolved using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for CLASS resolved using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for WHILE resolved using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for SWITCH resolved using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for IF resolved using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for FOR resolved using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for $end resolved using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for RBRACE resolved using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
  ! reduce/reduce conflict for BREAK resolved using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    VARIABLE        reduce using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    ECHO            reduce using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    PRINT           reduce using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    INT             reduce using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    FLOAT           reduce using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    CLASS           reduce using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    WHILE           reduce using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    SWITCH          reduce using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    IF              reduce using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    FOR             reduce using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    $end            reduce using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    RBRACE          reduce using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)
    BREAK           reduce using rule 84 (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .)

  ! VARIABLE        [ reduce using rule 87 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! ECHO            [ reduce using rule 87 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! PRINT           [ reduce using rule 87 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! INT             [ reduce using rule 87 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 87 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! FUNCTION        [ reduce using rule 87 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! CLASS           [ reduce using rule 87 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! WHILE           [ reduce using rule 87 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! SWITCH          [ reduce using rule 87 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! IF              [ reduce using rule 87 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! FOR             [ reduce using rule 87 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! $end            [ reduce using rule 87 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! RBRACE          [ reduce using rule 87 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]
  ! BREAK           [ reduce using rule 87 (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON .) ]


state 201

    (73) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN . LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    LBRACE          shift and go to state 218


state 202

    (69) parametro -> dataType ID EQUALS valor .

    COMMA           reduce using rule 69 (parametro -> dataType ID EQUALS valor .)
    RPAREN          reduce using rule 69 (parametro -> dataType ID EQUALS valor .)


state 203

    (59) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody . RBRACE

    RBRACE          shift and go to state 219


state 204

    (61) funcionBody -> body .

    RBRACE          reduce using rule 61 (funcionBody -> body .)


state 205

    (62) funcionBody -> RETURN . expresion SEMICOLON
    (120) expresion -> . valor
    (121) expresion -> . operaArit
    (122) expresion -> . conditionProdu
    (123) expresion -> . ternario
    (124) expresion -> . accessMember
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (117) operaArit -> . valor
    (118) operaArit -> . valor operador operaArit
    (119) operaArit -> . valor DOT valor
    (26) conditionProdu -> . condition
    (27) conditionProdu -> . condition opLogic conditionProdu
    (130) ternario -> . conditionProdu QUESTION expresion COLON expresion
    (80) accessMember -> . VARIABLE ARROW ID
    (81) accessMember -> . VARIABLE ARROW funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 226
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45
    LPAREN          shift and go to state 85

    expresion                      shift and go to state 220
    valor                          shift and go to state 221
    operaArit                      shift and go to state 222
    conditionProdu                 shift and go to state 223
    ternario                       shift and go to state 224
    accessMember                   shift and go to state 225
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44
    condition                      shift and go to state 90

state 206

    (60) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType . LBRACE funcionBody RBRACE

    LBRACE          shift and go to state 227


state 207

    (79) classMember -> dataType FUNCTION ID LPAREN . parametros RPAREN brace
    (63) parametros -> . parametro
    (64) parametros -> . parametro COMMA parametros
    (65) parametros -> . empty
    (66) parametro -> . ID
    (67) parametro -> . dataType ID
    (68) parametro -> . ID EQUALS valor
    (69) parametro -> . dataType ID EQUALS valor
    (131) empty -> .
    (106) dataType -> . INTEGER
    (107) dataType -> . FLOATING
    (108) dataType -> . STRINGS
    (109) dataType -> . BOOLEAN
    (110) dataType -> . VOID

    ID              shift and go to state 104
    RPAREN          reduce using rule 131 (empty -> .)
    INTEGER         shift and go to state 109
    FLOATING        shift and go to state 110
    STRINGS         shift and go to state 111
    BOOLEAN         shift and go to state 112
    VOID            shift and go to state 113

    dataType                       shift and go to state 108
    parametros                     shift and go to state 228
    parametro                      shift and go to state 106
    empty                          shift and go to state 107

state 208

    (75) classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .

    VARIABLE        reduce using rule 75 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    ECHO            reduce using rule 75 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    PRINT           reduce using rule 75 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    INT             reduce using rule 75 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    FLOAT           reduce using rule 75 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    FUNCTION        reduce using rule 75 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    CLASS           reduce using rule 75 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    WHILE           reduce using rule 75 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    SWITCH          reduce using rule 75 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    IF              reduce using rule 75 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    FOR             reduce using rule 75 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    $end            reduce using rule 75 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    RBRACE          reduce using rule 75 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)
    BREAK           reduce using rule 75 (classDeclarate -> CLASS ID EXTENDS ID LBRACE classBody RBRACE .)


state 209

    (45) while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .

    VARIABLE        reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    ECHO            reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    FLOAT           reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    FUNCTION        reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    CLASS           reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    SWITCH          reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)
    BREAK           reduce using rule 45 (while -> WHILE LPAREN condition RPAREN LBRACE body RBRACE .)


state 210

    (47) switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .

    VARIABLE        reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    ECHO            reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    PRINT           reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    INT             reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    FLOAT           reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    FUNCTION        reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    CLASS           reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    WHILE           reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    SWITCH          reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    IF              reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    FOR             reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    $end            reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    RBRACE          reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)
    BREAK           reduce using rule 47 (switch -> SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE .)


state 211

    (49) caseLists -> cases default .

    RBRACE          reduce using rule 49 (caseLists -> cases default .)


state 212

    (53) cases -> case cases .

    DEFAULT         reduce using rule 53 (cases -> case cases .)
    RBRACE          reduce using rule 53 (cases -> case cases .)


state 213

    (56) default -> DEFAULT COLON . body BREAK SEMICOLON
    (91) body -> . sentencia
    (92) body -> . sentencia sentencias
    (93) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (131) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (111) comparacion -> . INT operador INT
    (112) comparacion -> . FLOAT operador FLOAT
    (113) comparacion -> . INT operador FLOAT
    (114) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (74) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (75) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (82) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    BREAK           reduce using rule 131 (empty -> .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    body                           shift and go to state 229
    sentencia                      shift and go to state 82
    empty                          shift and go to state 83
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 214

    (55) case -> CASE valor . COLON body BREAK SEMICOLON

    COLON           shift and go to state 230


state 215

    (25) statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .

    ELSE            reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    ELSEIF          reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    VARIABLE        reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    ECHO            reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    FLOAT           reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    FUNCTION        reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    CLASS           reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    SWITCH          reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)
    BREAK           reduce using rule 25 (statementif -> IF LPAREN conditionProdu RPAREN LBRACE body RBRACE .)


state 216

    (42) forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .

    VARIABLE        reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    ECHO            reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    INT             reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    FLOAT           reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    FUNCTION        reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    CLASS           reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    SWITCH          reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)
    BREAK           reduce using rule 42 (forStatement -> FOR LPAREN forcondition RPAREN LBRACE body RBRACE .)


state 217

    (43) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE . opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE . opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS
    (30) opSymbol -> . EQ
    (31) opSymbol -> . NEQ
    (32) opSymbol -> . STRICTEQ
    (33) opSymbol -> . STRICTNEQ
    (34) opSymbol -> . LT
    (35) opSymbol -> . GT
    (36) opSymbol -> . LEQ
    (37) opSymbol -> . GEQ

    EQ              shift and go to state 126
    NEQ             shift and go to state 127
    STRICTEQ        shift and go to state 128
    STRICTNEQ       shift and go to state 129
    LT              shift and go to state 130
    GT              shift and go to state 131
    LEQ             shift and go to state 132
    GEQ             shift and go to state 133

    opSymbol                       shift and go to state 231

state 218

    (73) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE . RETURN expresion SEMICOLON RBRACE SEMICOLON

    RETURN          shift and go to state 232


state 219

    (59) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .

    VARIABLE        reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    ECHO            reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    PRINT           reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    INT             reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    FLOAT           reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    FUNCTION        reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    CLASS           reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    WHILE           reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    SWITCH          reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    IF              reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    FOR             reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    $end            reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    RBRACE          reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)
    BREAK           reduce using rule 59 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE .)


state 220

    (62) funcionBody -> RETURN expresion . SEMICOLON

    SEMICOLON       shift and go to state 233


state 221

    (120) expresion -> valor .
    (117) operaArit -> valor .
    (118) operaArit -> valor . operador operaArit
    (119) operaArit -> valor . DOT valor
    (28) condition -> valor . opSymbol valor
    (125) operador -> . PLUS
    (126) operador -> . MINUS
    (127) operador -> . TIMES
    (128) operador -> . DIVIDE
    (129) operador -> . MODULO
    (30) opSymbol -> . EQ
    (31) opSymbol -> . NEQ
    (32) opSymbol -> . STRICTEQ
    (33) opSymbol -> . STRICTNEQ
    (34) opSymbol -> . LT
    (35) opSymbol -> . GT
    (36) opSymbol -> . LEQ
    (37) opSymbol -> . GEQ

  ! reduce/reduce conflict for SEMICOLON resolved using rule 117 (operaArit -> valor .)
  ! reduce/reduce conflict for COLON resolved using rule 117 (operaArit -> valor .)
    SEMICOLON       reduce using rule 117 (operaArit -> valor .)
    COLON           reduce using rule 117 (operaArit -> valor .)
    DOT             shift and go to state 100
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    TIMES           shift and go to state 50
    DIVIDE          shift and go to state 51
    MODULO          shift and go to state 52
    EQ              shift and go to state 126
    NEQ             shift and go to state 127
    STRICTEQ        shift and go to state 128
    STRICTNEQ       shift and go to state 129
    LT              shift and go to state 130
    GT              shift and go to state 131
    LEQ             shift and go to state 132
    GEQ             shift and go to state 133

  ! SEMICOLON       [ reduce using rule 120 (expresion -> valor .) ]
  ! COLON           [ reduce using rule 120 (expresion -> valor .) ]

    operador                       shift and go to state 99
    opSymbol                       shift and go to state 125

state 222

    (121) expresion -> operaArit .

    SEMICOLON       reduce using rule 121 (expresion -> operaArit .)
    COLON           reduce using rule 121 (expresion -> operaArit .)


state 223

    (122) expresion -> conditionProdu .
    (130) ternario -> conditionProdu . QUESTION expresion COLON expresion

    SEMICOLON       reduce using rule 122 (expresion -> conditionProdu .)
    COLON           reduce using rule 122 (expresion -> conditionProdu .)
    QUESTION        shift and go to state 234


state 224

    (123) expresion -> ternario .

    SEMICOLON       reduce using rule 123 (expresion -> ternario .)
    COLON           reduce using rule 123 (expresion -> ternario .)


state 225

    (124) expresion -> accessMember .

    SEMICOLON       reduce using rule 124 (expresion -> accessMember .)
    COLON           reduce using rule 124 (expresion -> accessMember .)


state 226

    (99) valor -> VARIABLE .
    (80) accessMember -> VARIABLE . ARROW ID
    (81) accessMember -> VARIABLE . ARROW funcionParen
    (73) funcionAnonima -> VARIABLE . EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON

    DOT             reduce using rule 99 (valor -> VARIABLE .)
    PLUS            reduce using rule 99 (valor -> VARIABLE .)
    MINUS           reduce using rule 99 (valor -> VARIABLE .)
    TIMES           reduce using rule 99 (valor -> VARIABLE .)
    DIVIDE          reduce using rule 99 (valor -> VARIABLE .)
    MODULO          reduce using rule 99 (valor -> VARIABLE .)
    EQ              reduce using rule 99 (valor -> VARIABLE .)
    NEQ             reduce using rule 99 (valor -> VARIABLE .)
    STRICTEQ        reduce using rule 99 (valor -> VARIABLE .)
    STRICTNEQ       reduce using rule 99 (valor -> VARIABLE .)
    LT              reduce using rule 99 (valor -> VARIABLE .)
    GT              reduce using rule 99 (valor -> VARIABLE .)
    LEQ             reduce using rule 99 (valor -> VARIABLE .)
    GEQ             reduce using rule 99 (valor -> VARIABLE .)
    SEMICOLON       reduce using rule 99 (valor -> VARIABLE .)
    COLON           reduce using rule 99 (valor -> VARIABLE .)
    ARROW           shift and go to state 235
    EQUALS          shift and go to state 70


state 227

    (60) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE . funcionBody RBRACE
    (61) funcionBody -> . body
    (62) funcionBody -> . RETURN expresion SEMICOLON
    (91) body -> . sentencia
    (92) body -> . sentencia sentencias
    (93) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (131) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (111) comparacion -> . INT operador INT
    (112) comparacion -> . FLOAT operador FLOAT
    (113) comparacion -> . INT operador FLOAT
    (114) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (74) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (75) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (82) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    RETURN          shift and go to state 205
    RBRACE          reduce using rule 131 (empty -> .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    funcionBody                    shift and go to state 236
    body                           shift and go to state 204
    sentencia                      shift and go to state 82
    empty                          shift and go to state 83
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 228

    (79) classMember -> dataType FUNCTION ID LPAREN parametros . RPAREN brace

    RPAREN          shift and go to state 237


state 229

    (56) default -> DEFAULT COLON body . BREAK SEMICOLON

    BREAK           shift and go to state 238


state 230

    (55) case -> CASE valor COLON . body BREAK SEMICOLON
    (91) body -> . sentencia
    (92) body -> . sentencia sentencias
    (93) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (131) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (111) comparacion -> . INT operador INT
    (112) comparacion -> . FLOAT operador FLOAT
    (113) comparacion -> . INT operador FLOAT
    (114) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (74) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (75) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (82) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    BREAK           reduce using rule 131 (empty -> .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    body                           shift and go to state 239
    sentencia                      shift and go to state 82
    empty                          shift and go to state 83
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 231

    (43) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol . INT SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol . INT SEMICOLON VARIABLE DOUBLEMINUS

    INT             shift and go to state 240


state 232

    (73) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN . expresion SEMICOLON RBRACE SEMICOLON
    (120) expresion -> . valor
    (121) expresion -> . operaArit
    (122) expresion -> . conditionProdu
    (123) expresion -> . ternario
    (124) expresion -> . accessMember
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (117) operaArit -> . valor
    (118) operaArit -> . valor operador operaArit
    (119) operaArit -> . valor DOT valor
    (26) conditionProdu -> . condition
    (27) conditionProdu -> . condition opLogic conditionProdu
    (130) ternario -> . conditionProdu QUESTION expresion COLON expresion
    (80) accessMember -> . VARIABLE ARROW ID
    (81) accessMember -> . VARIABLE ARROW funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 226
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45
    LPAREN          shift and go to state 85

    expresion                      shift and go to state 241
    valor                          shift and go to state 221
    operaArit                      shift and go to state 222
    conditionProdu                 shift and go to state 223
    ternario                       shift and go to state 224
    accessMember                   shift and go to state 225
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44
    condition                      shift and go to state 90

state 233

    (62) funcionBody -> RETURN expresion SEMICOLON .

    RBRACE          reduce using rule 62 (funcionBody -> RETURN expresion SEMICOLON .)


state 234

    (130) ternario -> conditionProdu QUESTION . expresion COLON expresion
    (120) expresion -> . valor
    (121) expresion -> . operaArit
    (122) expresion -> . conditionProdu
    (123) expresion -> . ternario
    (124) expresion -> . accessMember
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (117) operaArit -> . valor
    (118) operaArit -> . valor operador operaArit
    (119) operaArit -> . valor DOT valor
    (26) conditionProdu -> . condition
    (27) conditionProdu -> . condition opLogic conditionProdu
    (130) ternario -> . conditionProdu QUESTION expresion COLON expresion
    (80) accessMember -> . VARIABLE ARROW ID
    (81) accessMember -> . VARIABLE ARROW funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 226
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45
    LPAREN          shift and go to state 85

    conditionProdu                 shift and go to state 223
    expresion                      shift and go to state 242
    valor                          shift and go to state 221
    operaArit                      shift and go to state 222
    ternario                       shift and go to state 224
    accessMember                   shift and go to state 225
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44
    condition                      shift and go to state 90

state 235

    (80) accessMember -> VARIABLE ARROW . ID
    (81) accessMember -> VARIABLE ARROW . funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN

    ID              shift and go to state 243

    funcionParen                   shift and go to state 244

state 236

    (60) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody . RBRACE

    RBRACE          shift and go to state 245


state 237

    (79) classMember -> dataType FUNCTION ID LPAREN parametros RPAREN . brace
    (71) brace -> . LBRACE body RBRACE

    LBRACE          shift and go to state 247

    brace                          shift and go to state 246

state 238

    (56) default -> DEFAULT COLON body BREAK . SEMICOLON

    SEMICOLON       shift and go to state 248


state 239

    (55) case -> CASE valor COLON body . BREAK SEMICOLON

    BREAK           shift and go to state 249


state 240

    (43) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT . SEMICOLON VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT . SEMICOLON VARIABLE DOUBLEMINUS

    SEMICOLON       shift and go to state 250


state 241

    (73) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion . SEMICOLON RBRACE SEMICOLON

    SEMICOLON       shift and go to state 251


state 242

    (130) ternario -> conditionProdu QUESTION expresion . COLON expresion

    COLON           shift and go to state 252


state 243

    (80) accessMember -> VARIABLE ARROW ID .
    (72) funcionParen -> ID . LPAREN parametros RPAREN

    SEMICOLON       reduce using rule 80 (accessMember -> VARIABLE ARROW ID .)
    COLON           reduce using rule 80 (accessMember -> VARIABLE ARROW ID .)
    LPAREN          shift and go to state 71


state 244

    (81) accessMember -> VARIABLE ARROW funcionParen .

    SEMICOLON       reduce using rule 81 (accessMember -> VARIABLE ARROW funcionParen .)
    COLON           reduce using rule 81 (accessMember -> VARIABLE ARROW funcionParen .)


state 245

    (60) funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .

    VARIABLE        reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    ECHO            reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    PRINT           reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    INT             reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    FLOAT           reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    FUNCTION        reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    CLASS           reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    WHILE           reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    SWITCH          reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    IF              reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    FOR             reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    $end            reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    RBRACE          reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)
    BREAK           reduce using rule 60 (funcionDeclarate -> FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE .)


state 246

    (79) classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .

    INTEGER         reduce using rule 79 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    FLOATING        reduce using rule 79 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    STRINGS         reduce using rule 79 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    BOOLEAN         reduce using rule 79 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    VOID            reduce using rule 79 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)
    RBRACE          reduce using rule 79 (classMember -> dataType FUNCTION ID LPAREN parametros RPAREN brace .)


state 247

    (71) brace -> LBRACE . body RBRACE
    (91) body -> . sentencia
    (92) body -> . sentencia sentencias
    (93) body -> . empty
    (3) sentencia -> . asignacion
    (4) sentencia -> . impresion
    (5) sentencia -> . comparacion
    (6) sentencia -> . estructurasProgram
    (131) empty -> .
    (10) asignacion -> . VARIABLE EQUALS operaArit SEMICOLON
    (11) impresion -> . ECHO imprimir SEMICOLON
    (12) impresion -> . PRINT imprimir SEMICOLON
    (111) comparacion -> . INT operador INT
    (112) comparacion -> . FLOAT operador FLOAT
    (113) comparacion -> . INT operador FLOAT
    (114) comparacion -> . FLOAT operador INT
    (13) estructurasProgram -> . controlStructure
    (14) estructurasProgram -> . dataStructure
    (15) estructurasProgram -> . funcionDeclarate
    (16) estructurasProgram -> . classDeclarate
    (17) controlStructure -> . if
    (18) controlStructure -> . for
    (19) controlStructure -> . while
    (20) controlStructure -> . switch
    (57) dataStructure -> . array
    (58) dataStructure -> . map
    (59) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN LBRACE funcionBody RBRACE
    (60) funcionDeclarate -> . FUNCTION ID LPAREN parametros RPAREN DOUBLEDOT dataType LBRACE funcionBody RBRACE
    (74) classDeclarate -> . CLASS ID LBRACE classBody RBRACE
    (75) classDeclarate -> . CLASS ID EXTENDS ID LBRACE classBody RBRACE
    (21) if -> . statementif ELSE body
    (22) if -> . statementif ELSE if
    (23) if -> . statementif ELSEIF if
    (24) if -> . statementif
    (41) for -> . forStatement
    (45) while -> . WHILE LPAREN condition RPAREN LBRACE body RBRACE
    (46) while -> . WHILE LPAREN condition RPAREN LBRACE RBRACE
    (47) switch -> . SWITCH LPAREN condition RPAREN LBRACE caseLists RBRACE
    (48) switch -> . SWITCH LPAREN condition RPAREN LBRACE RBRACE
    (82) array -> . VARIABLE EQUALS LBRACKET repiteValores RBRACKET SEMICOLON
    (83) array -> . VARIABLE EQUALS ARRAY LPAREN repiteValores RPAREN SEMICOLON
    (84) array -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (85) array -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (86) map -> . VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON
    (87) map -> . VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON
    (25) statementif -> . IF LPAREN conditionProdu RPAREN LBRACE body RBRACE
    (42) forStatement -> . FOR LPAREN forcondition RPAREN LBRACE body RBRACE

    RBRACE          reduce using rule 131 (empty -> .)
    VARIABLE        shift and go to state 7
    ECHO            shift and go to state 8
    PRINT           shift and go to state 9
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    FUNCTION        shift and go to state 22
    CLASS           shift and go to state 23
    WHILE           shift and go to state 26
    SWITCH          shift and go to state 27
    IF              shift and go to state 28
    FOR             shift and go to state 29

    body                           shift and go to state 253
    sentencia                      shift and go to state 82
    empty                          shift and go to state 83
    asignacion                     shift and go to state 3
    impresion                      shift and go to state 4
    comparacion                    shift and go to state 5
    estructurasProgram             shift and go to state 6
    controlStructure               shift and go to state 12
    dataStructure                  shift and go to state 13
    funcionDeclarate               shift and go to state 14
    classDeclarate                 shift and go to state 15
    if                             shift and go to state 16
    for                            shift and go to state 17
    while                          shift and go to state 18
    switch                         shift and go to state 19
    array                          shift and go to state 20
    map                            shift and go to state 21
    statementif                    shift and go to state 24
    forStatement                   shift and go to state 25

state 248

    (56) default -> DEFAULT COLON body BREAK SEMICOLON .

    RBRACE          reduce using rule 56 (default -> DEFAULT COLON body BREAK SEMICOLON .)


state 249

    (55) case -> CASE valor COLON body BREAK . SEMICOLON

    SEMICOLON       shift and go to state 254


state 250

    (43) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON . VARIABLE DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON . VARIABLE DOUBLEMINUS

    VARIABLE        shift and go to state 255


state 251

    (73) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON . RBRACE SEMICOLON

    RBRACE          shift and go to state 256


state 252

    (130) ternario -> conditionProdu QUESTION expresion COLON . expresion
    (120) expresion -> . valor
    (121) expresion -> . operaArit
    (122) expresion -> . conditionProdu
    (123) expresion -> . ternario
    (124) expresion -> . accessMember
    (97) valor -> . INT
    (98) valor -> . FLOAT
    (99) valor -> . VARIABLE
    (100) valor -> . STRING
    (101) valor -> . TRUE
    (102) valor -> . FALSE
    (103) valor -> . THIS
    (104) valor -> . funcionParen
    (105) valor -> . funcionAnonima
    (117) operaArit -> . valor
    (118) operaArit -> . valor operador operaArit
    (119) operaArit -> . valor DOT valor
    (26) conditionProdu -> . condition
    (27) conditionProdu -> . condition opLogic conditionProdu
    (130) ternario -> . conditionProdu QUESTION expresion COLON expresion
    (80) accessMember -> . VARIABLE ARROW ID
    (81) accessMember -> . VARIABLE ARROW funcionParen
    (72) funcionParen -> . ID LPAREN parametros RPAREN
    (73) funcionAnonima -> . VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON
    (28) condition -> . valor opSymbol valor
    (29) condition -> . LPAREN conditionProdu RPAREN

    INT             shift and go to state 36
    FLOAT           shift and go to state 37
    VARIABLE        shift and go to state 226
    STRING          shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    THIS            shift and go to state 42
    ID              shift and go to state 45
    LPAREN          shift and go to state 85

    conditionProdu                 shift and go to state 223
    expresion                      shift and go to state 257
    valor                          shift and go to state 221
    operaArit                      shift and go to state 222
    ternario                       shift and go to state 224
    accessMember                   shift and go to state 225
    funcionParen                   shift and go to state 43
    funcionAnonima                 shift and go to state 44
    condition                      shift and go to state 90

state 253

    (71) brace -> LBRACE body . RBRACE

    RBRACE          shift and go to state 258


state 254

    (55) case -> CASE valor COLON body BREAK SEMICOLON .

    CASE            reduce using rule 55 (case -> CASE valor COLON body BREAK SEMICOLON .)
    DEFAULT         reduce using rule 55 (case -> CASE valor COLON body BREAK SEMICOLON .)
    RBRACE          reduce using rule 55 (case -> CASE valor COLON body BREAK SEMICOLON .)


state 255

    (43) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE . DOUBLEPLUS
    (44) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE . DOUBLEMINUS

    DOUBLEPLUS      shift and go to state 259
    DOUBLEMINUS     shift and go to state 260


state 256

    (73) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 261


state 257

    (130) ternario -> conditionProdu QUESTION expresion COLON expresion .

    SEMICOLON       reduce using rule 130 (ternario -> conditionProdu QUESTION expresion COLON expresion .)
    COLON           reduce using rule 130 (ternario -> conditionProdu QUESTION expresion COLON expresion .)


state 258

    (71) brace -> LBRACE body RBRACE .

    INTEGER         reduce using rule 71 (brace -> LBRACE body RBRACE .)
    FLOATING        reduce using rule 71 (brace -> LBRACE body RBRACE .)
    STRINGS         reduce using rule 71 (brace -> LBRACE body RBRACE .)
    BOOLEAN         reduce using rule 71 (brace -> LBRACE body RBRACE .)
    VOID            reduce using rule 71 (brace -> LBRACE body RBRACE .)
    RBRACE          reduce using rule 71 (brace -> LBRACE body RBRACE .)


state 259

    (43) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS .

    RPAREN          reduce using rule 43 (forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEPLUS .)


state 260

    (44) forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS .

    RPAREN          reduce using rule 44 (forcondition -> VARIABLE EQUALS INT SEMICOLON VARIABLE opSymbol INT SEMICOLON VARIABLE DOUBLEMINUS .)


state 261

    (73) funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .

    COMMA           reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    SEMICOLON       reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    DOT             reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    PLUS            reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    MINUS           reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    TIMES           reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    DIVIDE          reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    MODULO          reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    RPAREN          reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    EQ              reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    NEQ             reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    STRICTEQ        reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    STRICTNEQ       reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    LT              reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    GT              reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    LEQ             reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    GEQ             reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    ARROWMAP        reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    RBRACKET        reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    COLON           reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    AND             reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    OR              reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    NOT             reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)
    QUESTION        reduce using rule 73 (funcionAnonima -> VARIABLE EQUALS FUNCTION LPAREN parametros RPAREN LBRACE RETURN expresion SEMICOLON RBRACE SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 56 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 56 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 56 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 56 resolved as shift
WARNING: shift/reduce conflict for INT in state 56 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 56 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 56 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 56 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 56 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 56 resolved as shift
WARNING: shift/reduce conflict for FOR in state 56 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 82 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 82 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 82 resolved as shift
WARNING: shift/reduce conflict for INT in state 82 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 82 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 82 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 82 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 82 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 82 resolved as shift
WARNING: shift/reduce conflict for IF in state 82 resolved as shift
WARNING: shift/reduce conflict for FOR in state 82 resolved as shift
WARNING: shift/reduce conflict for VARIABLE in state 120 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 120 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 120 resolved as shift
WARNING: shift/reduce conflict for INT in state 120 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 120 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 120 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 120 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 120 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 120 resolved as shift
WARNING: shift/reduce conflict for IF in state 120 resolved as shift
WARNING: shift/reduce conflict for FOR in state 120 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 163 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 165 resolved as shift
WARNING: reduce/reduce conflict in state 81 resolved using rule (controlStructure -> if)
WARNING: rejected rule (if -> statementif ELSE if) in state 81
WARNING: reduce/reduce conflict in state 82 resolved using rule (body -> sentencia)
WARNING: rejected rule (empty -> <empty>) in state 82
WARNING: reduce/reduce conflict in state 120 resolved using rule (sentencias -> sentencia)
WARNING: rejected rule (empty -> <empty>) in state 120
WARNING: reduce/reduce conflict in state 171 resolved using rule (array -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON)
WARNING: rejected rule (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON) in state 171
WARNING: reduce/reduce conflict in state 200 resolved using rule (array -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON)
WARNING: rejected rule (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON) in state 200
WARNING: reduce/reduce conflict in state 221 resolved using rule (operaArit -> valor)
WARNING: rejected rule (expresion -> valor) in state 221
WARNING: Rule (if -> statementif ELSE if) is never reduced
WARNING: Rule (map -> VARIABLE EQUALS LBRACKET mapProduc RBRACKET SEMICOLON) is never reduced
WARNING: Rule (map -> VARIABLE EQUALS ARRAY LPAREN mapProduc RPAREN SEMICOLON) is never reduced
WARNING: Rule (expresion -> valor) is never reduced
